///|
/// ================================================================================
/// # LLVM Codegen: æ•°ç»„çš„è®¿é—®ä¸æ›´æ–°
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»å­¦ä¼šäº†å¦‚ä½•åˆ›å»ºæ•°ç»„ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¥å­¦ä¹ å¦‚ä½•ä¸æ•°ç»„è¿›è¡Œäº¤äº’ï¼š
/// è¯»å–æ•°ç»„ä¸­çš„å…ƒç´ ï¼ˆ`get`ï¼‰å’Œæ›´æ–°æ•°ç»„ä¸­çš„å…ƒç´ ï¼ˆ`put`ï¼‰ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯æ‰©å±• `expr_codegen` å’Œ `stmt_codegen`ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†ï¼š
/// 1.  **æ•°ç»„è®¿é—®è¡¨è¾¾å¼** (`KnfExpr::ArrayAccess`)
/// 2.  **æ•°ç»„æ›´æ–°è¯­å¥** (`KnfStmt::ArrayPut`)
///
/// ## ğŸ’¡ å®ç°æŒ‡å—ï¼šè°ƒç”¨å†…å»ºå‡½æ•°
///
/// ä¸æ•°ç»„åˆ›å»ºä¸€æ ·ï¼Œå¯¹æ•°ç»„çš„è®¿é—®å’Œæ›´æ–°ä¹Ÿæ˜¯é€šè¿‡è°ƒç”¨ `Context` ä¸­é¢„å…ˆå®šä¹‰å¥½çš„å†…å»ºå‡½æ•°æ¥å®Œæˆçš„ã€‚
/// ä½ éœ€è¦åšçš„å°±æ˜¯æ ¹æ®æ•°ç»„çš„å…ƒç´ ç±»å‹ï¼Œé€‰æ‹©æ­£ç¡®çš„å‡½æ•°å¹¶ä½¿ç”¨ `builder.createCall` æ¥è°ƒç”¨å®ƒã€‚
///
/// ### æ•°ç»„å…ƒç´ è®¿é—® (Get)
///
/// åœ¨ `expr_codegen` ä¸­å¤„ç† `ArrayAccess(array_name, index_name)` æ—¶ï¼š
///
/// 1.  **ç¡®å®šç±»å‹**: æ£€æŸ¥ `array_name` çš„ KNF ç±»å‹ï¼Œç¡®å®šå…¶å…ƒç´ ç±»å‹ï¼ˆå¦‚ `Int`, `Double` ç­‰ï¼‰ã€‚
/// 2.  **é€‰æ‹©å‡½æ•°**: æ ¹æ®å…ƒç´ ç±»å‹ï¼Œä» `builtin_funcs` ä¸­è·å–å¯¹åº”çš„ `get` å‡½æ•°ï¼ˆå¦‚ `"array_int_get"`ï¼‰ã€‚
/// 3.  **ç”Ÿæˆè°ƒç”¨**: ä½¿ç”¨ `createCall` ç”Ÿæˆå¯¹è¯¥å‡½æ•°çš„è°ƒç”¨ï¼Œå‚æ•°ä¸ºæ•°ç»„çš„æŒ‡é’ˆå’Œç´¢å¼•å€¼ã€‚
///
/// ### æ•°ç»„å…ƒç´ æ›´æ–° (Put)
///
/// åœ¨ `stmt_codegen` ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„åˆ†æ”¯æ¥å¤„ç† `ArrayPut(array_name, index_name, value_expr)` è¯­å¥ï¼š
///
/// 1.  **è®¡ç®—å³å€¼**: é¦–å…ˆï¼Œè°ƒç”¨ `expr_codegen` è®¡ç®—å‡º `value_expr` çš„ LLVM å€¼ã€‚
/// 2.  **ç¡®å®šç±»å‹**: æ£€æŸ¥ `array_name` çš„ KNF ç±»å‹ä»¥ç¡®å®šå…ƒç´ ç±»å‹ã€‚
/// 3.  **é€‰æ‹©å‡½æ•°**: æ ¹æ®å…ƒç´ ç±»å‹ï¼Œä» `builtin_funcs` ä¸­è·å–å¯¹åº”çš„ `put` å‡½æ•°ï¼ˆå¦‚ `"array_int_put"`ï¼‰ã€‚
/// 4.  **ç”Ÿæˆè°ƒç”¨**: ä½¿ç”¨ `createCall` ç”Ÿæˆè°ƒç”¨ï¼Œå‚æ•°ä¸ºæ•°ç»„æŒ‡é’ˆã€ç´¢å¼•å€¼å’Œè¦å­˜å…¥çš„æ–°å€¼ã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_array_acc_and_put_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½æ­£ç¡®ç”Ÿæˆå¯¹ `get` å’Œ `put` å†…å»ºå‡½æ•°çš„è°ƒç”¨ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
test "Codegen for Array Make Test" {
  let code =
    #|fn swap_head_two(arr: Array[Int]) -> Unit {
    #|  let t = arr[0];
    #|  arr[0] = arr[1];
    #|  arr[1] = t;
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // make_arr
  let swap_head_two = knf_prog.functions.get("swap_head_two").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(swap_head_two)
  inspect(
    llvm_func,
    content=(
      #|define void @swap_head_two(ptr %0) {
      #|entry:
      #|  %1 = call i32 @array_int_get(ptr %0, i32 0)
      #|  %2 = call i32 @array_int_get(ptr %0, i32 1)
      #|  call void @array_int_put(ptr %0, i32 0, i32 %2)
      #|  call void @array_int_put(ptr %0, i32 1, i32 %1)
      #|  ret void
      #|}
      #|
    ),
  )
}

///|
/// ================================================================================
/// # LLVM Codegen: æ•°ç»„å­—é¢é‡
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»å­¦ä¹ äº† `Array::make`ï¼Œç°åœ¨æˆ‘ä»¬æ¥å¤„ç†å¦ä¸€ç§æ›´ç›´è§‚çš„æ•°ç»„åˆ›å»ºæ–¹å¼ï¼š**æ•°ç»„å­—é¢é‡ï¼ˆArray Literalsï¼‰**ï¼Œä¾‹å¦‚ `[1, 2, 3]`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯æ‰©å±• `expr_codegen` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç† `KnfExpr::ArrayLiteral` è¡¨è¾¾å¼ã€‚
///
/// ## ğŸ’¡ å®ç°æŒ‡å—ï¼šä¸‰æ­¥èµ°
///
/// ç”Ÿæˆæ•°ç»„å­—é¢é‡çš„ä»£ç å¯ä»¥åˆ†è§£ä¸ºä¸‰ä¸ªæ­¥éª¤ï¼š
///
/// 1.  **åˆ›å»ºç©ºæ•°ç»„**:
///     é¦–å…ˆï¼Œè°ƒç”¨æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `make_..._array` å†…å»ºå‡½æ•°æ¥åˆ›å»ºä¸€ä¸ªæŒ‡å®šå¤§å°ä½†å†…å®¹ä¸ºé»˜è®¤å€¼çš„æ•°ç»„ã€‚
///     - **å¤§å°**: æ•°ç»„å­—é¢é‡ä¸­çš„å…ƒç´ æ•°é‡ã€‚
///     - **åˆå§‹å€¼**: å¯ä»¥æ˜¯è¯¥ç±»å‹çš„ä»»æ„é»˜è®¤å€¼ï¼ˆä¾‹å¦‚ `0` æˆ– `false`ï¼‰ï¼Œå› ä¸ºå®ƒé©¬ä¸Šå°±ä¼šè¢«è¦†ç›–ã€‚
///
/// 2.  **é€ä¸ªå¡«å……å…ƒç´ **:
///     éå†æ•°ç»„å­—é¢é‡ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ã€‚å¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œç”Ÿæˆä¸€ä¸ª `array_..._put` è°ƒç”¨ï¼Œ
///     å°†å…ƒç´ çš„å€¼è®¾ç½®åˆ°æ•°ç»„å¯¹åº”çš„ç´¢å¼•ä½ç½®ä¸Šã€‚
///
/// 3.  **è¿”å›æ•°ç»„**:
///     æœ€åï¼Œè¿”å›ç¬¬ä¸€æ­¥ä¸­åˆ›å»ºçš„æ•°ç»„çš„æŒ‡é’ˆã€‚
///
/// ç®€å•æ¥è¯´ï¼Œ`[1, 2, 3]` çš„ä»£ç ç”Ÿæˆé€»è¾‘ç­‰ä»·äºï¼š
///
/// ```skip
/// let __internal_array = Array::make(3, 0); // æ­¥éª¤ 1
/// __internal_array[0] = 1;                  // æ­¥éª¤ 2
/// __internal_array[1] = 2;
/// __internal_array[2] = 3;
/// __internal_array;                         // æ­¥éª¤ 3
/// ```
///
/// åŒæ ·ï¼Œä½ éœ€è¦æ ¹æ®æ•°ç»„çš„å…ƒç´ ç±»å‹ï¼Œä» `Context` çš„ `builtin_funcs` ä¸­é€‰æ‹©æ­£ç¡®çš„ `make` å’Œ `put` å‡½æ•°ï¼Œå¹¶ä½¿ç”¨ `createCall` æ¥è°ƒç”¨å®ƒä»¬ã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_array_expr_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºæ•°ç»„å­—é¢é‡æ­£ç¡®ç”Ÿæˆåˆ›å»ºå’Œå¡«å……æŒ‡ä»¤ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
test "Codegen for Array Literal Test" {
  let code =
    #|fn create_arr() -> Array[Int] {
    #|  [1, 2, 3];
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // codegen
  let create_arr = knf_prog.functions.get("create_arr").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(create_arr)
  inspect(
    llvm_func,
    content=(
      #|define ptr @create_arr() {
      #|entry:
      #|  %0 = call ptr @make_int_array(i32 3, i32 0)
      #|  call void @array_int_put(ptr %0, i32 0, i32 1)
      #|  call void @array_int_put(ptr %0, i32 1, i32 2)
      #|  call void @array_int_put(ptr %0, i32 2, i32 3)
      #|  ret ptr %0
      #|}
      #|
    ),
  )
}

///|
test "Codegen for Array Make Test - 2" {
  let code =
    #|fn make_arr(x: Int) -> Array[Int] {
    #|  let arr = Array::make(x, 0);
    #|  arr
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // make_arr
  let make_arr = knf_prog.functions.get("make_arr").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(make_arr)
  inspect(
    llvm_func,
    content=(
      #|define ptr @make_arr(i32 %0) {
      #|entry:
      #|  %1 = call ptr @make_int_array(i32 %0, i32 0)
      #|  ret ptr %1
      #|}
      #|
    ),
  )
}

///|
///
test "Codegen for Simple Let and LetMut Test" {
  let code =
    #|fn foo(x: Int) -> Int {
    #|  let mut z = 0;
    #|  z = x;
    #|  z
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // foo
  let add = knf_prog.functions.get("foo").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(add)
  inspect(
    llvm_func,
    content=(
      #|define i32 @foo(i32 %0) {
      #|entry:
      #|  %1 = alloca i32, align 4
      #|  store i32 0, ptr %1, align 4
      #|  store i32 %0, ptr %1, align 4
      #|  %4 = load i32, ptr %1, align 4
      #|  ret i32 %4
      #|}
      #|
    ),
  )
}

///|
test "Codegen for Simple Binary Test" {
  let code =
    #|fn arith_int(x: Int, y: Int) -> Int {
    #|  let z = x + y;
    #|  let z = x - y;
    #|  let z = x * y;
    #|  let z = x / y;
    #|  let z = x % y;
    #|  z
    #|}
    #|
    #|fn arith_double(x: Double, y: Double) -> Double {
    #|  let z = x + y;
    #|  let z = x - y;
    #|  let z = x * y;
    #|  let z = x / y;
    #|  z
    #|}
    #|
    #|fn int_cmp(x: Int, y: Int) -> Bool {
    #|  let a = x == y;
    #|  let b = x != y;
    #|  let c = x < y;
    #|  let d = x <= y;
    #|  let e = x > y;
    #|  let f = x >= y;
    #|  f
    #|}
    #|
    #|fn double_cmp(x: Double, y: Double) -> Bool {
    #|  let a = x == y;
    #|  let b = x != y;
    #|  let c = x < y;
    #|  let d = x <= y;
    #|  let e = x > y;
    #|  let f = x >= y;
    #|  f
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // arith_int
  let arith_int = knf_prog.functions.get("arith_int").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(arith_int)
  inspect(
    llvm_func,
    content=(
      #|define i32 @arith_int(i32 %0, i32 %1) {
      #|entry:
      #|  %2 = add i32 %0, %1
      #|  %3 = sub i32 %0, %1
      #|  %4 = mul i32 %0, %1
      #|  %5 = sdiv i32 %0, %1
      #|  %6 = srem i32 %0, %1
      #|  ret i32 %6
      #|}
      #|
    ),
  )

  // arith_double
  let arith_double = knf_prog.functions.get("arith_double").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(arith_double)
  inspect(
    llvm_func,
    content=(
      #|define double @arith_double(double %0, double %1) {
      #|entry:
      #|  %2 = fadd double %0, %1
      #|  %3 = fsub double %0, %1
      #|  %4 = fmul double %0, %1
      #|  %5 = fdiv double %0, %1
      #|  ret double %5
      #|}
      #|
    ),
  )

  // int_cmp
  let int_cmp = knf_prog.functions.get("int_cmp").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(int_cmp)
  inspect(
    llvm_func,
    content=(
      #|define i1 @int_cmp(i32 %0, i32 %1) {
      #|entry:
      #|  %2 = icmp eq i32 %0, %1
      #|  %3 = icmp ne i32 %0, %1
      #|  %4 = icmp slt i32 %0, %1
      #|  %5 = icmp sle i32 %0, %1
      #|  %6 = icmp sgt i32 %0, %1
      #|  %7 = icmp sge i32 %0, %1
      #|  ret i1 %7
      #|}
      #|
    ),
  )

  // double_cmp
  let double_cmp = knf_prog.functions.get("double_cmp").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(double_cmp)
  inspect(
    llvm_func,
    content=(
      #|define i1 @double_cmp(double %0, double %1) {
      #|entry:
      #|  %2 = fcmp oeq double %0, %1
      #|  %3 = fcmp one double %0, %1
      #|  %4 = fcmp olt double %0, %1
      #|  %5 = fcmp ole double %0, %1
      #|  %6 = fcmp ogt double %0, %1
      #|  %7 = fcmp oge double %0, %1
      #|  ret i1 %7
      #|}
      #|
    ),
  )
}

///|
///
test "Codegen for Simple Let and LetMut Test - 2" {
  let code =
    #|fn foo(x: Int, y: Int) -> Int {
    #|  let z = { let a = x + 1; let b = y -1; a * b };
    #|  z
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // foo
  let foo = knf_prog.functions.get("foo").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(foo)
  inspect(
    llvm_func,
    content=(
      #|define i32 @foo(i32 %0, i32 %1) {
      #|entry:
      #|  br label %3
      #|
      #|3:                                     ; preds = %entry
      #|  %4 = add i32 %0, 1
      #|  %5 = sub i32 %1, 1
      #|  %6 = mul i32 %4, %5
      #|  br label %8
      #|
      #|8:                                     ; preds = %3
      #|  ret i32 %6
      #|}
      #|
    ),
  )
}

///|
test "Codegen Call Test" {
  let code =
    #|fn add(x: Int, y: Int) -> Int {
    #|  x + y;
    #|}
    #|
    #|fn main {
    #|  let result = add(2, 3);
    #|  println(result);
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)
  let func = knf_prog.functions.get("add").unwrap()
  let _ = codegen_ctx.top_function_codegen(func)
  let main_func = knf_prog.functions.get("main").unwrap()
  let main_ir = codegen_ctx.top_function_codegen(main_func)
  inspect(
    main_ir,
    content=(
      #|define void @moonbit_main() {
      #|entry:
      #|  %0 = call i32 @add(i32 2, i32 3)
      #|  call void @__builtin_println_int(i32 %0)
      #|  ret void 
      #|}
      #|
    ),
  )
}

///|
test "Codegen Closure Test" {
  let code =
    #|fn make_adder(x: Int) -> (Int) -> Int {
    #|  fn adder(y: Int) -> Int {
    #|    x + y;
    #|  }
    #|  adder;
    #|}
    #|
    #|fn main {
    #|  let add_five = make_adder(5);
    #|  let result = add_five(10);
    #|  println(result);
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)
  let make_adder_func = knf_prog.functions.get("make_adder").unwrap()
  let make_adder_ir = codegen_ctx.top_function_codegen(make_adder_func)
  inspect(
    make_adder_ir,
    content=(
      #|define ptr @make_adder(i32 %0) {
      #|entry:
      #|  %1 = call ptr @moonbit_malloc(i32 16)
      #|  %2 = getelementptr { ptr, i32 }, ptr %1, i32 0, i32 0
      #|  store ptr @make_adder$adder, ptr %2, align 8
      #|  %4 = getelementptr { ptr, i32 }, ptr %1, i32 0, i32 1
      #|  store i32 %0, ptr %4, align 4
      #|  ret ptr %1
      #|}
      #|
    ),
  )
  let main_func = knf_prog.functions.get("main").unwrap()
  let main_ir = codegen_ctx.top_function_codegen(main_func)
  inspect(
    main_ir,
    content=(
      #|define void @moonbit_main() {
      #|entry:
      #|  %0 = call ptr @make_adder(i32 5)
      #|  %1 = getelementptr { ptr }, ptr %0, i32 0, i32 0
      #|  %2 = load ptr, ptr %1, align 8
      #|  %3 = call i32 %2(ptr %0, i32 10)
      #|  call void @__builtin_println_int(i32 %3)
      #|  ret void 
      #|}
      #|
    ),
  )
}
/// ================================================================================
/// # LLVM Codegen
//
// åœ¨æˆ‘ä»¬æ·±å…¥ä»£ç ç”Ÿæˆä¹‹å‰ï¼Œç†è§£ä¸¤ä¸ªæ ¸å¿ƒæ¦‚å¿µè‡³å…³é‡è¦ï¼šSSA å’Œ LLVMã€‚
//
// ## é™æ€å•èµ‹å€¼ï¼ˆStatic Single Assignment, SSAï¼‰
//
// SSA æ˜¯ä¸€ç§ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰çš„ç‰¹æ€§ï¼Œå®ƒè¦æ±‚æ¯ä¸ªå˜é‡éƒ½åªè¢«èµ‹å€¼ä¸€æ¬¡ã€‚
// å¦‚æœåœ¨åŸå§‹ä»£ç ä¸­ä¸€ä¸ªå˜é‡è¢«å¤šæ¬¡èµ‹å€¼ï¼Œé‚£ä¹ˆåœ¨ SSA å½¢å¼ä¸­ï¼Œæ¯æ¬¡èµ‹å€¼éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ã€å¸¦ç‰ˆæœ¬å·çš„å˜é‡ã€‚
//
// ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç ï¼š
//
// ```
// let mut x = 1;
// x = x + 1;
// ```
//
// åœ¨ SSA å½¢å¼ä¸‹ä¼šå˜æˆï¼š
//
// ```
// x_1 = 1;
// x_2 = x_1 + 1;
// ```
//
// **ä¸ºä»€ä¹ˆ SSA å¦‚æ­¤é‡è¦ï¼Ÿ**
//
// è¿™ç§å½¢å¼æå¤§åœ°ç®€åŒ–äº†ç¼–è¯‘å™¨çš„ä¼˜åŒ–è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼š
// - **å¸¸é‡ä¼ æ’­**ï¼šå¦‚æœ `x_1` æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œç¼–è¯‘å™¨å¯ä»¥ç«‹å³å°†æ‰€æœ‰ä½¿ç”¨ `x_1` çš„åœ°æ–¹æ›¿æ¢ä¸ºè¯¥å¸¸é‡ã€‚
// - **æ­»ç æ¶ˆé™¤**ï¼šå¦‚æœä¸€ä¸ªå˜é‡ï¼ˆå¦‚ `x_2`ï¼‰ä»æœªè¢«ä½¿ç”¨è¿‡ï¼Œç¼–è¯‘å™¨å¯ä»¥å®‰å…¨åœ°ç§»é™¤åˆ›å»ºå®ƒçš„é‚£è¡Œä»£ç ã€‚
//
// æˆ‘ä»¬çš„ KNFï¼ˆKernel Normal Formï¼‰ä¸­é—´è¡¨ç¤ºå°±æ˜¯ä¸ºç”Ÿæˆ SSA å½¢å¼çš„ä»£ç åšå‡†å¤‡çš„ã€‚
//
// ## LLVMï¼šç°ä»£ç¼–è¯‘å™¨çš„åŸºçŸ³
//
// LLVM æœ€åˆæ˜¯â€œåº•å±‚è™šæ‹Ÿæœºâ€ï¼ˆLow Level Virtual Machineï¼‰çš„ç¼©å†™ï¼Œä½†ç°åœ¨å®ƒå·²ç»å‘å±•æˆä¸ºä¸€ä¸ªåºå¤§çš„ã€
// åŒ…å«ä¸€ç³»åˆ—æ¨¡å—åŒ–å’Œå¯é‡ç”¨ç¼–è¯‘å™¨åŠå·¥å…·é“¾æŠ€æœ¯çš„æ€»ç§°ã€‚å®ƒä¸ä»…ä»…æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œæ›´æ˜¯ä¸€ä¸ªâ€œç¼–è¯‘å™¨çš„ç¼–è¯‘å™¨â€ã€‚
//
// **LLVM çš„æ ¸å¿ƒæ˜¯å…¶å¼ºå¤§ä¸”å®šä¹‰è‰¯å¥½çš„ä¸­é—´è¡¨ç¤ºï¼ˆLLVM IRï¼‰ï¼Œè€Œ LLVM IR æ­£æ˜¯åŸºäº SSA çš„ã€‚**
//
// **å·¥ä½œæµç¨‹ï¼š**
//
// 1.  **å‰ç«¯ï¼ˆFrontendï¼‰**ï¼šåƒæˆ‘ä»¬æ­£åœ¨æ„å»ºçš„ MiniMoonBit ç¼–è¯‘å™¨ï¼Œè´Ÿè´£å°†æºä»£ç ï¼ˆ`.mbt` æ–‡ä»¶ï¼‰è§£æã€ç±»å‹æ£€æŸ¥ï¼Œå¹¶è½¬æ¢ä¸ºä¸­é—´è¡¨ç¤ºï¼ˆæˆ‘ä»¬çš„ KNFï¼‰ã€‚
// 2.  **ä¸­é—´è¡¨ç¤ºè½¬æ¢**ï¼šæˆ‘ä»¬å°† KNF è½¬æ¢ä¸º LLVM IRã€‚
// 3.  **LLVM ä¼˜åŒ–å™¨ï¼ˆOptimizerï¼‰**ï¼šLLVM ä¼šå¯¹ç”Ÿæˆçš„ IR è¿›è¡Œå¤§é‡çš„ä¼˜åŒ–ï¼Œä½¿å…¶æ›´é«˜æ•ˆã€‚
// 4.  **åç«¯ï¼ˆBackendï¼‰/ä»£ç ç”Ÿæˆå™¨ï¼ˆCode Generatorï¼‰**ï¼šLLVM å°†ä¼˜åŒ–åçš„ IR è½¬æ¢ä¸ºç‰¹å®šç¡¬ä»¶å¹³å°ï¼ˆå¦‚ x86, ARMï¼‰çš„æœºå™¨ç ã€‚
//
// é€šè¿‡åˆ©ç”¨ LLVMï¼Œæˆ‘ä»¬æ— éœ€ä»é›¶å¼€å§‹ç¼–å†™å¤æ‚çš„ä¼˜åŒ–ç®—æ³•å’Œé’ˆå¯¹ä¸åŒç¡¬ä»¶çš„ä»£ç ç”Ÿæˆå™¨ï¼Œ
// è€Œæ˜¯å¯ä»¥ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šï¼Œç”Ÿæˆé«˜è´¨é‡ã€é«˜æ€§èƒ½çš„æœºå™¨ç ã€‚
//
// åœ¨æ¥ä¸‹æ¥çš„æŒ‘æˆ˜ä¸­ï¼Œä½ å°†äº²æ‰‹ä½¿ç”¨ MoonBit çš„ LLVM API æ¥å°† KNF è½¬æ¢ä¸º LLVM IRã€‚
//
// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
/// ================================================================================

///|
///
/// demo_addåˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„LLVMå‡½æ•°æ¥æ·»åŠ ä¸¤ä¸ªæ•´æ•°ã€‚
/// å¦‚æœæˆ‘ä»¬å†™Cä»£ç ï¼Œå°±åƒè¿™æ ·ï¼š
///
/// ```c
/// int add(int a, int b) {
///   return a + b;
/// }
/// ```
///
/// ä½ çš„ä»»åŠ¡æ˜¯å®ç°demo_addä¸‹é¢çš„demo_fmaä»£ç ï¼Œé€»è¾‘ä¸ºï¼š
///
/// ```c
/// double fma(double a, double b, double c) {
///   return a * b + c;
/// }
/// ```
///
/// æç¤ºï¼š
///
/// - ä½¿ç”¨ `getDoubleTy` æ¥è·å– double ç±»å‹ã€‚
/// - ä½¿ç”¨ `createFMul` æ¥åˆ›å»ºæµ®ç‚¹ä¹˜æ³•æŒ‡ä»¤ã€‚
/// - ä½¿ç”¨ `createFAdd` æ¥åˆ›å»ºæµ®ç‚¹åŠ æ³•æŒ‡ä»¤ã€‚
fn demo_add() -> @llvm.Function raise {
  // Contextæ˜¯LLVMçš„æ ¸å¿ƒå¯¹è±¡ï¼Œç®¡ç†ç€æ‰€æœ‰çš„LLVMæ•°æ®ç»“æ„ã€‚
  // ä¾‹å¦‚ç±»å‹ã€æ¨¡å—å’ŒæŒ‡ä»¤ç”Ÿæˆå™¨ç­‰ã€‚
  let ctx = @llvm.Context::new()

  // ä½¿ç”¨contextæ¥åˆ›å»ºä¸€ä¸ªæ¨¡å—ã€‚æ¨¡å—æ˜¯LLVMä¸­ä»£ç çš„å®¹å™¨ã€‚
  let mod = ctx.addModule("demo")

  // æŒ‡ä»¤ç”Ÿæˆå™¨ç”¨äºåœ¨åŸºæœ¬å—ä¸­ç”ŸæˆLLVMæŒ‡ä»¤ã€‚
  // è®°å¾—åœ¨ç”ŸæˆæŒ‡ä»¤å‰è®¾ç½®æ’å…¥ç‚¹ã€‚
  // ä½¿ç”¨`setInsertPoint`æ–¹æ³•è®¾ç½®æ’å…¥ç‚¹ã€‚`
  let builder = ctx.createBuilder()

  // åˆ›å»ºå‡½æ•°ç±»å‹å’Œå‡½æ•°ã€‚ä½¿ç”¨`getInt32Ty`è·å–32ä½æ•´æ•°ç±»å‹ã€‚
  let i32ty = ctx.getInt32Ty()

  // ä½¿ç”¨`getFunctionType`åˆ›å»ºå‡½æ•°ç±»å‹ï¼Œä¼ å…¥è¿”å›ç±»å‹å’Œå‚æ•°ç±»å‹åˆ—è¡¨ã€‚
  // åœ¨åŸå§‹çš„llvm Cæ¥å£ä¸­ï¼Œå‡½æ•°ç±»å‹è¿˜éœ€è¦ä¸€ä¸ªå¸ƒå°”å€¼å‚æ•°è¡¨ç¤ºæ˜¯å¦æ˜¯å¯å˜å‚æ•°å‡½æ•°ã€‚
  // åœ¨MoonBitä¸­ï¼Œè¿™ä¸ªå‚æ•°è¢«æ ‡è®°æˆlabelå‚æ•°ï¼Œå…è®¸çœç•¥ã€‚
  // åœ¨æˆ‘ä»¬çš„æ•™ç¨‹ä¸­ï¼Œæ‰€æœ‰å‡½æ•°éƒ½ä¸æ˜¯å¯å˜å‚æ•°å‡½æ•°ï¼Œæ‰€ä»¥å¯ä»¥çœç•¥è¿™ä¸ªå‚æ•°ã€‚
  let fn_type = ctx.getFunctionType(i32ty, [i32ty, i32ty])

  // åˆ›å»ºå‡½æ•°å¯¹è±¡ï¼Œæ³¨æ„å‡½æ•°åœ¨æ¨¡å—ä¸­åˆ›å»ºã€‚
  // å› æ­¤éœ€è¦è°ƒç”¨çš„æ˜¯æ¨¡å—çš„æ–¹æ³•`addFunction`ã€‚
  let fval = mod.addFunction(fn_type, "add")

  // åˆ›å»ºåŸºæœ¬å—å¯¹è±¡ï¼Œæ³¨æ„åŸºæœ¬å—åœ¨å‡½æ•°ä¸­åˆ›å»ºã€‚
  // å› æ­¤éœ€è¦è°ƒç”¨çš„æ˜¯å‡½æ•°çš„æ–¹æ³•`addBasicBlock`ã€‚
  let entry_bb = fval.addBasicBlock(name="entry")

  // æ¥ä¸‹æ¥åœ¨åŸºæœ¬å—ä¸­ç”ŸæˆæŒ‡ä»¤ã€‚éœ€è¦ä½¿ç”¨builderæ¥æ„å»ºæŒ‡ä»¤ï¼Œåœ¨æ„å»ºæŒ‡ä»¤å‰éœ€è¦è®¾ç½®æ’å…¥ç‚¹ã€‚
  builder.setInsertPoint(entry_bb)

  // è·å¾—å‚æ•°ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“å‡½æ•°æœ‰ä¸¤ä¸ªå‚æ•°ï¼Œå› æ­¤ç›´æ¥ä½¿ç”¨getArg(index).unwrap()æ¥è·å–å‚æ•°ã€‚
  // getArgä¹‹åunwrapï¼Œå¾—åˆ°çš„ç±»å‹æ˜¯ä¸€ä¸ª`&Value`ï¼Œå®ƒæ˜¯ä¸€ä¸ªtrait Objectã€‚åœ¨llvmé‡Œï¼Œæˆ‘ä»¬ä¼šæœ‰
  // å¾ˆå¤šç§ä¸åŒçš„Valueï¼Œä¾‹å¦‚æŒ‡ä»¤ï¼Œå¸¸é‡ï¼Œå‡½æ•°å‚æ•°ç­‰ï¼Œå®ƒä»¬éƒ½å®ç°äº†Valueè¿™ä¸ªtraitã€‚
  let arg0 = fval.getArg(0).unwrap()
  let arg1 = fval.getArg(1).unwrap()

  // åˆ›å»ºåŠ æ³•æŒ‡ä»¤ï¼Œä½¿ç”¨createAddæ–¹æ³•ã€‚æ‰€æœ‰çš„æŒ‡ä»¤åˆ›å»ºæ–¹æ³•éƒ½åœ¨builderå¯¹è±¡ä¸Šã€‚
  // å®ƒæ¥æ”¶ä¸¤ä¸ª`&Value`å‚æ•°ï¼Œæœ‰ä¸€ä¸ªlabel argumentç”¨äºç»™æŒ‡ä»¤å‘½åã€‚
  // ä½ å¯ä»¥çœç•¥label argument.
  //
  // æ³¨æ„ï¼ŒcreateAddæ–¹æ³•æ¥æ”¶çš„ä¸¤ä¸ªå‚æ•°å¿…é¡»æ˜¯æ•´æ•°ç±»å‹ã€‚ä¸”ç±»å‹éœ€è¦ä¸€è‡´ï¼Œå¦‚æœä¸ä¸€è‡´ï¼Œä¼šå‡ºç°è¿è¡Œæ—¶
  // é”™è¯¯ã€‚
  //
  // å¦‚æœæ˜¯æµ®ç‚¹æ•°åŠ æ³•ï¼Œéœ€è¦ä½¿ç”¨createFAddæ–¹æ³•ï¼Œå…¶ä»–ç±»ä¼¼ã€‚
  let sum = builder.createAdd(arg0, arg1, name="sum")

  // åˆ›å»ºè¿”å›æŒ‡ä»¤ï¼Œä½¿ç”¨createRetæ–¹æ³•ï¼Œæ³¨æ„createRetæ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªæŒ‡ä»¤å¯¹è±¡ï¼Œ
  // ä½†æˆ‘ä»¬è¿™é‡Œä¸éœ€è¦ä½¿ç”¨å®ƒï¼Œå› æ­¤ä½¿ç”¨let _æ¥å¿½ç•¥å®ƒã€‚
  let _ = builder.createRet(sum)

  // è¿”å›å‡½æ•°å¯¹è±¡ã€‚
  // å¦‚æœä½ è°ƒç”¨è¿™ä¸ªå‡½æ•°ç”ŸæˆLLVM IRä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ç”Ÿæˆçš„ä»£ç å¦‚ä¸‹ï¼š
  //
  // ```llvm
  // ; ModuleID = 'demo'
  //
  // define i32 @add(i32 %0, i32 %1) {
  // entry:
  //  %sum = add i32 %0, %1
  //  ret i32 %sum
  // }
  // ```
  fval
}

///|
fn demo_fma() -> @llvm.Function raise {
  let ctx = @llvm.Context::new()
  let mod = ctx.addModule("demo_fma")
  let builder = ctx.createBuilder()
  let double_ty = ctx.getDoubleTy()
  let fn_type = ctx.getFunctionType(double_ty, [double_ty, double_ty, double_ty])
  let fval = mod.addFunction(fn_type, "fma")
  let entry_bb = fval.addBasicBlock(name="entry")
  builder.setInsertPoint(entry_bb)
  let arg0 = fval.getArg(0).unwrap()
  let arg1 = fval.getArg(1).unwrap()
  let arg2 = fval.getArg(2).unwrap()
  let mul = builder.createFMul(arg0, arg1, name="mul")
  let result = builder.createFAdd(mul, arg2, name="result")
  let _ = builder.createRet(result)
  fval
}

///|
test "LLVM Codegen Demo Test" {
  let add = demo_add()
  inspect(
    add,
    content=(
      #|define i32 @add(i32 %0, i32 %1) {
      #|entry:
      #|  %sum = add i32 %0, %1
      #|  ret i32 %sum
      #|}
      #|
    ),
  )
  let fadd = demo_fma()
  inspect(
    fadd,
    content=(
      #|define double @fma(double %0, double %1, double %2) {
      #|entry:
      #|  %mul = fmul double %0, %1
      #|  %result = fadd double %mul, %2
      #|  ret double %result
      #|}
      #|
    ),
  )
}
/// ================================================================================
/// # LLVM Codegen: åˆ›å»ºç»“æ„ä½“ç±»å‹
///
/// åœ¨ä¸Šä¸€ä¸ªæŒ‘æˆ˜ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº†å¦‚ä½•åˆ›å»ºç®€å•çš„ LLVM å‡½æ•°ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•åœ¨ LLVM ä¸­å®šä¹‰å¤åˆç±»å‹ï¼Œ
/// å³**ç»“æ„ä½“ï¼ˆStructsï¼‰**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯ LLVM ç»“æ„ä½“ç±»å‹ï¼Ÿ
///
/// LLVM ä¸­çš„ç»“æ„ä½“ç±»å‹ä¸ C è¯­è¨€ä¸­çš„ `struct` éå¸¸ç›¸ä¼¼ã€‚å®ƒå…è®¸æˆ‘ä»¬å°†å¤šä¸ªä¸åŒç±»å‹çš„æ•°æ®æˆå‘˜ï¼ˆå­—æ®µï¼‰
/// ç»„åˆæˆä¸€ä¸ªå•ä¸€çš„ã€è¿ç»­çš„å†…å­˜å—ã€‚è¿™å¯¹äºè¡¨ç¤ºå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œå¦‚åæ ‡ç‚¹ã€ç”¨æˆ·ä¿¡æ¯æˆ– AST èŠ‚ç‚¹è‡³å…³é‡è¦ã€‚
///
/// LLVM æ”¯æŒä¸¤ç§ç»“æ„ä½“ç±»å‹ï¼š
///
/// 1.  **å­—é¢ç»“æ„ä½“ï¼ˆLiteral Structsï¼‰**ï¼šå®ƒä»¬æ˜¯åŒ¿åçš„ï¼Œé€šè¿‡å…¶å­—æ®µçš„ç±»å‹åºåˆ—æ¥å®šä¹‰ï¼Œä¾‹å¦‚ `{ i32, double }`ã€‚
/// 2.  **å·²è¯†åˆ«ç»“æ„ä½“ï¼ˆIdentified Structsï¼‰**ï¼šå®ƒä»¬æœ‰è‡ªå·±çš„åå­—ï¼Œä¾‹å¦‚ `%Point = type { i32, i32 }`ã€‚
///     åœ¨æˆ‘ä»¬çš„ç¼–è¯‘å™¨ä¸­ï¼Œæˆ‘ä»¬å°†ä¸»è¦ä½¿ç”¨å·²è¯†åˆ«ç»“æ„ä½“ï¼Œå› ä¸ºå®ƒä»¬æ›´æ˜“äºè°ƒè¯•å’Œå¼•ç”¨ã€‚
///
/// ## ğŸ› ï¸ å¦‚ä½•åˆ›å»ºç»“æ„ä½“ç±»å‹ï¼Ÿ
///
//  åœ¨ MoonBit çš„ LLVM API ä¸­ï¼Œåˆ›å»ºç»“æ„ä½“ç±»å‹éå¸¸ç›´æ¥ï¼š
///
/// 1.  **è·å–ä¸Šä¸‹æ–‡ï¼ˆContextï¼‰**ï¼šå’Œä¹‹å‰ä¸€æ ·ï¼Œæ‰€æœ‰æ“ä½œéƒ½å§‹äº `llvm.Context`ã€‚
///
/// 2.  **è·å–å­—æ®µç±»å‹**ï¼šä½¿ç”¨ `ctx.getInt32Ty()`ã€`ctx.getDoubleTy()` ç­‰æ–¹æ³•è·å–æ„æˆç»“æ„ä½“çš„åŸºæœ¬ç±»å‹ã€‚
///
/// 3.  **åˆ›å»ºç»“æ„ä½“ç±»å‹**ï¼šè°ƒç”¨ `ctx.getStructType` æ–¹æ³•ã€‚
///
///     ```moonbit
///     let struct_ty = ctx.getStructType(
///       [i32ty, f64ty], // å­—æ®µç±»å‹çš„æ•°ç»„
///       name="i32_f64"  // ç»“æ„ä½“çš„åå­—ï¼ˆæ¨èï¼‰
///     );
///     ```
///
///     - ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªåŒ…å«æ‰€æœ‰å­—æ®µç±»å‹çš„ `Array`ã€‚
///     - `name` æ˜¯ä¸€ä¸ªå¯é€‰çš„æ ‡ç­¾å‚æ•°ï¼Œç”¨äºç»™ç»“æ„ä½“å‘½åã€‚ä¸ºç»“æ„ä½“å‘½åæ˜¯ä¸€ä¸ªå¥½ä¹ æƒ¯ï¼Œ
///       å› ä¸ºå®ƒå…è®¸æˆ‘ä»¬ç¨åé€šè¿‡ `ctx.getStructTypeByName("i32_f64")` æ¥å¼•ç”¨å®ƒï¼Œé¿å…é‡å¤å®šä¹‰ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼Œ`demo_i32_f64` å‡½æ•°å·²ç»ä¸ºä½ å±•ç¤ºäº†å¦‚ä½•åˆ›å»ºä¸€ä¸ªåŒ…å« `i32` å’Œ `f64` ä¸¤ä¸ªå­—æ®µçš„ç»“æ„ä½“ã€‚
///
/// ä½ çš„ä»»åŠ¡æ˜¯æ¨¡ä»¿å®ƒï¼Œå®Œæˆ `demo_i8_i16_i32_f32_f64` å‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªåŒ…å« `i8`, `i16`, `i32`, `f32`, `f64` äº”ç§ç±»å‹çš„ç»“æ„ä½“ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
/// ================================================================================

///|
///
/// demo_i32_f64åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«i32å’Œf64ä¸¤ä¸ªå­—æ®µçš„ç»“æ„ä½“ç±»å‹ã€‚
/// åœ¨Cè¯­è¨€é‡Œï¼Œè¿™ç›¸å½“äºå®šä¹‰äº†å¦‚ä¸‹ç»“æ„ä½“ï¼š
///
/// ```c
/// struct i32_f64 {
///   int32_t a;
///   double b;
/// };
/// ```
///
/// ä½ çš„ä»»åŠ¡æ˜¯å®ç°demo_i8_i16_i32_f32_f64å‡½æ•°ï¼Œ
/// åˆ›å»ºä¸€ä¸ªåŒ…å«i8ã€i16ã€i32ã€f32å’Œf64äº”ä¸ªå­—æ®µçš„ç»“æ„ä½“ç±»å‹ã€‚
///
/// åœ¨Cè¯­è¨€é‡Œï¼Œè¿™ç›¸å½“äºå®šä¹‰äº†å¦‚ä¸‹ç»“æ„ä½“ï¼š
///
/// ```c
/// struct i8_i16_i32_f32_f64 {
///   int8_t a;
///   int16_t b;
///   int32_t c;
///   float d;
///   double e;
/// };
/// ```
///
/// æç¤ºï¼š
///
/// - ä½¿ç”¨ `getInt8Ty` æ¥è·å– i8 ç±»å‹ã€‚
/// - ä½¿ç”¨ `getInt16Ty` æ¥è·å– i16 ç±»å‹ã€‚
/// - ä½¿ç”¨ `getInt32Ty` æ¥è·å– i32 ç±»å‹ã€‚
/// - ä½¿ç”¨ `getFloatTy` æ¥è·å– f32 ç±»å‹ã€‚
/// - ä½¿ç”¨ `getDoubleTy` æ¥è·å– f64 ç±»å‹ã€‚
///
/// æé†’ï¼š
///
/// 1. getStructTypeæœ‰ä¸€ä¸ªlabelå‚æ•°nameï¼Œå¯ä»¥ç”¨æ¥ç»™ç»“æ„ä½“å‘½åï¼Œ
/// llvmå…è®¸å®šä¹‰åŒ¿åç»“æ„ä½“ï¼Œå¦‚æœä¸ä¼ nameå‚æ•°ï¼Œåˆ™åˆ›å»ºçš„æ˜¯åŒ¿åç»“æ„ä½“ç±»å‹ã€‚
///
/// ä½†å»ºè®®åœ¨å®šä¹‰ç»“æ„ä½“ç±»å‹æ—¶ï¼Œæœ€å¥½ç»™ç»“æ„ä½“å‘½åã€‚
///
/// å…¶ä¸­çš„ä¸€ä¸ªé‡è¦åŸå› ï¼Œæ˜¯å‘½åçš„ç»“æ„ä½“å¯ä»¥ä½¿ç”¨contextçš„`getStructTypeByName`æ–¹æ³•æ¥è·å–ã€‚
/// ä»è€Œé¿å…é‡å¤å®šä¹‰ç›¸åŒåç§°çš„ç»“æ„ä½“ç±»å‹ã€‚
///
/// 2. åœ¨æ‰“å°ç»“æ„ä½“æ—¶ï¼Œå¦‚æœç›´æ¥ç”¨`println(struct_ty)`ï¼Œ
/// å¯¹äºéåŒ¿åçš„ç»“æ„ä½“ç±»å‹ï¼Œè¾“å‡ºå¯èƒ½åªæ˜¾ç¤ºç»“æ„ä½“çš„åç§°ã€‚
/// å¦‚æœéœ€è¦æŸ¥çœ‹ç»“æ„ä½“çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¯ä»¥ä½¿ç”¨`struct_ty.full_info()`æ–¹æ³•ã€‚
fn demo_i32_f64() -> @llvm.StructType raise {
  let ctx = @llvm.Context::new()
  let i32ty = ctx.getInt32Ty()
  let f64ty = ctx.getDoubleTy()
  let struct_ty = ctx.getStructType([i32ty, f64ty], name="i32_f64")
  struct_ty
}

///|
pub fn demo_i8_i16_i32_f32_f64() -> @llvm.StructType raise {
  let ctx = @llvm.Context::new()
  let i8ty = ctx.getInt8Ty()
  let i16ty = ctx.getInt16Ty()
  let i32ty = ctx.getInt32Ty()
  let f32ty = ctx.getFloatTy()
  let f64ty = ctx.getDoubleTy()
  let struct_ty = ctx.getStructType(
    [i8ty, i16ty, i32ty, f32ty, f64ty],
    name="i8_i16_i32_f32_f64",
  )
  struct_ty
}

///|
test "Codegen Demo Struct Test" {
  let s = demo_i32_f64()
  inspect(s.full_info(), content="%i32_f64 = type { i32, double }")

  //
  let s = demo_i8_i16_i32_f32_f64()
  inspect(
    s.full_info(),
    content="%i8_i16_i32_f32_f64 = type { i8, i16, i32, float, double }",
  )
}
/// ================================================================================
/// # LLVM Codegen: ç”Ÿæˆé¡¶å±‚å‡½æ•°
///
/// æ­å–œä½ ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº† KNF IR çš„å­¦ä¹ ï¼Œç°åœ¨æ­£å¼è¿›å…¥ä»£ç ç”Ÿæˆçš„æœ€åé˜¶æ®µï¼š**LLVM IR ç”Ÿæˆ**ã€‚
/// åœ¨è¿™ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬ä¼šå°† KNF å½¢å¼çš„ç¨‹åºé€ä¸€è½¬æ¢ä¸º LLVM IRã€‚
///
/// ## ğŸ’¡ ä¸¤é˜¶æ®µä»£ç ç”Ÿæˆï¼ˆTwo-Pass Codegenï¼‰
///
/// ä¸Knfç±»ä¼¼ï¼Œllvmä»£ç ç”Ÿæˆä¹Ÿé‡‡ç”¨â€œä¸¤é˜¶æ®µâ€ç­–ç•¥æ¥å¤„ç†å‡½æ•°é—´çš„ç›¸äº’è°ƒç”¨å’Œé€’å½’ã€‚
///
/// 1.  **ç¬¬ä¸€é˜¶æ®µï¼ˆæ”¶é›†ï¼‰**ï¼šéå†æ•´ä¸ª KNF ç¨‹åºï¼Œä½†ä¸ç”Ÿæˆä»»ä½•å‡½æ•°ä½“ã€‚æˆ‘ä»¬åªæ”¶é›†æ‰€æœ‰å‡½æ•°å’Œç»“æ„ä½“çš„â€œç­¾åâ€ä¿¡æ¯ï¼Œ
///     å¹¶åœ¨ LLVM ä¸­åˆ›å»ºå¯¹åº”çš„ã€ä½†å°šæ— å†…å®¹çš„å‡½æ•°ï¼ˆFunctionï¼‰å’Œç»“æ„ä½“ç±»å‹ï¼ˆStructTypeï¼‰ã€‚
///     è¿™æ ·ï¼ŒLLVM å°±çŸ¥é“äº†æ¯ä¸ªå‡½æ•°çš„åå­—ã€å‚æ•°å’Œè¿”å›ç±»å‹ã€‚
///
/// 2.  **ç¬¬äºŒé˜¶æ®µï¼ˆç”Ÿæˆï¼‰**ï¼šå†æ¬¡éå† KNF ç¨‹åºï¼Œè¿™æ¬¡æˆ‘ä»¬çœŸæ­£è¿›å…¥æ¯ä¸ªå‡½æ•°å†…éƒ¨ï¼Œç”Ÿæˆå…¶å‡½æ•°ä½“çš„ LLVM IR æŒ‡ä»¤ã€‚
///     ç”±äºç¬¬ä¸€é˜¶æ®µå·²ç»åˆ›å»ºäº†æ‰€æœ‰å‡½æ•°çš„å£°æ˜ï¼Œæ‰€ä»¥åœ¨ç”Ÿæˆå‡½æ•°ä½“æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªç”±åœ°è°ƒç”¨å…¶ä»–ä»»ä½•å‡½æ•°ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯å®Œæˆç¬¬ä¸€é˜¶æ®µçš„å¤§éƒ¨åˆ†å·¥ä½œï¼Œå¹¶ä¸ºç¬¬äºŒé˜¶æ®µç”Ÿæˆä¸€ä¸ªæœ€ç®€å•çš„å‡½æ•°ã€‚
///
/// ### 1. é˜…è¯»å¹¶å®ç° `context.mbt`
///
/// é¦–å…ˆï¼Œè¯·ä»”ç»†é˜…è¯» `codegen/context.mbt` æ–‡ä»¶ã€‚ä½ éœ€è¦å®ç°ä»¥ä¸‹ä¸¤ä¸ªæ ¸å¿ƒçš„â€œæ”¶é›†â€å‡½æ•°ï¼š
///
///   - `collect_struct_types(struct_defs)`: éå† KNF çš„ç»“æ„ä½“å®šä¹‰ï¼Œå¹¶åœ¨ LLVM ä¸­åˆ›å»ºå¯¹åº”çš„ `StructType`ã€‚
///   - `collect_func_values(functions)`: éå† KNF çš„å‡½æ•°å®šä¹‰ï¼Œå¹¶åœ¨ LLVM ä¸­åˆ›å»ºå¯¹åº”çš„ `Function` **å£°æ˜**ã€‚
///     **æ³¨æ„**ï¼šåœ¨è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬**æš‚æ—¶ä¸å¤„ç†å‡½æ•°ä½“**ï¼Œåªåˆ›å»ºå‡½æ•°çš„ç­¾åã€‚
///
/// ### 2. å®ç° `top_function_codegen`
///
/// æ¥ä¸‹æ¥ï¼Œåœ¨ `codegen/top_function.mbt` ä¸­ï¼Œä½ éœ€è¦å®ç° `top_function_codegen` å‡½æ•°ã€‚
/// è¿™ä¸ªå‡½æ•°è´Ÿè´£ä¸ºå•ä¸ª KNF å‡½æ•°ç”Ÿæˆå®Œæ•´çš„ LLVM IRï¼ŒåŒ…æ‹¬å‡½æ•°ä½“ã€‚
///
/// **LLVM API å…³é”®æç¤ºï¼š**
///
/// - **åˆ›å»ºåŸºæœ¬å—**ï¼šä¸€ä¸ªå‡½æ•°è‡³å°‘éœ€è¦ä¸€ä¸ªå…¥å£åŸºæœ¬å—ï¼ˆBasic Blockï¼‰ã€‚ä½¿ç”¨ `@llvm.Function::addBasicBlock` æ¥åˆ›å»ºå®ƒã€‚
///
/// - **è®¾ç½®æ’å…¥ç‚¹**ï¼šåœ¨ç”ŸæˆæŒ‡ä»¤ä¹‹å‰ï¼Œä½ å¿…é¡»å‘Šè¯‰ LLVM æŒ‡ä»¤åº”è¯¥è¢«æ’å…¥åˆ°å“ªé‡Œã€‚ä½¿ç”¨ `@llvm.IRBuilder::setInsertPoint` å°†æ’å…¥ç‚¹è®¾ç½®åˆ°ä½ åˆ›å»ºçš„åŸºæœ¬å—ä¸Šã€‚
///
/// - **åˆ›å»ºè¿”å›æŒ‡ä»¤**ï¼šä¸€ä¸ªåˆæ³•çš„ LLVM åŸºæœ¬å—å¿…é¡»ä»¥ä¸€ä¸ªâ€œç»ˆç»“æŒ‡ä»¤â€ï¼ˆTerminator Instructionï¼‰ç»“æŸï¼Œæœ€å¸¸è§çš„å°±æ˜¯è¿”å›æŒ‡ä»¤ã€‚
///   - å¦‚æœå‡½æ•°æœ‰è¿”å›å€¼ï¼Œä½¿ç”¨ `builder.createRet(...)`ã€‚
///   - å¦‚æœå‡½æ•°è¿”å› `Unit` (å³ C ä¸­çš„ `void`)ï¼Œä½¿ç”¨ `builder.createRetVoid()`ã€‚
///   - ä½ éœ€è¦åˆ¤æ–­å‡½æ•°çš„è¿”å›ç±»å‹ï¼Œä»¥å†³å®šæ˜¯å¦ä»¥åŠå¦‚ä½•æ·»åŠ  `ret` æŒ‡ä»¤ã€‚
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_empty_top_func_test.mbt` å°†ä¼šæ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºä¸€ä¸ªæ²¡æœ‰å‚æ•°å’Œå…·ä½“é€»è¾‘çš„ç©ºå‡½æ•°æ­£ç¡®ç”Ÿæˆ LLVM IRã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
/// ================================================================================

///|
///
/// åŠ¡å¿…æ³¨æ„ï¼Œä»»ä½•çš„å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°éƒ½æ˜¯éšå¼ä¼ å…¥çš„ç¯å¢ƒæŒ‡é’ˆã€‚
/// æ— è®ºå®ƒæ˜¯å¦æ˜¯Top Level Functionï¼Œä¹Ÿæ— è®ºå®ƒæ˜¯å¦ä»è¯æ³•ç¯å¢ƒä¸­æ•è·äº†å˜é‡ã€‚
///
/// è¿™æ ·æ‰èƒ½æ›´æ–¹ä¾¿åœ°æ”¯æŒé—­åŒ…çš„å®ç°ã€‚
test "Codegen for Empty Top Function Test" {
  let code =
    #|fn foo() -> Unit {}
    #|
    #|fn bar(x: Int, y: Double) -> Unit {}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // foo 
  let foo = knf_prog.functions.get("foo").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(foo)
  inspect(
    llvm_func,
    content=(
      #|define void @foo() {
      #|entry:
      #|  ret void
      #|}
      #|
    ),
  )

  // bar
  let bar = knf_prog.functions.get("bar").unwrap()
  let llvm_func2 = codegen_ctx.top_function_codegen(bar)
  inspect(
    llvm_func2,
    content=(
      #|define void @bar(i32 %0, double %1) {
      #|entry:
      #|  ret void
      #|}
      #|
    ),
  )
}
/// ================================================================================
/// # LLVM Codegen: if-else ä¸ PHI èŠ‚ç‚¹
/// ================================================================================
///
/// æˆ‘ä»¬å³å°†å¤„ç†ç¬¬ä¸€ä¸ªçœŸæ­£çš„æ§åˆ¶æµç»“æ„ï¼š`if-else` è¡¨è¾¾å¼ã€‚
/// è¿™åœ¨ä»£ç ç”Ÿæˆä¸­æ˜¯ä¸€ä¸ªé£è·ƒï¼Œå› ä¸ºå®ƒæ‰“ç ´äº†æŒ‡ä»¤çš„çº¿æ€§æ‰§è¡Œæµç¨‹ï¼Œå¹¶å¼•å…¥äº†ä¸€ä¸ªå¼ºå¤§çš„æ–°æ¦‚å¿µï¼š**PHI èŠ‚ç‚¹**ã€‚
///
/// ## `if-else` çš„æ§åˆ¶æµ
///
/// `if-else` è¯­å¥åœ¨ LLVM IR ä¸­é€šè¿‡ä¸€ç³»åˆ—åŸºæœ¬å—å’Œåˆ†æ”¯æŒ‡ä»¤æ¥è¡¨ç¤ºï¼š
///
/// 1.  **å…¥å£å— (`entry_bb`)**: è®¡ç®— `if` çš„æ¡ä»¶ï¼Œç„¶åæ ¹æ®ç»“æœä½¿ç”¨ `createCondBr` æŒ‡ä»¤è·³è½¬åˆ° `then_bb` æˆ– `else_bb`ã€‚
/// 2.  **Then å— (`then_bb`)**: åŒ…å« `if` ä¸ºçœŸæ—¶æ‰§è¡Œçš„ä»£ç ã€‚
/// 3.  **Else å— (`else_bb`)**: åŒ…å« `if` ä¸ºå‡æ—¶æ‰§è¡Œçš„ä»£ç ã€‚
/// 4.  **åˆå¹¶å— (`merge_bb`)**: `then` å’Œ `else` åˆ†æ”¯æ‰§è¡Œå®Œæ¯•åï¼Œæ§åˆ¶æµä¼šé‡æ–°æ±‡åˆåˆ°è¿™ä¸ªå—ï¼Œç»§ç»­æ‰§è¡Œåç»­ä»£ç ã€‚
///
/// ## ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µï¼šPHI èŠ‚ç‚¹
///
/// è€ƒè™‘è¡¨è¾¾å¼ `let z = if cond { x } else { y }`ã€‚å½“æ§åˆ¶æµåˆ°è¾¾ `merge_bb` æ—¶ï¼Œ`z` çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿ
/// å®ƒå¯èƒ½æ˜¯ `x`ï¼ˆå¦‚æœèµ°äº† `then` åˆ†æ”¯ï¼‰ï¼Œä¹Ÿå¯èƒ½æ˜¯ `y`ï¼ˆå¦‚æœèµ°äº† `else` åˆ†æ”¯ï¼‰ã€‚
///
/// ä¸ºäº†åœ¨ SSA å½¢å¼ä¸‹è§£å†³è¿™ä¸ªé—®é¢˜ï¼ˆä¸€ä¸ªå˜é‡åªèƒ½è¢«èµ‹å€¼ä¸€æ¬¡ï¼‰ï¼ŒLLVM å¼•å…¥äº† `phi` æŒ‡ä»¤ã€‚
///
/// **PHI èŠ‚ç‚¹å°±åƒä¸€ä¸ªæ ¹æ®æ¥æºè·¯å¾„é€‰æ‹©å€¼çš„å¼€å…³**ã€‚
///
/// `z = phi i32 [ %x, %then_bb ], [ %y, %else_bb ]`
///
/// è¿™è¡Œä»£ç çš„æ„æ€æ˜¯ï¼š
/// - `z` çš„å€¼æ˜¯ä¸€ä¸ª `i32`ã€‚
/// - å¦‚æœæ§åˆ¶æµæ˜¯ä» `%then_bb` è¿‡æ¥çš„ï¼Œ`z` çš„å€¼å°±ç­‰äº `%x`ã€‚
/// - å¦‚æœæ§åˆ¶æµæ˜¯ä» `%else_bb` è¿‡æ¥çš„ï¼Œ`z` çš„å€¼å°±ç­‰äº `%y`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯å®ç° `if_codegen` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿæ­£ç¡®å¤„ç† `if-else` è¡¨è¾¾å¼ã€‚
///
/// ### 1. åˆ›å»ºåŸºæœ¬å—å’Œåˆ†æ”¯
///
/// - å¦‚ä¸Šæ‰€è¿°ï¼Œä¸º `then`ã€`else` å’Œ `merge` åˆ›å»ºä¸‰ä¸ªæ–°çš„åŸºæœ¬å—ã€‚
/// - ç”Ÿæˆ `createCondBr` æŒ‡ä»¤è¿›è¡Œæ¡ä»¶è·³è½¬ã€‚
///
/// ### 2. å®ç° PHI èŠ‚ç‚¹é€»è¾‘
///
/// - å¦‚æœ `if` è¡¨è¾¾å¼æœ‰è¿”å›å€¼ï¼ˆå³å®ƒçš„ç±»å‹ä¸æ˜¯ `Unit`ï¼‰ï¼Œä½ éœ€è¦åœ¨ `merge_bb` çš„**æœ€å¼€å§‹**åˆ›å»ºä¸€ä¸ª PHI èŠ‚ç‚¹ã€‚
///   - **æ¥å£**: `builder.createPHI(type)`
/// - åœ¨åˆ†åˆ«ç”Ÿæˆå®Œ `then` å—å’Œ `else` å—çš„ä»£ç åï¼Œä½ éœ€è¦å‘Šè¯‰ PHI èŠ‚ç‚¹è¿™ä¸¤ä¸ªåˆ†æ”¯åˆ†åˆ«ä¼šäº§ç”Ÿä»€ä¹ˆå€¼ã€‚
///   - **æ¥å£**: `phi_node.addIncoming(value, block)`
///
/// ### 3. âš ï¸ æ³¨æ„ï¼šå¤„ç†å·²ç»ˆç»“çš„å—
///
/// åœ¨ `then` å—æˆ– `else` å—çš„æœ«å°¾ï¼Œæˆ‘ä»¬é€šå¸¸éœ€è¦ä¸€ä¸ª `createBr` æŒ‡ä»¤è·³è½¬åˆ° `merge_bb`ã€‚
/// ä½†æ˜¯ï¼Œå¦‚æœè¿™ä¸ªå—å·²ç»å› ä¸ºä¸€ä¸ª `return` æŒ‡ä»¤è€Œâ€œç»ˆç»“â€äº†å‘¢ï¼Ÿåœ¨ä¸€ä¸ªåŸºæœ¬å—ä¸­æ·»åŠ ä¸¤ä¸ªç»ˆç»“æŒ‡ä»¤æ˜¯é”™è¯¯çš„ã€‚
///
/// - åœ¨æ·»åŠ  `br` æŒ‡ä»¤å‰ï¼Œä½ å¿…é¡»æ£€æŸ¥å½“å‰å—æ˜¯å¦å·²ç»æœ‰äº†ç»ˆç»“æŒ‡ä»¤ã€‚
///   - **æ¥å£**: `builder.getInsertBlock().getTerminator()`ã€‚å¦‚æœè¿”å›å€¼æ˜¯ `Some(...)`ï¼Œåˆ™è¯´æ˜å·²æœ‰ç»ˆç»“æŒ‡ä»¤ï¼Œä¸åº”å†æ·»åŠ  `br`ã€‚
///
/// ### 4. âš ï¸ ç‰¹åˆ«å½“å¿ƒï¼šæ— ç”¨çš„ `merge` å—
///
/// è€ƒè™‘è¿™ç§æƒ…å†µï¼š`fn max(a, b) { if a > b { return a; } else { return b; } }`
///
/// åœ¨è¿™é‡Œï¼Œ`then` å—å’Œ `else` å—éƒ½ä»¥ `return` ç»“æŸã€‚æ§åˆ¶æµ**æ°¸è¿œä¸ä¼š**åˆ°è¾¾ `merge_bb`ã€‚
/// è¿™ç§æƒ…å†µä¸‹ï¼Œ`merge_bb` æˆäº†ä¸€ä¸ªæ²¡æœ‰å‰é©±ï¼ˆpredecessorï¼‰çš„â€œæ­»å—â€ã€‚ä¸€ä¸ªæ²¡æœ‰å‰é©±çš„åŸºæœ¬å—æ˜¯éæ³•çš„ï¼ˆå…¥å£å—é™¤å¤–ï¼‰ã€‚
///
/// - ä½ éœ€è¦æ£€æµ‹è¿™ç§æƒ…å†µï¼ˆå³ `then` å’Œ `else` å—éƒ½å·²è¢«ç»ˆç»“ï¼‰ã€‚
/// - å¦‚æœå‘ç”Ÿï¼Œä½ åº”è¯¥å°† `merge_bb` ä»å‡½æ•°ä¸­ç§»é™¤ï¼Œä»¥ä¿æŒ IR çš„åˆæ³•æ€§ã€‚
///   - **æ¥å£**: `merge_bb.removeFromParent()`
///
/// ---
///
/// è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„æŒ‘æˆ˜ï¼Œä½†å®ƒæ¶µç›–äº†ä»£ç ç”Ÿæˆä¸­å…³äºæ§åˆ¶æµçš„è®¸å¤šæ ¸å¿ƒæ€æƒ³ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

///|
///
test "Codegen for If Test" {
  let code =
    #|fn max(x: Int, y: Int) -> Int {
    #|  let z = if x > y { x } else { y };
    #|  z
    #|}
    #|
    #|fn min(x: Int, y: Int) -> Int {
    #|  if x < y {
    #|    return x;
    #|  } else {
    #|    return y;
    #|  }
    #|}
    #|
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // max
  let max = knf_prog.functions.get("max").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(max)
  inspect(
    llvm_func,
    content=(
      #|define i32 @max(i32 %0, i32 %1) {
      #|entry:
      #|  %2 = icmp sgt i32 %0, %1
      #|  br i1 %2, label %4, label %6
      #|
      #|4:                                     ; preds = %entry
      #|  br label %8
      #|
      #|6:                                     ; preds = %entry
      #|  br label %8
      #|
      #|8:                                     ; preds = %4, %6
      #|  %9 = phi i32 [ %0, %4 ], [ %1, %6 ]
      #|  ret i32 %9
      #|}
      #|
    ),
  )

  // min
  let min = knf_prog.functions.get("min").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(min)
  inspect(
    llvm_func,
    content=(
      #|define i32 @min(i32 %0, i32 %1) {
      #|entry:
      #|  %2 = icmp slt i32 %0, %1
      #|  br i1 %2, label %4, label %6
      #|
      #|4:                                     ; preds = %entry
      #|  ret i32 %0
      #|
      #|6:                                     ; preds = %entry
      #|  ret i32 %1
      #|}
      #|
    ),
  )
}

///|
test "Codegen for Simple Let and LetMut Test - 3" {
  let code =
    #|fn foo(x: Int) -> Int {
    #|  let z = x;
    #|  z
    #|}
    #|
    #|fn bar(x: Int) -> Int {
    #|  let mut z = x;
    #|  z
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // foo
  let add = knf_prog.functions.get("foo").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(add)
  inspect(
    llvm_func,
    content=(
      #|define i32 @foo(i32 %0) {
      #|entry:
      #|  ret i32 %0
      #|}
      #|
    ),
  )

  // bar
  let bar = knf_prog.functions.get("bar").unwrap()
  let llvm_func2 = codegen_ctx.top_function_codegen(bar)
  inspect(
    llvm_func2,
    content=(
      #|define i32 @bar(i32 %0) {
      #|entry:
      #|  %1 = alloca i32, align 4
      #|  store i32 %0, ptr %1, align 4
      #|  %3 = load i32, ptr %1, align 4
      #|  ret i32 %3
      #|}
      #|
    ),
  )
}

///|
/// ================================================================================
/// # LLVM Codegen: ç”Ÿæˆå¸¦è¿”å›å€¼çš„å‡½æ•°
/// ================================================================================
///
/// åœ¨ä¸Šä¸€ä¸ªæŒ‘æˆ˜ä¸­ï¼Œæˆ‘ä»¬æˆåŠŸç”Ÿæˆäº†ç©ºå‡½æ•°ä½“çš„ LLVM IRã€‚ç°åœ¨ï¼Œæ˜¯æ—¶å€™è®©æˆ‘ä»¬çš„å‡½æ•°åšä¸€äº›å®é™…çš„äº‹æƒ…äº†â€”â€”è¿”å›ä¸€ä¸ªå€¼ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯è®© `top_function_codegen` èƒ½å¤Ÿå¤„ç†è¿”å›ç®€å•å¸¸é‡ï¼ˆå¦‚æ•´æ•°ã€æµ®ç‚¹æ•°ã€å­—ç¬¦ä¸²ï¼‰çš„å‡½æ•°ã€‚
/// ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œä½ éœ€è¦å¼€å§‹å¡«å……å¦å¤–ä¸¤ä¸ªå…³é”®çš„è¾…åŠ©å‡½æ•°ï¼š
///
/// ### 1. å®ç° `expr_codegen` (åœ¨ `codegen/top_function.mbt` ä¸­)
///
/// `expr_codegen` å‡½æ•°è´Ÿè´£å°†ä¸€ä¸ª KNF è¡¨è¾¾å¼ï¼ˆ`KnfExpr`ï¼‰è½¬æ¢ä¸ºå¯¹åº”çš„ LLVM å€¼ï¼ˆ`@llvm.Value`ï¼‰ã€‚
///
/// ä½ éœ€è¦å¼€å§‹å¤„ç† `KnfExpr` çš„å‡ ä¸ªåŸºæœ¬æƒ…å†µï¼š
///   - `Int(i)`: ä½¿ç”¨ `llvm_ctx.getConstInt32(i)` åˆ›å»ºä¸€ä¸ª LLVM æ•´æ•°å¸¸é‡ã€‚
///   - `Double(d)`: ä½¿ç”¨ `llvm_ctx.getConstDouble(d)` åˆ›å»ºä¸€ä¸ª LLVM æµ®ç‚¹æ•°å¸¸é‡ã€‚
///   - `Bool(b)`: ä½¿ç”¨ `llvm_ctx.getConstTrue()` æˆ– `llvm_ctx.getConstFalse()`ã€‚
///   - `String(s)`: ä½¿ç”¨ `builder.createGlobalString(s, name=...)` åˆ›å»ºä¸€ä¸ªå…¨å±€å­—ç¬¦ä¸²å¸¸é‡ã€‚
///     - **æç¤º**ï¼šä¸ºå…¨å±€å­—ç¬¦ä¸²å‘½åæ˜¯ä¸ªå¥½ä¹ æƒ¯ï¼Œå¯ä»¥é¿å…å†²çªã€‚ä½ å¯ä»¥ä½¿ç”¨ä¸€ä¸ªè®¡æ•°å™¨ï¼ˆä¾‹å¦‚ `str_cnt`ï¼‰æ¥ç”Ÿæˆå”¯ä¸€çš„åå­—ï¼Œå¦‚ `"str_lit_1"`, `"str_lit_2"` ç­‰ã€‚
///
/// ### 2. å®ç° `stmt_codegen` (åœ¨ `codegen/top_function.mbt` ä¸­)
///
/// `stmt_codegen` è´Ÿè´£å°† KNF è¯­å¥ï¼ˆ`KnfStmt`ï¼‰è½¬æ¢ä¸º LLVM æŒ‡ä»¤ã€‚è™½ç„¶æœ¬æ¬¡æŒ‘æˆ˜çš„æ ¸å¿ƒåœ¨ `expr_codegen`ï¼Œä½† `top_function_codegen` çš„é€»è¾‘ä¼šé€šè¿‡ `stmt_codegen` æ¥å¤„ç†å‡½æ•°ä½“çš„æœ€åä¸€æ¡è¯­å¥ã€‚
///
/// ä½ éœ€è¦ç¡®ä¿ `stmt_codegen` èƒ½å¤Ÿå¤„ç† `Return(expr)` å’Œ `ExprStmt(expr)` è¿™ä¸¤ç§æƒ…å†µï¼Œå¹¶æœ€ç»ˆè°ƒç”¨ `expr_codegen` æ¥è·å–è¿”å›å€¼ã€‚
///
/// ## ğŸ’¡ å…³é”®é€»è¾‘
///
/// åœ¨ `top_function_codegen` ä¸­ï¼Œå½“å¤„ç†å®Œå‡½æ•°ä½“ï¼ˆ`func.body`ï¼‰åï¼Œä½ éœ€è¦æ£€æŸ¥å‡½æ•°ä½“çš„æœ€åä¸€æ¡è¯­å¥ï¼Œä»¥ç¡®å®šå¦‚ä½•ç”Ÿæˆ `ret` æŒ‡ä»¤ï¼š
///
/// - **å¦‚æœæœ€åæ˜¯ `Return(expr)` æˆ– `ExprStmt(expr)`**ï¼š
///   1. è°ƒç”¨ `expr_codegen(expr)` è·å¾— LLVM å€¼ã€‚
///   2. ä½¿ç”¨ `builder.createRet(value)` ç”Ÿæˆè¿”å›è¯¥å€¼çš„æŒ‡ä»¤ã€‚
///
/// - **å¦‚æœå‡½æ•°ä½“ä¸ºç©ºæˆ–æœ€åä¸€æ¡è¯­å¥ä¸æ˜¯è¿”å›è¡¨è¾¾å¼**ï¼š
///   1. æ£€æŸ¥å‡½æ•°çš„è¿”å›ç±»å‹ã€‚
///   2. å¦‚æœè¿”å›ç±»å‹æ˜¯ `void` (å¯¹åº”æˆ‘ä»¬çš„ `Unit`)ï¼Œåˆ™ä½¿ç”¨ `builder.createRetVoid()`ã€‚
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_simple_top_func_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºè¿”å›ä¸åŒç±»å‹å¸¸é‡çš„å‡½æ•°æ­£ç¡®ç”Ÿæˆ LLVM IRã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
test "Codegen for Simple Top Function Test" {
  let code =
    #|fn ret42() -> Int { 42 }
    #|
    #|fn ret_double_63() -> Double { 63.0 }
    #|
    #|fn hello() -> String {
    #|  "Hello, World!"
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)
  let foo = knf_prog.functions.get("ret42").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(foo)
  inspect(
    llvm_func,
    content=(
      #|define i32 @ret42() {
      #|entry:
      #|  ret i32 42
      #|}
      #|
    ),
  )

  // ret_double_63
  let bar = knf_prog.functions.get("ret_double_63").unwrap()
  let llvm_func2 = codegen_ctx.top_function_codegen(bar)
  inspect(
    llvm_func2,
    content=(
      #|define double @ret_double_63() {
      #|entry:
      #|  ret double 0x404F800000000000
      #|}
      #|
    ),
  )

  // hello
  let baz = knf_prog.functions.get("hello").unwrap()
  let llvm_func3 = codegen_ctx.top_function_codegen(baz)
  inspect(
    llvm_func3,
    content=(
      #|define ptr @hello() {
      #|entry:
      #|  %0 = call ptr @__builtin_create_string(ptr @str_lit_1)
      #|  ret ptr %0
      #|}
      #|
    ),
  )
}
/// ================================================================================
/// # LLVM Codegen: ç»“æ„ä½“æ“ä½œ
/// ================================================================================
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥å¤„ç†æ•°ç»„äº†ï¼Œç°åœ¨æˆ‘ä»¬æ¥å¤„ç†å¦ä¸€ç§é‡è¦çš„å¤åˆç±»å‹ï¼š**ç»“æ„ä½“ï¼ˆStructsï¼‰**ã€‚
/// è¿™åŒ…æ‹¬ç»“æ„ä½“çš„åˆ›å»ºã€å­—æ®µçš„è¯»å–å’Œå­—æ®µçš„æ›´æ–°ã€‚è¿™äº›æ“ä½œçš„æ ¸å¿ƒéƒ½ç¦»ä¸å¼€ä¸€æ¡å…³é”®æŒ‡ä»¤ï¼š`getelementptr`ã€‚
///
/// ## ğŸ’¡ æ ¸å¿ƒæŒ‡ä»¤ï¼š`getelementptr` (GEP)
///
/// `getelementptr`ï¼ˆè·å–å…ƒç´ æŒ‡é’ˆï¼‰æ˜¯ LLVM ä¸­ç”¨äºåœ°å€è®¡ç®—çš„æŒ‡ä»¤ã€‚å®ƒ**ä¸è®¿é—®å†…å­˜**ï¼Œ
/// è€Œæ˜¯æ ¹æ®åŸºåœ°å€å’Œç´¢å¼•ï¼Œè®¡ç®—å‡ºç»“æ„ä½“æˆ–æ•°ç»„ä¸­æŸä¸ªå…ƒç´ çš„å†…å­˜åœ°å€ã€‚
///
/// ### GEP æŒ‡ä»¤æ ¼å¼
///
/// å½“æˆ‘ä»¬æƒ³è·å–ä¸€ä¸ªç»“æ„ä½“å®ä¾‹ä¸­æŸä¸ªå­—æ®µçš„æŒ‡é’ˆæ—¶ï¼ŒGEP æŒ‡ä»¤çš„æ ¼å¼å¦‚ä¸‹ï¼š
///
/// `%field_ptr = getelementptr %MyStruct, ptr %struct_ptr, i32 0, i32 <field_index>`
///
/// - `%MyStruct`: è¿™æ˜¯ç»“æ„ä½“çš„ç±»å‹ã€‚
/// - `ptr %struct_ptr`: è¿™æ˜¯æŒ‡å‘ç»“æ„ä½“å®ä¾‹çš„åŸºåœ°å€æŒ‡é’ˆã€‚
/// - `i32 0`: ç¬¬ä¸€ä¸ªç´¢å¼•ã€‚å®ƒç”¨äºâ€œç©¿è¿‡â€`%struct_ptr` æŒ‡é’ˆã€‚åœ¨è®¿é—®ç»“æ„ä½“å­—æ®µæ—¶ï¼Œè¿™ä¸ªç´¢å¼•**æ€»æ˜¯ 0**ã€‚
/// - `i32 <field_index>`: ç¬¬äºŒä¸ªç´¢å¼•ï¼Œä»£è¡¨ä½ æƒ³è¦è®¿é—®çš„å­—æ®µåœ¨ç»“æ„ä½“å®šä¹‰ä¸­çš„**åºå·**ï¼ˆä» 0 å¼€å§‹ï¼‰ã€‚
///
/// ä¾‹å¦‚ï¼Œå¯¹äº `struct Point { x: Int; y: Int; }`ï¼Œå­—æ®µ `y` çš„ç´¢å¼•å°±æ˜¯ `1`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯å®ç°ç»“æ„ä½“çš„åˆ›å»ºã€è®¿é—®å’Œæ›´æ–°ã€‚
///
/// ### 1. ç»“æ„ä½“åˆ›å»º (`CreateStruct`)
///
/// åœ¨ `expr_codegen` ä¸­å¤„ç† `CreateStruct` æ—¶ï¼š
/// a. **åˆ†é…å†…å­˜**: ä¸æ•°ç»„ç±»ä¼¼ï¼Œç»“æ„ä½“å®ä¾‹ä¹Ÿå­˜æ”¾åœ¨å †ä¸Šã€‚ä½ éœ€è¦è°ƒç”¨ `moonbit_malloc` å†…å»ºå‡½æ•°æ¥ä¸ºå…¶åˆ†é…å†…å­˜ã€‚åˆ†é…çš„å¤§å°å¯ä»¥é€šè¿‡ `module.getDataLayout().getTypeAllocSize(struct_ty)` æ¥è·å–ã€‚
/// b. **å¡«å……å­—æ®µ**: éå†æ‰€æœ‰éœ€è¦åˆå§‹åŒ–çš„å­—æ®µã€‚å¯¹äºæ¯ä¸ªå­—æ®µï¼š
///    i.  ä½¿ç”¨ `getelementptr` è®¡ç®—å‡ºè¯¥å­—æ®µçš„åœ°å€ã€‚
///    ii. ä½¿ç”¨ `builder.createStore` å°†åˆå§‹å€¼å­˜å…¥è¯¥åœ°å€ã€‚
///
/// ### 2. å­—æ®µè®¿é—® (`FieldAccess`)
///
/// åœ¨ `expr_codegen` ä¸­å¤„ç† `FieldAccess` æ—¶ï¼š
/// a. **è·å–å­—æ®µæŒ‡é’ˆ**: ä½¿ç”¨ `getelementptr` è®¡ç®—å‡ºå­—æ®µçš„åœ°å€ã€‚
/// b. **åŠ è½½å€¼**: ä½¿ç”¨ `builder.createLoad` ä»è¯¥åœ°å€åŠ è½½å­—æ®µçš„å€¼ã€‚
///
/// ### 3. å­—æ®µæ›´æ–° (`StructFieldSet`)
///
/// åœ¨ `stmt_codegen` ä¸­æ·»åŠ å¯¹ `StructFieldSet` çš„å¤„ç†ï¼š
/// a. **è·å–å­—æ®µæŒ‡é’ˆ**: åŒæ ·ï¼Œä½¿ç”¨ `getelementptr` è®¡ç®—å‡ºå­—æ®µçš„åœ°å€ã€‚
/// b. **å­˜å‚¨æ–°å€¼**: ä½¿ç”¨ `builder.createStore` å°†æ–°å€¼å­˜å…¥è¯¥åœ°å€ã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_struct_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½æ­£ç¡®åœ°ä¸ºç»“æ„ä½“çš„åˆ›å»ºã€è®¿é—®å’Œæ›´æ–°ç”Ÿæˆä»£ç ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚

///|
///
test "Codegen for Struct Create, Access and Set Test" {
  let code =
    #|struct Point {
    #|  mut x: Int;
    #|  mut y: Int;
    #|}
    #|
    #|fn create_point() -> Point {
    #|  let p = Point::{ x: 10, y: 20 };
    #|  p;
    #|}
    #|
    #|fn swap_x_y(p: Point) -> Unit {
    #|  let t = p.x;
    #|  p.x = p.y;
    #|  p.y = t;
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)
  codegen_ctx.collect_struct_types(knf_prog.struct_defs)

  // codegen for create_point
  let create_point = knf_prog.functions.get("create_point").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(create_point)
  inspect(
    llvm_func,
    content=(
      #|define ptr @create_point() {
      #|entry:
      #|  %0 = call ptr @moonbit_malloc(i32 8)
      #|  %1 = getelementptr %Point, ptr %0, i32 0, i32 0
      #|  store i32 10, ptr %1, align 4
      #|  %3 = getelementptr %Point, ptr %0, i32 0, i32 1
      #|  store i32 20, ptr %3, align 4
      #|  ret ptr %0
      #|}
      #|
    ),
  )

  // codegen for swap_x_y
  let swap_x_y = knf_prog.functions.get("swap_x_y").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(swap_x_y)
  inspect(
    llvm_func,
    content=(
      #|define void @swap_x_y(ptr %0) {
      #|entry:
      #|  %1 = getelementptr %Point, ptr %0, i32 0, i32 0
      #|  %2 = load i32, ptr %1, align 4
      #|  %3 = getelementptr %Point, ptr %0, i32 0, i32 1
      #|  %4 = load i32, ptr %3, align 4
      #|  %5 = getelementptr %Point, ptr %0, i32 0, i32 0
      #|  store i32 %4, ptr %5, align 4
      #|  %7 = getelementptr %Point, ptr %0, i32 0, i32 1
      #|  store i32 %2, ptr %7, align 4
      #|  ret void
      #|}
      #|
    ),
  )
}

///|
/// ================================================================================
/// # LLVM Codegen: å…ƒç»„ (Tuples)
/// ================================================================================
///
/// åœ¨å¤„ç†å®Œç»“æ„ä½“ä¹‹åï¼Œæˆ‘ä»¬æ¥å¤„ç†ä¸€ä¸ªä¸å®ƒéå¸¸ç›¸ä¼¼çš„å…„å¼Ÿï¼š**å…ƒç»„ï¼ˆTuplesï¼‰**ã€‚
///
/// ## ğŸ’¡ æ ¸å¿ƒæ€æƒ³ï¼šå…ƒç»„å°±æ˜¯åŒ¿åçš„ç»“æ„ä½“
///
/// ä»ä»£ç ç”Ÿæˆçš„è§’åº¦æ¥çœ‹ï¼Œå…ƒç»„å’Œç»“æ„ä½“åŸºæœ¬ä¸Šæ˜¯ä¸€ä¸ªé“ç†ã€‚ä½ å¯ä»¥å°†ä¸€ä¸ªå…ƒç»„ `(Int, Double)`
/// æƒ³è±¡æˆä¸€ä¸ªåŒ¿åçš„ã€åªæœ‰å­—æ®µåºå·æ²¡æœ‰å­—æ®µåçš„ç»“æ„ä½“ `struct { Int; Double; }`ã€‚
///
/// - **å†…å­˜å¸ƒå±€**: å’Œç»“æ„ä½“ä¸€æ ·ï¼Œå…ƒç»„ä¹Ÿä½œä¸ºä¸€å—è¿ç»­çš„å†…å­˜å­˜åœ¨ï¼Œæˆ‘ä»¬åŒæ ·åœ¨**å †**ä¸Šä¸ºå…¶åˆ†é…ç©ºé—´ã€‚
/// - **å…ƒç´ è®¿é—®**: è®¿é—®å…ƒç»„çš„ç¬¬ `n` ä¸ªå…ƒç´ ï¼Œå°±å’Œè®¿é—®ç»“æ„ä½“çš„ç¬¬ `n` ä¸ªå­—æ®µå®Œå…¨ä¸€æ ·ã€‚
///
/// å› æ­¤ï¼Œç”Ÿæˆå…ƒç»„ç›¸å…³ä»£ç çš„é€»è¾‘ä¸æˆ‘ä»¬ä¸Šä¸€å…³å®ç°çš„ç»“æ„ä½“é€»è¾‘é«˜åº¦é‡åˆã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯ä¸ºå…ƒç»„çš„åˆ›å»ºå’Œè®¿é—®ç”Ÿæˆä»£ç ã€‚
///
/// ### 1. å…ƒç»„åˆ›å»º (`TupleLiteral`)
///
/// åœ¨ `expr_codegen` ä¸­å¤„ç† `TupleLiteral` æ—¶ï¼š
/// a. **ç¡®å®šç±»å‹**: é¦–å…ˆï¼Œä½ éœ€è¦æ ¹æ®å…ƒç»„ä¸­æ‰€æœ‰å…ƒç´ çš„ LLVM ç±»å‹ï¼Œåœ¨ LLVM ä¸­åˆ›å»ºä¸€ä¸ªåŒ¿åçš„ç»“æ„ä½“ç±»å‹ï¼Œä¾‹å¦‚ `{ i32, double, i1 }`ã€‚
/// b. **åˆ†é…å†…å­˜**: è°ƒç”¨ `moonbit_malloc` ä¸ºè¿™ä¸ªåŒ¿åç»“æ„ä½“åˆ†é…å †å†…å­˜ã€‚
/// c. **å¡«å……å…ƒç´ **: éå†å…ƒç»„ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œå¯¹äºç¬¬ `i` ä¸ªå…ƒç´ ï¼š
///    i.  ä½¿ç”¨ `getelementptr` è®¡ç®—å‡ºç¬¬ `i` ä¸ªå…ƒç´ çš„åœ°å€ã€‚æŒ‡ä»¤æ ¼å¼ä¸ºï¼š`getelementptr {..types..}, ptr %tuple_ptr, i32 0, i32 i`
///    ii. ä½¿ç”¨ `builder.createStore` å°†å…ƒç´ å€¼å­˜å…¥è¯¥åœ°å€ã€‚
///
/// ### 2. å…ƒç»„è®¿é—® (`TupleAccess` æˆ– `let` è§£æ„)
///
/// åœ¨ `expr_codegen` ä¸­å¤„ç†å…ƒç»„è®¿é—®æ—¶ï¼ˆKNF å¯èƒ½ä¼šå°† `let (x,...) = t` è½¬æ¢ä¸ºå¯¹ `t` çš„ `TupleAccess`ï¼‰ï¼š
/// a. **è·å–å…ƒç´ æŒ‡é’ˆ**: ä½¿ç”¨ `getelementptr` è®¡ç®—å‡ºè¦è®¿é—®çš„å…ƒç´ çš„åœ°å€ã€‚
/// b. **åŠ è½½å€¼**: ä½¿ç”¨ `builder.createLoad` ä»è¯¥åœ°å€åŠ è½½å…ƒç´ çš„å€¼ã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_tuple_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½æ­£ç¡®åœ°ä¸ºå…ƒç»„çš„åˆ›å»ºå’Œè®¿é—®ç”Ÿæˆä»£ç ã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
test "Codegen for Struct Create And Set Test" {
  let code =
    #|fn first(a: (Int, Double, Bool)) -> Int {
    #|  let (x, _, _) = a;
    #|  x;
    #|}
    #|
    #|fn combine(a: Int, b: Double, c: Bool) -> (Int, Double, Bool) {
    #|  let x = (a, b, c);
    #|  x;
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)
  codegen_ctx.collect_struct_types(knf_prog.struct_defs)

  // 
  let first = knf_prog.functions.get("first").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(first)
  inspect(
    llvm_func,
    content=(
      #|define i32 @first(ptr %0) {
      #|entry:
      #|  %1 = getelementptr { i32, double, i1 }, ptr %0, i32 0, i32 0
      #|  %2 = load i32, ptr %1, align 4
      #|  %3 = getelementptr { i32, double, i1 }, ptr %0, i32 0, i32 1
      #|  %4 = load double, ptr %3, align 8
      #|  %5 = getelementptr { i32, double, i1 }, ptr %0, i32 0, i32 2
      #|  %6 = load i1, ptr %5, align 1
      #|  ret i32 %2
      #|}
      #|
    ),
  )
  let combine = knf_prog.functions.get("combine").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(combine)
  inspect(
    llvm_func,
    content=(
      #|define ptr @combine(i32 %0, double %1, i1 %2) {
      #|entry:
      #|  %3 = call ptr @moonbit_malloc(i32 24)
      #|  %4 = getelementptr { i32, double, i1 }, ptr %3, i32 0, i32 0
      #|  store i32 %0, ptr %4, align 4
      #|  %6 = getelementptr { i32, double, i1 }, ptr %3, i32 0, i32 1
      #|  store double %1, ptr %6, align 8
      #|  %8 = getelementptr { i32, double, i1 }, ptr %3, i32 0, i32 2
      #|  store i1 %2, ptr %8, align 1
      #|  ret ptr %3
      #|}
      #|
    ),
  )
}

///|
/// ================================================================================
/// # LLVM Codegen: ä¸€å…ƒè¿ç®—
/// ================================================================================
///
/// åœ¨å¤„ç†å®ŒäºŒå…ƒè¿ç®—åï¼Œæˆ‘ä»¬æ¥å¤„ç†æ›´ç®€å•çš„ä¸€å…ƒè¿ç®—ï¼ˆUnary Operationsï¼‰ã€‚
/// åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦å…³å¿ƒä¸¤ç§ä¸€å…ƒè¿ç®—ï¼šå–è´Ÿ (`-`) å’Œé€»è¾‘é (`!`)ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„ç›®æ ‡æ˜¯ç»§ç»­æ‰©å±• `expr_codegen` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç† `KnfExpr::Neg` å’Œ `KnfExpr::Not` è¡¨è¾¾å¼ã€‚
///
/// ## ğŸ’¡ å®ç°æŒ‡å—
///
/// ### é€»è¾‘é `!`
///
/// å¯¹äºå¸ƒå°”ç±»å‹çš„ `!b` æ“ä½œï¼Œä¸€ä¸ªæ ‡å‡†ä¸”é«˜æ•ˆçš„å®ç°æ–¹å¼æ˜¯ä½¿ç”¨â€œå¼‚æˆ–â€ï¼ˆXORï¼‰è¿ç®—ï¼š
///
/// `!b` ç­‰ä»·äº `b XOR true`
///
/// - **LLVM Builder æ¥å£**: `builder.createXor(value, llvm_ctx.getConstTrue())`
///
/// ### å–è´Ÿ `-`
///
/// å–è´Ÿæ“ä½œæ ¹æ®æ“ä½œæ•°çš„ç±»å‹æœ‰ä¸åŒçš„å®ç°æ–¹å¼ï¼Œè¿™ä¸€ç‚¹éœ€è¦ç‰¹åˆ«æ³¨æ„ã€‚
///
/// #### æ•´æ•°å–è´Ÿ
///
/// å¯¹äºæ•´æ•° `-x`ï¼ŒLLVM æ²¡æœ‰æä¾›ä¸€ä¸ªä¸“é—¨çš„ `neg` æŒ‡ä»¤ã€‚æ ‡å‡†çš„å®ç°æ–¹å¼æ˜¯å°†å…¶è½¬æ¢ä¸ºå‡æ³•ï¼š
///
/// `-x` ç­‰ä»·äº `0 - x`
///
/// - **LLVM Builder æ¥å£**: `builder.createSub(zero, value)`
///
/// #### æµ®ç‚¹æ•°å–è´Ÿ
///
/// **âš ï¸ è¯·æ³¨æ„**: å¯¹äºæµ®ç‚¹æ•° `-x`ï¼Œä½ åº”è¯¥ä½¿ç”¨ä¸“é—¨çš„ `fneg` æŒ‡ä»¤ã€‚
///
/// - **LLVM Builder æ¥å£**: `builder.createFNeg(value)`
///
/// **ä¸ºä»€ä¹ˆä¸èƒ½ç”¨ `0.0 - x`ï¼Ÿ**
///
/// è¿™æ˜¯å› ä¸º IEEE 754 æµ®ç‚¹æ•°æ ‡å‡†ä¸­å­˜åœ¨ä¸¤ç§é›¶ï¼š`+0.0` å’Œ `-0.0`ã€‚
/// `fneg` æŒ‡ä»¤ä¿è¯äº†å®ƒä»…ä»…æ˜¯ç¿»è½¬æ“ä½œæ•°çš„ç¬¦å·ä½ï¼Œè¿™æ˜¯æœ€ç²¾ç¡®å’Œé«˜æ•ˆçš„æ–¹å¼ã€‚
/// è€Œ `0.0 - x` ä½œä¸ºä¸€ä¸ªå‡æ³•è¿ç®—ï¼Œåœ¨æŸäº›æ¶‰åŠ `NaN` æˆ–æ— ç©·å¤§çš„è¾¹ç•Œæƒ…å†µä¸‹ï¼Œå…¶è¡Œä¸ºå¯èƒ½ä¸ `fneg` ä¸åŒã€‚
///
/// ---
///
/// æœ¬æ¬¡æµ‹è¯• `codegen_unary_test.mbt` å°†æ£€æŸ¥ä½ æ˜¯å¦èƒ½ä¸ºè¿™å‡ ç§ä¸€å…ƒè¿ç®—æ­£ç¡®ç”Ÿæˆ LLVM IRã€‚
///
/// è·Ÿç€ä¸‹é¢çš„æŒ‡å¼•å®Œæˆä»»åŠ¡å§ã€‚
test "Codegen for Simple Unary Test" {
  let code =
    #|fn neg_int(x: Int) -> Int {
    #|  let z = -x;
    #|  z
    #|}
    #|
    #|fn neg_double(x: Double) -> Double {
    #|  let z = -x;
    #|  z
    #|}
    #|
    #|fn not_bool(b: Bool) -> Bool {
    #|  let z = !b;
    #|  z
    #|}
  let tokens = @lexer.tokenize(code)
  let ast = @parser.parse(tokens)
  let typed_ast = @typecheck.typecheck(ast)
  let knf_prog = @knf.knf_transform(typed_ast)
  let codegen_ctx = Context::new("demo")
  codegen_ctx.collect_func_values(knf_prog.functions)

  // neg_int
  let neg_int = knf_prog.functions.get("neg_int").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(neg_int)
  inspect(
    llvm_func,
    content=(
      #|define i32 @neg_int(i32 %0) {
      #|entry:
      #|  %1 = sub i32 0, %0
      #|  ret i32 %1
      #|}
      #|
    ),
  )

  // neg_double
  let neg_double = knf_prog.functions.get("neg_double").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(neg_double)
  inspect(
    llvm_func,
    content=(
      #|define double @neg_double(double %0) {
      #|entry:
      #|  %1 = fneg double %0
      #|  ret double %1
      #|}
      #|
    ),
  )

  // not_bool
  let not_bool = knf_prog.functions.get("not_bool").unwrap()
  let llvm_func = codegen_ctx.top_function_codegen(not_bool)
  inspect(
    llvm_func,
    content=(
      #|define i1 @not_bool(i1 %0) {
      #|entry:
      #|  %1 = xor i1 true, %0
      #|  ret i1 %1
      #|}
      #|
    ),
  )
}
