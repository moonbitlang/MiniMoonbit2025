///|
pub(all) struct Program {
  source_file : String
  top_lets : Map[String, TopLet]
  top_functions : Map[String, TopFunction]
  extern_funcions : Map[String, ExternFunction]
  struct_defs : Map[String, StructDef]
  enum_defs : Map[String, EnumDef]
}

pub fn Program::to_string(self: Self, color?: Bool = true) -> String {
  let sb = StringBuilder::new()
  for _, extern_fn in self.extern_funcions {
    sb.write_string(extern_fn.to_string(color~))
  }
  for _, struct_def in self.struct_defs {
    sb.write_string(struct_def.to_string(color~))
  }
  for _, enum_def in self.enum_defs {
    sb.write_string(enum_def.to_string(color~))
  }
  for _, top_let in self.top_lets {
    sb.write_string(top_let.to_string(color~))
  }
  for _, top_fn in self.top_functions {
    sb.write_string(top_fn.to_string(color~))
  }
  sb.to_string()
}

pub impl Show for Program with output(self, logger) {
  logger.write_string(self.to_string(color=true))
}

///|
pub fn parse(tokens : Array[Token]) -> Program raise ParseError {
  guard tokens is [tok, ..] else {
    raise ParseError("Empty token array passed to parser")
  }
  let source_file = tok.file
  let top_lets = Map::new()
  let top_functions = Map::new()
  let extern_funcions = Map::new()
  let struct_defs = Map::new()
  let enum_defs = Map::new()
  loop tokens[:] {
    [{ kind: Keyword(Extern), .. }, ..] as tokens => {
      let (extern_fn, rest) = parse_extern_function(tokens)
      extern_funcions.set(extern_fn.fname, extern_fn)
      continue rest
    }
    [{ kind: Keyword(Fn), .. }, ..] as tokens => {
      let (top_fn, rest) = parse_top_function(tokens)
      // Use whole_name() to avoid conflicts between methods with the same name
      // e.g., Point::new and Rect::new should be stored as different functions
      top_functions.set(top_fn.whole_name(), top_fn)
      continue rest
    }
    [{ kind: Keyword(Let), .. }, ..] as tokens => {
      let (top_let, rest) = parse_top_let(tokens)
      top_lets.set(top_let.name, top_let)
      continue rest
    }
    [{ kind: Keyword(Struct), .. }, ..] as tokens => {
      let (struct_def, rest) = parse_struct_def(tokens)
      struct_defs.set(struct_def.name, struct_def)
      continue rest
    }
    [{ kind: Keyword(Enum), .. }, ..] as tokens => {
      let (enum_def, rest) = parse_enum_def(tokens)
      enum_defs.set(enum_def.name, enum_def)
      continue rest
    }
    [{ kind: EOF, .. }, ..] => break
    [] => {
      println("Compiler ICE: Empty Token ArrayView")
      panic()
    }
    tokens => raise ParseError("Unexpected token in top level: \{tokens[0]}")
  }
  let prog = Program::{
    top_lets,
    top_functions,
    extern_funcions,
    struct_defs,
    enum_defs,
    source_file,
  }
  prog
}
