/// ================================================================================
/// # æ–¹æ‹¬å·çš„é›†ç»“ï¼šè§£ææ•°ç»„å­—é¢é‡
///
/// æˆ‘ä»¬å·²ç»æˆåŠŸå¤„ç†äº†åœ†æ‹¬å· `()` çš„å¤šç§æƒ…å†µã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥æŒ‘æˆ˜å¦ä¸€ç§å¸¸è§çš„æ‹¬å·ï¼š
/// æ–¹æ‹¬å· `[]`ï¼Œå®ƒåœ¨ MiniMoonBit ä¸­ç”¨äºå®šä¹‰**æ•°ç»„å­—é¢é‡ï¼ˆArray Literalsï¼‰**ã€‚
///
/// ## æ•°ç»„å­—é¢é‡
///
/// æ•°ç»„å­—é¢é‡å…è®¸æˆ‘ä»¬ç›´æ¥åœ¨ä»£ç ä¸­å®šä¹‰ä¸€ä¸ªåŒ…å«å¤šä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œä¾‹å¦‚ï¼š
/// `[1, 2, 3]` æˆ– `["hello", "world"]`ã€‚
///
/// å®ƒçš„ç»“æ„ä¸æˆ‘ä»¬ä¹‹å‰è§£æçš„å…ƒç»„ï¼ˆTupleï¼‰éå¸¸ç›¸ä¼¼ï¼šç”±ä¸€å¯¹æ‹¬å·åŒ…è£¹ï¼Œå†…éƒ¨æ˜¯é€—å·åˆ†éš”çš„è¡¨è¾¾å¼åˆ—è¡¨ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_atom_expr` ä¸­å¤„ç† `[]`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ `atom_expr.mbt` ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•° `parse_array_expr`
/// æ¥å®ç°å¯¹æ•°ç»„å­—é¢é‡çš„è§£æã€‚`parse_atom_expr` å°†åœ¨é‡åˆ° `[` æ—¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// å¥½æ¶ˆæ¯æ˜¯ï¼Œè¿™éƒ¨åˆ†é€»è¾‘ä¸æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `parse_paren_expr` é«˜åº¦ç›¸ä¼¼ï¼
///
/// 1.  **å…¥å£ï¼š** å½“ `parse_atom_expr` é‡åˆ° `[` æ—¶ï¼Œå®ƒåº”è¯¥å°†è§£æå·¥ä½œå§”æ‰˜ç»™ `parse_array_expr`ã€‚
///
/// 2.  **`parse_array_expr` çš„é€»è¾‘ï¼š**
///     *   é¦–å…ˆï¼Œè·³è¿‡å¼€å¤´çš„ `[`ã€‚
///     *   è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œç”¨ `parse_expr` è§£æç”±é€—å·åˆ†éš”çš„è¡¨è¾¾å¼åˆ—è¡¨ã€‚
///     *   å¾ªç¯ç›´åˆ°é‡åˆ°ç»“å°¾çš„ `]`ã€‚
///     *   å°†æ‰€æœ‰è§£æå‡ºçš„ `Expr` æ”¶é›†åˆ°ä¸€ä¸ª `Array` ä¸­ã€‚
///     *   ä½¿ç”¨è¿™ä¸ª `Array[Expr]` æ¥æ„é€ ä¸€ä¸ª `AtomExprKind::Array` èŠ‚ç‚¹ã€‚
///
/// ## ğŸ¤” æ·±å…¥æ€è€ƒï¼šé€—å·çš„è‰ºæœ¯
///
/// æ—¢ç„¶æ•°ç»„å’Œå…ƒç»„çš„è§£æå¦‚æ­¤ç›¸ä¼¼ï¼Œé‚£ä¹ˆå…³äºé€—å·çš„è¾¹ç•Œæƒ…å†µä¹Ÿå€¼å¾—æˆ‘ä»¬å†æ¬¡æ€è€ƒã€‚
/// å¯¹äºä¸€ä¸ªå¥å£®ä¸”ç”¨æˆ·å‹å¥½çš„è¯­è¨€æ¥è¯´ï¼Œä»¥ä¸‹æƒ…å†µæ˜¯å¦åº”è¯¥è¢«æ¥å—ï¼Ÿ
///
/// *   **å°¾éšé€—å·ï¼š** `[1, 2, 3,]`
/// *   **å¼€å¤´é€—å·ï¼š** `[, 1, 2, 3]`
/// *   **è¿ç»­é€—å·ï¼š** `[1, , 2, 3]`
/// *   **å¤šä¸ªå°¾éšé€—å·ï¼š** `[1, 2, 3, ,]`
///
/// ä½ çš„ `parse_paren_expr` çš„å®ç°å¯èƒ½å·²ç»å¤„ç†äº†å…¶ä¸­ä¸€éƒ¨åˆ†æƒ…å†µã€‚
/// åœ¨å®ç° `parse_array_expr` æ—¶ï¼Œä½ å¯ä»¥è€ƒè™‘æ˜¯å¦éœ€è¦ä¸€ä¸ªæ›´é€šç”¨çš„ã€å¯ä»¥è¢«ä¸¤è€…å¤ç”¨çš„åˆ—è¡¨è§£æå‡½æ•°ï¼Œ
/// ä»¥ç¡®ä¿è¯­è¨€åœ¨ä¸åŒè¯­æ³•ç»“æ„ä¸­è¡Œä¸ºçš„ä¸€è‡´æ€§ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_array_expr_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼é€šè¿‡ä»£ç å¤ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥è®©ç¼–è¯‘å™¨å˜å¾—æ›´åŠ ä¼˜é›…å’Œå¥å£®ã€‚**
/// ================================================================================

///|
test "Array Expr Parsing Test" {
  let code =
    #|[42, 3.14, true]
    #|[foo, bar, baz]
    #|[ 1 + 3]
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(
    a.kind is AtomExprKind::Array(exprs) &&
    exprs is [e1, e2, e3] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(42) &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Double(3.14) &&
    e3.kind is ApplyExpr(app3) &&
    app3.kind is AtomExpr(atom3) &&
    atom3.kind is Bool(true),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is AtomExprKind::Array(exprs) &&
    exprs is [e1, e2, e3] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Ident("foo") &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Ident("bar") &&
    e3.kind is ApplyExpr(app3) &&
    app3.kind is AtomExpr(atom3) &&
    atom3.kind is Ident("baz"),
  )
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is AtomExprKind::Array(exprs) &&
    exprs is [e1] &&
    e1.kind is BinaryExpr(Add, left, right) &&
    left.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    right.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(3),
  )
}
/// ================================================================================
/// # ç¼–è¯‘å™¨â€œå¼€æ´â€ï¼šè§£æç‰¹æ®Šçš„ `Array::make` è¯­æ³•
///
/// åœ¨è®¾è®¡ä¸€é—¨è¯­è¨€æ—¶ï¼Œæœ‰æ—¶æˆ‘ä»¬ä¼šé‡åˆ°ä¸€äº›æ— æ³•é€šè¿‡é€šç”¨è¯­æ³•è§„åˆ™ä¼˜é›…è¡¨è¾¾çš„ç»“æ„ã€‚
/// è¿™æ—¶ï¼Œç¼–è¯‘å™¨å¼€å‘è€…ä¼šé€‰æ‹©â€œå¼€ä¸€ä¸ªæ´â€ï¼Œä¸ºè¿™ç§ç‰¹æ®Šæƒ…å†µç¼–å†™ä¸“é—¨çš„è§£æé€»è¾‘ã€‚
///
/// `Array::make(size, init)` å°±æ˜¯ MiniMoonBit ä¸­çš„ä¸€ä¸ªå…¸å‹ä¾‹å­ã€‚
/// å®ƒçœ‹èµ·æ¥åƒä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œä½†å®é™…ä¸Šæ˜¯ä¸€ç§ç‰¹æ®Šçš„ã€å†…ç½®äºè¯­è¨€æ ¸å¿ƒçš„æ•°ç»„åˆ›å»ºè¯­æ³•ã€‚
/// ä½ å¯ä»¥æŠŠå®ƒç±»æ¯”äº C è¯­è¨€ä¸­çš„ `int arr[n];`ï¼Œè¿™åŒæ ·ä¸æ˜¯ä¸€ä¸ªæ™®é€šçš„å‡½æ•°è°ƒç”¨ï¼Œ
/// è€Œæ˜¯éœ€è¦ç¼–è¯‘å™¨ç‰¹æ®Šå¤„ç†çš„è¯­æ³•ç»“æ„ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_atom_expr` ä¸­å¤„ç† `Array::make`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ `atom_expr.mbt` ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•° `parse_array_make_expr`
/// æ¥å®ç°å¯¹è¿™ä¸ªç‰¹æ®Šè¯­æ³•çš„è§£æã€‚`parse_atom_expr` å°†åœ¨é‡åˆ° `Array` å…³é”®å­—æ—¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **å…¥å£ï¼š** å½“ `parse_atom_expr` é‡åˆ° `Array` è¿™ä¸ª `Upper` ç±»å‹çš„ Token æ—¶ï¼Œ
///     å®ƒåº”è¯¥å°†è§£æå·¥ä½œå§”æ‰˜ç»™ `parse_array_make_expr`ã€‚
///
/// 2.  **`parse_array_make_expr` çš„é€»è¾‘ï¼š**
///     *   è¿™ä¸ªå‡½æ•°éœ€è¦è¿›è¡Œä¸€æ¬¡ç²¾ç¡®çš„â€œæ¨¡å¼åŒ¹é…â€ï¼Œç¡®ä¿æ¥ä¸‹æ¥çš„ Token åºåˆ—æ˜¯ `::`ï¼Œ`make`ï¼Œå’Œ `(`ã€‚
///       å¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆè¿™å¯èƒ½æ˜¯ä¸€ä¸ªæ™®é€šçš„ä»¥ `Array` å¼€å¤´çš„ç±»å‹åï¼Œåº”è¯¥ç«‹å³æŠ¥é”™æˆ–äº¤ç”±å…¶ä»–é€»è¾‘å¤„ç†ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œç›´æ¥æŠ¥é”™ï¼‰ã€‚
///     *   è·³è¿‡ `Array::make(` è¿™ä¸€å›ºå®šåºåˆ—ã€‚
///     *   è°ƒç”¨ `parse_expr` æ¥è§£ææ•°ç»„çš„**å¤§å°ï¼ˆsizeï¼‰**ã€‚
///     *   ç¡®ä¿ä¸‹ä¸€ä¸ª Token æ˜¯ä¸€ä¸ªé€—å· `,`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   å†æ¬¡è°ƒç”¨ `parse_expr` æ¥è§£ææ•°ç»„çš„**åˆå§‹å€¼ï¼ˆinitï¼‰**ã€‚
///     *   ç¡®ä¿æœ€åä¸€ä¸ª Token æ˜¯ä¸€ä¸ªå³æ‹¬å· `)`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   æœ€åï¼Œå°†è§£æå‡ºçš„ `size` å’Œ `init` ä¸¤ä¸ªè¡¨è¾¾å¼ç»„è£…æˆä¸€ä¸ª `ArrayMake` èŠ‚ç‚¹ã€‚
///
/// è¿™ç§ä¸ºç‰¹å®šè¯­æ³•â€œå¼€æ´â€çš„åšæ³•ï¼Œåœ¨çœŸå®çš„ç¼–è¯‘å™¨ä¸­éå¸¸å¸¸è§ï¼Œå®ƒä½“ç°äº†è¯­è¨€è®¾è®¡åœ¨ä¸€è‡´æ€§ä¸å®ç”¨æ€§ä¹‹é—´çš„æƒè¡¡ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_array_make_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼ä½ æ­£åœ¨å­¦ä¹ ç¼–è¯‘å™¨å¼€å‘ä¸­éå¸¸å®ç”¨çš„ä¸€ä¸ªæŠ€å·§ï¼**
/// ================================================================================

///|
test "Array Make Expr Parsing Test" {
  let code =
    #|Array::make(10, 0)
    #|Array::make(5, true)
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(
    a.kind is AtomExprKind::ArrayMake(size_expr, init_expr) &&
    size_expr.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(10) &&
    init_expr.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(0),
  )
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is AtomExprKind::ArrayMake(size_expr, init_expr) &&
    size_expr.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(5) &&
    init_expr.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Bool(true),
  )
}
/// ================================================================================
/// # ç»„è£…ï¼è§£æèµ‹å€¼è¯­å¥
///
/// ä¸‡äº‹ä¿±å¤‡ï¼æˆ‘ä»¬å·²ç»åˆ†åˆ«å®ç°äº† `left_value` å’Œ `expr` çš„è§£æå™¨ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™å°†å®ƒä»¬ç»„è£…èµ·æ¥ï¼Œå®Œæˆ**èµ‹å€¼è¯­å¥ï¼ˆAssignment Statementï¼‰**çš„è§£æäº†ã€‚
///
/// ## èµ‹å€¼è¯­å¥çš„ EBNF èŒƒå¼
///
/// è®©æˆ‘ä»¬å†æ¬¡å›é¡¾ä¸€ä¸‹èµ‹å€¼è¯­å¥çš„ç»“æ„ï¼š
///
/// ```
/// assign_stmt ::= left_value assign_op expr ";"
/// ```
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_assign_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/assign_stmt.mbt` ä¸­å®ç° `parse_assign_stmt` å‡½æ•°ã€‚
///
/// è¿™ä¸ªä»»åŠ¡éå¸¸ç›´æ¥ï¼Œå®ƒå®Œç¾åœ°ä½“ç°äº†é€’å½’ä¸‹é™è§£æå™¨çš„â€œç»„åˆâ€æ€æƒ³ï¼š
///
/// 1.  **è§£æå·¦å€¼ï¼š** é¦–å…ˆï¼Œè°ƒç”¨ä½ åˆšåˆšå®Œæˆçš„ `parse_left_value` å‡½æ•°æ¥è§£æèµ‹å€¼ç¬¦å·å·¦è¾¹çš„éƒ¨åˆ†ã€‚
/// 2.  **è§£æèµ‹å€¼ç¬¦å·ï¼š** æ¥ç€ï¼ŒåŒ¹é…ä¸€ä¸ªèµ‹å€¼æ“ä½œç¬¦ï¼ˆ`=`ã€`+=` ç­‰ï¼‰ã€‚
/// 3.  **è§£æå³å€¼ï¼š** ç„¶åï¼Œè°ƒç”¨æˆ‘ä»¬å¼ºå¤§çš„ `parse_expr` å‡½æ•°æ¥è§£æèµ‹å€¼ç¬¦å·å³è¾¹çš„è¡¨è¾¾å¼ã€‚
/// 4.  **ç»“å°¾ï¼š** æœ€åï¼Œç¡®ä¿è¯­å¥ä»¥åˆ†å· `;` ç»“å°¾ã€‚
///
/// ä½ çœ‹ï¼Œæˆ‘ä»¬ä¹‹å‰æ‰€æœ‰çš„åŠªåŠ›ï¼Œéƒ½æ˜¯ä¸ºäº†åœ¨è¿™ä¸€åˆ»èƒ½å¤Ÿè½»æ¾åœ°å°†å„ä¸ªéƒ¨åˆ†ç»„åˆåœ¨ä¸€èµ·ã€‚
///
/// åŠ æ²¹ï¼Œè§£æå™¨çš„è¯­å¥éƒ¨åˆ†å³å°†å®Œæˆï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_assign_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Assign Stmt Parsing Test" {
  let code =
    #|obj.field1 = 42 ;
    #|matrix[1][2] += 3.14 ;
    #|arr[3][5].field -= arr[0][0] ;
    #|x *= 10 ;
    #|y /= 2 ;
    #|z %= 5 ;
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_assign_stmt(tokens[:])
  assert_true(
    a.left_value.kind is FieldAccess(field_access, field_name) &&
    field_name is "field1" &&
    field_access.kind is Ident("obj") &&
    a.op is Assign &&
    a.expr.kind is ApplyExpr(expr_app) &&
    expr_app.kind is AtomExpr(expr_atom) &&
    expr_atom.kind is Int(42),
  )
  let (a, tok_view) = parse_assign_stmt(tok_view)
  assert_true(
    a.left_value.kind is ArrayAccess(array_access2, index_expr2) &&
    index_expr2.kind is ApplyExpr(index_app2) &&
    index_app2.kind is AtomExpr(index_atom2) &&
    index_atom2.kind is Int(2) &&
    array_access2.kind is ArrayAccess(array_access1, index_expr1) &&
    index_expr1.kind is ApplyExpr(index_app1) &&
    index_app1.kind is AtomExpr(index_atom1) &&
    index_atom1.kind is Int(1) &&
    array_access1.kind is Ident("matrix") &&
    a.op is PlusAssign &&
    a.expr.kind is ApplyExpr(expr_app2) &&
    expr_app2.kind is AtomExpr(expr_atom2) &&
    expr_atom2.kind is Double(3.14),
  )
  let (a, tok_view) = parse_assign_stmt(tok_view)
  assert_true(
    a.left_value.kind is FieldAccess(field_access2, field_name2) &&
    field_name2 is "field" &&
    field_access2.kind is ArrayAccess(array_access3, index_expr3) &&
    index_expr3.kind is ApplyExpr(index_app3) &&
    index_app3.kind is AtomExpr(index_atom3) &&
    index_atom3.kind is Int(5) &&
    array_access3.kind is ArrayAccess(array_access4, index_expr4) &&
    index_expr4.kind is ApplyExpr(index_app4) &&
    index_app4.kind is AtomExpr(index_atom4) &&
    index_atom4.kind is Int(3) &&
    array_access4.kind is Ident("arr") &&
    a.op is MinusAssign &&
    a.expr.kind is ApplyExpr(expr_app3) &&
    expr_app3.kind is ArrayAccess(expr_array_access, expr_index_expr) &&
    expr_index_expr.kind is ApplyExpr(expr_index_app) &&
    expr_index_app.kind is AtomExpr(expr_index_atom) &&
    expr_index_atom.kind is Int(0) &&
    expr_array_access.kind is ArrayAccess(expr_array_access2, expr_index_expr2) &&
    expr_index_expr2.kind is ApplyExpr(expr_index_app2) &&
    expr_index_app2.kind is AtomExpr(expr_index_atom2) &&
    expr_index_atom2.kind is Int(0) &&
    expr_array_access2.kind is AtomExpr(expr_array_atom) &&
    expr_array_atom.kind is Ident("arr"),
  )
  let (a, _) = parse_assign_stmt(tok_view)
  assert_true(
    a.left_value.kind is Ident("x") &&
    a.op is MultAssign &&
    a.expr.kind is ApplyExpr(expr_app4) &&
    expr_app4.kind is AtomExpr(expr_atom4) &&
    expr_atom4.kind is Int(10),
  )
}
/// ================================================================================
/// # ä»£ç å—çš„åŠ›é‡ï¼šè§£æ BlockExpr
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥è§£æç‹¬ç«‹çš„è¯­å¥äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬è¦å°†å®ƒä»¬ç»„ç»‡åˆ°ä¸€ä¸ªéå¸¸é‡è¦çš„ç»“æ„ä¸­ï¼š
/// **ä»£ç å—è¡¨è¾¾å¼ï¼ˆBlock Expressionï¼‰**ã€‚
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œä»£ç å—ç”± `{}` åŒ…è£¹ï¼Œå®ƒæœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå…¶å€¼æ˜¯å—å†…æœ€åä¸€æ¡è¡¨è¾¾å¼çš„å€¼ã€‚
///
/// ## BlockExpr çš„ EBNF èŒƒå¼
///
/// ```
/// block_expr ::= "{" stmt* expr? "}"
/// ```
///
/// è¿™æ®µèŒƒå¼å‘Šè¯‰æˆ‘ä»¬ï¼Œä¸€ä¸ªä»£ç å—åŒ…å«ï¼š
/// 1.  ä¸€ä¸ªèµ·å§‹çš„ `{"{"`ã€‚
/// 2.  é›¶æ¡æˆ–å¤šæ¡ï¼ˆ`*`ï¼‰ä»¥åˆ†å·ç»“å°¾çš„è¯­å¥ï¼ˆ`stmt`ï¼‰ã€‚
/// 3.  å¯é€‰åœ°ï¼ˆ`?`ï¼‰ï¼Œæœ€åå¯ä»¥æœ‰ä¸€æ¡ä¸å¸¦åˆ†å·çš„è¡¨è¾¾å¼ï¼ˆ`expr`ï¼‰ï¼Œå®ƒçš„å€¼å°±æ˜¯æ•´ä¸ªå—çš„å€¼ã€‚
/// 4.  ä¸€ä¸ªç»ˆç»“çš„ `"}"`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_block_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/block_expr.mbt` ä¸­å®ç° `parse_block_expr` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  åŒ¹é…å¹¶è·³è¿‡å¼€å¤´çš„ `{"{"`ã€‚
/// 2.  è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œåå¤è°ƒç”¨ `parse_stmt` æ¥è§£æå—å†…çš„æ¯ä¸€æ¡è¯­å¥ã€‚
/// 3.  å¾ªç¯ç›´åˆ°é‡åˆ° `"}"` ä¸ºæ­¢ã€‚
/// 4.  åŒ¹é…å¹¶è·³è¿‡ç»“å°¾çš„ `"}"`ã€‚
///
/// ### ğŸ¤” ä¸€ä¸ªæ£˜æ‰‹çš„é—®é¢˜ï¼šå¦‚ä½•å¤„ç†æœ€åä¸€æ¡â€œä¸å¸¦åˆ†å·â€çš„è¡¨è¾¾å¼ï¼Ÿ
///
/// EBNF ä¸­çš„ `expr?` æ˜¯æ•´ä¸ªè§£æè¿‡ç¨‹ä¸­çš„ä¸€ä¸ªéš¾ç‚¹ã€‚
/// `let x = { let y = 1; y + 1 }` æ˜¯åˆæ³•çš„ï¼Œæœ€åçš„ `y + 1` æ²¡æœ‰åˆ†å·ã€‚
///
/// è¿™æ„å‘³ç€ï¼Œå½“æˆ‘ä»¬çš„ `parse_stmt` åœ¨è§£æä¸€ä¸ªå¯èƒ½æ˜¯ `expr_stmt` çš„è¯­å¥æ—¶ï¼Œ
/// å®ƒä¸èƒ½å†å›ºæ‰§åœ°è¦æ±‚ç»“å°¾å¿…é¡»æ˜¯ `;` äº†ã€‚
///
/// **ğŸ’¡ æç¤ºï¼š**
///
/// è§£å†³è¿™ä¸ªé—®é¢˜çš„å…³é”®åœ¨äº**ä¿®æ”¹ `parse_stmt` å‡½æ•°**ã€‚
///
/// å½“ `parse_stmt` è§£æå®Œä¸€ä¸ª `expr_stmt` åï¼Œå®ƒéœ€è¦æ£€æŸ¥ä¸‹ä¸€ä¸ª Tokenï¼š
/// *   å¦‚æœ Token æ˜¯ `;`ï¼Œé‚£ä¹ˆæ¶ˆè€—å®ƒï¼Œè¯­å¥ç»“æŸã€‚
/// *   å¦‚æœ Token æ˜¯ `}`ï¼Œé‚£ä¹ˆè¯´æ˜è¿™å·²ç»æ˜¯å—çš„ç»“å°¾äº†ï¼Œ**ä¸æ¶ˆè€—å®ƒ**ï¼Œç›´æ¥å°† `expr_stmt` è¿”å›ã€‚
/// *   å¦‚æœæ˜¯å…¶ä»– Tokenï¼Œåˆ™åº”è¯¥æŠ¥é”™ã€‚
///
/// é€šè¿‡åœ¨ `parse_stmt` ä¸­å¢åŠ å¯¹ `}` çš„â€œå®½å®¹â€ï¼Œ`parse_block_expr` çš„å®ç°å°±å¯ä»¥ä¿æŒéå¸¸ç®€å•ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_block_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Block Expr Parsing" {
  let code =
    #|{
    #|  let x = 10;
    #|  let mut y = 20;
    #|  y = y + x;
    #|  let t = Array::make(5, 0);
    #|  t[0] = y;
    #|}
  let tokens = @lexer.tokenize(code)
  let (block, _) = parse_block_expr(tokens)
  assert_true(block.stmts.length() is 5)
  assert_true(block.stmts[0].kind is LetStmt(_))
  assert_true(block.stmts[1].kind is LetMutStmt(_))
  assert_true(block.stmts[2].kind is AssignStmt(_))
  assert_true(block.stmts[3].kind is LetStmt(_))
  assert_true(block.stmts[4].kind is AssignStmt(_))
}

///|
test "Complex Apply Expr Parsing Test" {
  let code =
    #|obj.field1[0].method(a1, b2) ;
    #|matrix[1][2].to_string() ;
    #|arr[3](5)[7]
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(
    a.kind is Call(call_expr, [a1, a2]) &&
    a1.kind is ApplyExpr(arg1) &&
    arg1.kind is AtomExpr(atom_a1) &&
    atom_a1.kind is Ident("a1") &&
    a2.kind is ApplyExpr(arg2) &&
    arg2.kind is AtomExpr(atom_b2) &&
    atom_b2.kind is Ident("b2") &&
    call_expr.kind is FieldAccess(field_access2, field_name2) &&
    field_name2 is "method" &&
    field_access2.kind is ArrayAccess(array_access, index_expr) &&
    index_expr.kind is ApplyExpr(index_apply) &&
    index_apply.kind is AtomExpr(index_atom) &&
    index_atom.kind is Int(0) &&
    array_access.kind is FieldAccess(field_access, field_name) &&
    field_name is "field1" &&
    field_access.kind is AtomExpr(atom_obj) &&
    atom_obj.kind is Ident("obj"),
  )
  let (a, tok_view) = parse_apply_expr(tok_view[1:])
  assert_true(
    a.kind is Call(call_expr2, []) &&
    call_expr2.kind is FieldAccess(field_access4, field_name4) &&
    field_name4 is "to_string" &&
    field_access4.kind is ArrayAccess(array_access2, index_expr2) &&
    index_expr2.kind is ApplyExpr(index_apply2) &&
    index_apply2.kind is AtomExpr(index_atom2) &&
    index_atom2.kind is Int(2) &&
    array_access2.kind is ArrayAccess(array_access1, index_expr1) &&
    index_expr1.kind is ApplyExpr(index_apply1) &&
    index_apply1.kind is AtomExpr(index_atom1) &&
    index_atom1.kind is Int(1) &&
    array_access1.kind is AtomExpr(atom_matrix) &&
    atom_matrix.kind is Ident("matrix"),
  )
  let (a, _) = parse_apply_expr(tok_view[1:])
  assert_true(
    a.kind is ArrayAccess(array_access3, index_expr3) &&
    index_expr3.kind is ApplyExpr(index_apply3) &&
    index_apply3.kind is AtomExpr(index_atom3) &&
    index_atom3.kind is Int(7) &&
    array_access3.kind is Call(call_expr3, [arg_expr]) &&
    arg_expr.kind is ApplyExpr(arg_apply) &&
    arg_apply.kind is AtomExpr(arg_atom) &&
    arg_atom.kind is Int(5) &&
    call_expr3.kind is ArrayAccess(array_access4, index_expr4) &&
    index_expr4.kind is ApplyExpr(index_apply4) &&
    index_apply4.kind is AtomExpr(index_atom4) &&
    index_atom4.kind is Int(3) &&
    array_access4.kind is AtomExpr(atom_arr) &&
    atom_arr.kind is Ident("arr"),
  )
}
/// ================================================================================
/// # è¡¨è¾¾å¼è§£æçš„æœ€ç»ˆç« ï¼šç»„åˆä¸€åˆ‡
///
/// æ­å–œä½ ï¼ä½ å·²ç»åˆ†åˆ«æ„å»ºäº† `ApplyExpr`ã€`IfExpr`ã€`BlockExpr` ä»¥åŠå¤„ç†ä¸€å…ƒå’ŒäºŒå…ƒæ“ä½œçš„å„ç§é€»è¾‘ã€‚
/// ç°åœ¨ï¼Œæˆ‘ä»¬æ¥åˆ°äº†è¡¨è¾¾å¼è§£æçš„æœ€åä¸€ç«™ï¼šå°†æ‰€æœ‰è¿™äº›éƒ¨åˆ†åœ¨ `parse_expr` å‡½æ•°ä¸­å®Œç¾åœ°ç»„åˆèµ·æ¥ã€‚
///
/// ## è¡¨è¾¾å¼çš„â€œåˆ†è¯Šå°â€
///
/// `parse_expr` å‡½æ•°å°±åƒä¸€ä¸ªæ€¥è¯Šå®¤çš„åˆ†è¯Šå°ã€‚å½“ä¸€ä¸² Token åˆ°æ¥æ—¶ï¼Œå®ƒéœ€è¦å¿«é€Ÿåˆ¤æ–­è¿™å±äºå“ªç§â€œç—…ä¾‹â€ï¼Œ
/// ç„¶åå°†å…¶åˆ†å‘ç»™å¯¹åº”çš„â€œä¸“ç§‘åŒ»ç”Ÿâ€ï¼ˆä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¹‹å‰å†™çš„å„ä¸ªå­è§£æå™¨ï¼‰ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œå–„ `parse_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯æœ€åä¸€æ¬¡ä¿®æ”¹ `parser/expr.mbt` ä¸­çš„ `parse_expr` å‡½æ•°ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†æ‰€æœ‰ç±»å‹çš„è¡¨è¾¾å¼ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **ç‰¹æ®Šæƒ…å†µä¼˜å…ˆï¼š**
///     *   é¦–å…ˆï¼Œæ£€æŸ¥å¼€å¤´çš„ Token æ˜¯å¦æ˜¯ `if` æˆ– `{`ã€‚å¦‚æœæ˜¯ï¼Œé‚£ä¹ˆæ•´ä¸ªè¡¨è¾¾å¼å°±æ˜¯ä¸€ä¸ª `IfExpr` æˆ– `BlockExpr`ï¼Œ
///       ç›´æ¥è°ƒç”¨å¯¹åº”çš„ `parse_if_expr` æˆ– `parse_block_expr` å‡½æ•°ï¼Œç„¶åè¿”å›ç»“æœã€‚
///     *   æ¥ç€ï¼Œæ£€æŸ¥å¼€å¤´æ˜¯å¦æ˜¯ä¸€å…ƒæ“ä½œç¬¦ï¼ˆ`!` æˆ– `-`ï¼‰ã€‚å¦‚æœæ˜¯ï¼ŒæŒ‰ç…§æˆ‘ä»¬ä¹‹å‰å®ç°çš„ä¸€å…ƒæ“ä½œé€»è¾‘è¿›è¡Œè§£æã€‚
///
/// 2.  **é»˜è®¤æƒ…å†µï¼š**
///     *   å¦‚æœä»¥ä¸Šæƒ…å†µéƒ½ä¸åŒ¹é…ï¼Œé‚£ä¹ˆå®ƒå¿…ç„¶æ˜¯ä¸€ä¸ªä»¥ `ApplyExpr` å¼€å¤´çš„è¡¨è¾¾å¼ï¼Œ
///       åé¢å¯èƒ½è·Ÿç€ä¸€ç³»åˆ—çš„äºŒå…ƒæ“ä½œç¬¦ï¼ˆä¾‹å¦‚ `a + b * c`ï¼‰ã€‚
///     *   åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰§è¡Œæˆ‘ä»¬ä¸ºäºŒå…ƒæ“ä½œç¬¦å®ç°çš„ã€åŒ…å«ä¼˜å…ˆçº§å¤„ç†çš„â€œè°ƒåº¦åœºâ€ç®—æ³•ã€‚
///
/// é€šè¿‡è¿™ç§â€œç‰¹æ®Šæƒ…å†µä¼˜å…ˆï¼Œä¸€èˆ¬æƒ…å†µç½®åâ€çš„ç­–ç•¥ï¼Œä½ å°±å¯ä»¥å°†æ‰€æœ‰ç‹¬ç«‹çš„è§£æé€»è¾‘ä¼˜é›…åœ°æ•´åˆåœ¨ä¸€èµ·ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// è¿™ä¸ªæµ‹è¯•æ–‡ä»¶åŒ…å«äº†ä¸€äº›å°†ä¸åŒè¡¨è¾¾å¼ï¼ˆå¦‚ `if` å’ŒäºŒå…ƒæ“ä½œï¼‰ç»„åˆåœ¨ä¸€èµ·çš„å¤æ‚åœºæ™¯ï¼Œ
/// æ˜¯å¯¹ä½ æœ€ç»ˆ `parse_expr` å‡½æ•°çš„ç»ˆæè€ƒéªŒã€‚
///
/// ```bash
/// moon test -p parser -f parse_complex_expr_test.mbt
/// ```
///
/// **ç¥è´ºä½ ï¼å®Œæˆè¿™ä¸€æ­¥ï¼Œä½ çš„è¡¨è¾¾å¼è§£æå™¨å°±çœŸæ­£å¤§åŠŸå‘Šæˆäº†ï¼** ğŸ†
/// ================================================================================

///|
test "Complex Expr Parsing Test" {
  let code =
    #|(if a > b { a; } else { b; }) + (if c < d { c; } else { d; }) ;
  let tokens = @lexer.tokenize(code)
  let (e, _) = parse_expr(tokens)
  assert_true(
    e.kind is BinaryExpr(Add, l, r) &&
    l.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(a1) &&
    a1.kind is Paren(a1) &&
    a1.kind is IfExpr(_) &&
    r.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(a2) &&
    a2.kind is Paren(a2) &&
    a2.kind is IfExpr(_),
  )
}
/// ================================================================================
/// # æ§åˆ¶æµï¼šè§£æ if-else è¡¨è¾¾å¼
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥è§£æçº¿æ€§çš„è¯­å¥æµäº†ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥ä¸ºè¯­è¨€å¼•å…¥ç¬¬ä¸€ä¸ªçœŸæ­£çš„**æ§åˆ¶æµ**ç»“æ„ï¼š
/// **if-else è¡¨è¾¾å¼**ã€‚
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œ`if-else` å’Œä»£ç å—ä¸€æ ·ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒå¯ä»¥æœ‰è¿”å›å€¼ã€‚
///
/// ## if-else çš„ EBNF èŒƒå¼
///
/// ```
/// if_expr ::= "if" expr block_expr ("else" (if_expr | block_expr))?
/// ```
///
/// è¿™æ®µèŒƒå¼æ­ç¤ºäº†ä¸€ä¸ª `if-else` ç»“æ„æœ€æœ‰è¶£çš„éƒ¨åˆ†ï¼š
/// 1.  ä»¥ `if` å…³é”®å­—å¼€å¤´ï¼Œåè·Ÿä¸€ä¸ªæ¡ä»¶ `expr` å’Œä¸€ä¸ª `then` åˆ†æ”¯çš„ `block_expr`ã€‚
/// 2.  `else` éƒ¨åˆ†æ˜¯å¯é€‰çš„ã€‚
/// 3.  å¦‚æœå­˜åœ¨ `else`ï¼Œå®ƒåé¢å¯ä»¥è·Ÿç€å¦ä¸€ä¸ª `if_expr`ï¼ˆè¿™å°±æ„æˆäº† `else if` é“¾ï¼‰ï¼Œæˆ–è€…ä¸€ä¸ªæœ€ç»ˆçš„ `block_expr`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_if_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/if_expr.mbt` ä¸­å®ç° `parse_if_expr` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  è§£æ `if`ã€æ¡ä»¶è¡¨è¾¾å¼å’Œ `then` ä»£ç å—ã€‚è¿™éƒ¨åˆ†éå¸¸ç›´æ¥ã€‚
/// 2.  æ£€æŸ¥ `then` å—åé¢æ˜¯å¦æœ‰ `else` å…³é”®å­—ã€‚
/// 3.  å¦‚æœæœ‰ `else`ï¼Œä½ éœ€è¦å†æ¬¡å‘åçœ‹ä¸€ä¸ª Tokenï¼š
///     *   å¦‚æœ `else` åé¢è·Ÿç€ `if`ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ª `else if`ï¼Œä½ åº”è¯¥**é€’å½’åœ°è°ƒç”¨ `parse_if_expr`** æ¥è§£æè¿™ä¸ªé“¾å¼ç»“æ„ã€‚
///     *   å¦‚æœ `else` åé¢è·Ÿç€ `{`ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªæœ€ç»ˆçš„ `else` åˆ†æ”¯ï¼Œä½ åº”è¯¥è°ƒç”¨ `parse_block_expr` æ¥è§£æå®ƒã€‚
///
/// ### ğŸ’¡ æ•°æ®ç»“æ„æç¤ºï¼š`Either`
///
/// `else` åˆ†æ”¯æ—¢å¯èƒ½æ˜¯ `if_expr`ï¼Œä¹Ÿå¯èƒ½æ˜¯ `block_expr`ã€‚å¦‚ä½•åœ¨ä¸€ä¸ªå­—æ®µé‡Œè¡¨ç¤ºè¿™ä¸¤ç§å¯èƒ½æ€§å‘¢ï¼Ÿ
///
/// MoonBit æ ‡å‡†åº“ä¸­çš„ `Either[A, B]` ç±»å‹æ˜¯ä¸ºæ­¤åœºæ™¯é‡èº«å®šåšçš„ã€‚
/// å®ƒå¯ä»¥å­˜æ”¾ä¸¤ç§ç±»å‹çš„å€¼ä¹‹ä¸€ï¼š`Left(A)` æˆ– `Right(B)`ã€‚
///
/// åœ¨ `if_expr.mbt` ä¸­ï¼Œ`else_block` å­—æ®µçš„ç±»å‹ `Either[IfExpr, BlockExpr]?` å°±è¿ç”¨äº†è¿™ä¸ªæ€æƒ³ï¼Œ
/// ä½ å¯ä»¥åˆ©ç”¨å®ƒæ¥ä¼˜é›…åœ°å­˜å‚¨ `else` åˆ†æ”¯çš„ä¸¤ç§å¯èƒ½æ€§ã€‚
///
/// ç›¸ä¿¡è¿™ä¸ªæŒ‘æˆ˜å¯¹ä½ æ¥è¯´å·²ç»ä¸éš¾äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_if_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Parse If Expr Test" {
  let code =
    #|if a < b { return a; }
    #|if a < b { return a; } else { return b; }
    #|if a > b { a; } else if a == b { 0; } else { b; }
  let tokens = @lexer.tokenize(code)
  let (if_expr1, tok_view) = parse_if_expr(tokens[:])
  assert_true(if_expr1.then_block.stmts.length() is 1)
  assert_true(if_expr1.else_block is None)
  let (if_expr2, tok_view) = parse_if_expr(tok_view)
  assert_true(if_expr2.then_block.stmts.length() is 1)
  assert_true(if_expr2.else_block is Some(else_block) && else_block is Right(_))
  let (if_expr3, _) = parse_if_expr(tok_view)
  assert_true(if_expr3.then_block.stmts.length() is 1)
  assert_true(
    if_expr3.else_block is Some(else_block) &&
    else_block is Left(else_if) &&
    else_if.then_block.stmts.length() is 1 &&
    else_if.else_block is Some(else_block2) &&
    else_block2 is Right(_),
  )
}
/// ================================================================================
/// # èµ‹å€¼çš„å·¦ä¾§ï¼šè§£æ LeftValue
///
/// æˆ‘ä»¬å³å°†å¼€å§‹è§£æèµ‹å€¼è¯­å¥ï¼ˆAssignment Statementï¼‰ï¼Œè¿™æ˜¯å‘½ä»¤å¼ç¼–ç¨‹çš„æ ¸å¿ƒä¹‹ä¸€ã€‚
/// åœ¨ `let` è¯­å¥ä¸­ï¼Œæˆ‘ä»¬æ˜¯â€œå£°æ˜å¹¶ç»‘å®šâ€ï¼›è€Œåœ¨èµ‹å€¼è¯­å¥ä¸­ï¼Œæˆ‘ä»¬æ˜¯â€œä¿®æ”¹ä¸€ä¸ªå·²å­˜åœ¨çš„å€¼â€ã€‚
///
/// ## èµ‹å€¼è¯­å¥ä¸ LeftValue
///
/// èµ‹å€¼è¯­å¥çš„ç»“æ„å¦‚ä¸‹ï¼š
///
/// ```
/// assign_stmt ::= left_value assign_op expr ";"
/// ```
///
/// è¿™é‡Œçš„ `assign_op` åŒ…æ‹¬ `=`ã€`+=` ç­‰ã€‚
///
/// å…³é”®åœ¨äº `left_value`ï¼ˆå·¦å€¼ï¼‰ã€‚ä»€ä¹ˆæ˜¯å·¦å€¼ï¼Ÿç®€å•æ¥è¯´ï¼Œå°±æ˜¯**å¯ä»¥è¢«æ”¾åœ¨èµ‹å€¼ç¬¦å·å·¦è¾¹çš„ä¸œè¥¿**ã€‚
/// å¹¶ä¸æ˜¯æ‰€æœ‰çš„è¡¨è¾¾å¼éƒ½å¯ä»¥æ˜¯å·¦å€¼ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥å†™ `x = 1`ï¼Œä½†ä¸èƒ½å†™ `x + 1 = 2`ã€‚
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œåˆæ³•çš„å·¦å€¼åŒ…æ‹¬ï¼š
/// 1.  **å˜é‡ï¼š** `x`
/// 2.  **æ•°ç»„å…ƒç´ ï¼š** `arr[i]`
/// 3.  **ç»“æ„ä½“å­—æ®µï¼š** `obj.field`
/// 4.  **ä»¥åŠå®ƒä»¬çš„ç»„åˆï¼š** `obj.arr[i].field`
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_left_value`
///
/// åœ¨è§£æå®Œæ•´çš„èµ‹å€¼è¯­å¥ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆåœ¨ `parser/left_value.mbt` ä¸­å®ç° `parse_left_value` å‡½æ•°ï¼Œ
/// ä¸“é—¨ç”¨äºè§£æèµ‹å€¼ç¬¦å·å·¦è¾¹çš„éƒ¨åˆ†ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// ä»”ç»†è§‚å¯Ÿå·¦å€¼çš„æ„æˆï¼Œä½ ä¼šå‘ç°å®ƒå’Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„ `ApplyExpr` éå¸¸ç›¸ä¼¼ï¼
///
/// `ApplyExpr` æ˜¯ `atom_expr` åé¢è·Ÿç€ä¸€ç³»åˆ—çš„ `(...)`ã€`[...]` æˆ– `.ident`ã€‚
/// è€Œ `LeftValue` æ˜¯ä¸€ä¸ª `ident` åé¢è·Ÿç€ä¸€ç³»åˆ—çš„ `[...]` æˆ– `.ident`ã€‚
///
/// å®ƒå°±åƒä¸€ä¸ªç®€åŒ–ç‰ˆçš„ `ApplyExpr` è§£æå™¨ï¼š
/// 1.  **èµ·ç‚¹ï¼š** `LeftValue` å¿…é¡»ä»¥ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼ˆ`ident`ï¼‰å¼€å§‹ã€‚
/// 2.  **å¾ªç¯ï¼š** åœ¨è§£æå‡ºæ ‡è¯†ç¬¦åï¼Œè¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œå‘åæ£€æŸ¥æ˜¯å¦å­˜åœ¨ `[` æˆ– `.`ã€‚
/// 3.  **ç»„åˆï¼š** å¦‚æœå­˜åœ¨ï¼Œå°±è§£æå¯¹åº”çš„æ•°ç»„ç´¢å¼•æˆ–å­—æ®µè®¿é—®ï¼Œå¹¶ç”¨å®ƒ**åŒ…è£¹**ä½ä¹‹å‰è§£æå‡ºçš„ `LeftValue`ï¼Œå½¢æˆä¸€ä¸ªæ–°çš„ `LeftValue`ã€‚
/// 4.  **ç»“æŸï¼š** å¾ªç¯ç›´åˆ°åé¢å†ä¹Ÿæ²¡æœ‰ `[` æˆ– `.` ä¸ºæ­¢ã€‚
///
/// ç›¸ä¿¡è¿™ä¸ªè¿‡ç¨‹å¯¹ä½ æ¥è¯´å·²ç»éå¸¸ç†Ÿæ‚‰äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_left_value_test.mbt
/// ```
/// ================================================================================

///|
test "LeftValue Parsing Test" {
  let code =
    #|obj.field1[0] ;
    #|matrix[1][2] ;
    #|arr[3][5].field
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_left_value(tokens[:])
  assert_true(
    a.kind is ArrayAccess(array_access, index_expr) &&
    index_expr.kind is ApplyExpr(index_app) &&
    index_app.kind is AtomExpr(index_atom) &&
    index_atom.kind is Int(0) &&
    array_access.kind is FieldAccess(field_access, field_name) &&
    field_name is "field1" &&
    field_access.kind is Ident("obj"),
  )
  let (a, tok_view) = parse_left_value(tok_view[1:])
  assert_true(
    a.kind is ArrayAccess(array_access2, index_expr2) &&
    index_expr2.kind is ApplyExpr(index_app2) &&
    index_app2.kind is AtomExpr(index_atom2) &&
    index_atom2.kind is Int(2) &&
    array_access2.kind is ArrayAccess(array_access1, index_expr1) &&
    index_expr1.kind is ApplyExpr(index_app1) &&
    index_app1.kind is AtomExpr(index_atom1) &&
    index_atom1.kind is Int(1) &&
    array_access1.kind is Ident("matrix"),
  )
  let (a, _) = parse_left_value(tok_view[1:])
  assert_true(
    a.kind is FieldAccess(field_access2, field_name2) &&
    field_name2 is "field" &&
    field_access2.kind is ArrayAccess(array_access3, index_expr3) &&
    index_expr3.kind is ApplyExpr(index_app3) &&
    index_app3.kind is AtomExpr(index_atom3) &&
    index_atom3.kind is Int(5) &&
    array_access3.kind is ArrayAccess(array_access4, index_expr4) &&
    index_expr4.kind is ApplyExpr(index_app4) &&
    index_app4.kind is AtomExpr(index_atom4) &&
    index_atom4.kind is Int(3) &&
    array_access4.kind is Ident("arr"),
  )
}
/// ================================================================================
/// # å¯å˜å˜é‡ï¼šè§£æ let mut è¯­å¥
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥è§£æä¸å¯å˜çš„ `let` ç»‘å®šäº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¥å¤„ç†å®ƒçš„â€œå…„å¼Ÿâ€ï¼š
/// `let mut` è¯­å¥ï¼Œå®ƒç”¨äºå£°æ˜ä¸€ä¸ª**å¯å˜å˜é‡**ã€‚
///
/// ## `let mut` è¯­å¥çš„ EBNF èŒƒå¼
///
/// `let mut` è¯­å¥çš„ç»“æ„ä¸ `let` éå¸¸ç›¸ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªå…³é”®åŒºåˆ«ï¼š
///
/// ```
/// let_mut_stmt ::= "let" "mut" ident (":" type)? "=" expr ";"
/// ```
///
/// **âš ï¸ è¯·åŠ¡å¿…æ³¨æ„ï¼š**
/// `let mut` çš„å·¦è¾¹åªèƒ½æ˜¯ä¸€ä¸ª**å•ä¸€çš„æ ‡è¯†ç¬¦ï¼ˆ`ident`ï¼‰**ï¼Œè€Œ**ä¸æ˜¯**åƒ `let` é‚£æ ·å¯ä»¥æ˜¯å¤æ‚çš„æ¨¡å¼ï¼ˆ`pattern`ï¼‰ã€‚
/// è¿™æ˜¯ MiniMoonBit çš„ä¸€ä¸ªè®¾è®¡é€‰æ‹©ï¼Œæ„å‘³ç€ä½ ä¸èƒ½å†™ `let mut (a, b) = ...` è¿™æ ·çš„ä»£ç ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_let_mut_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/let_mut_stmt.mbt` ä¸­å®ç° `parse_let_mut_stmt` å‡½æ•°ã€‚
///
/// è¿™ä¸ªä»»åŠ¡çš„æµç¨‹ä¸ `parse_let_stmt` é«˜åº¦ä¸€è‡´ï¼Œä½ åªéœ€è¦ï¼š
/// 1.  åŒ¹é… `let mut` è¿™ä¸¤ä¸ªè¿ç»­çš„å…³é”®å­—ã€‚
/// 2.  ç¡®ä¿åé¢è·Ÿç€çš„æ˜¯ä¸€ä¸ª `Lower` ç±»å‹çš„ Token ä½œä¸ºæ ‡è¯†ç¬¦ã€‚
/// 3.  å…¶ä½™éƒ¨åˆ†ï¼ˆå¯é€‰çš„ç±»å‹ã€`=`ã€è¡¨è¾¾å¼å’Œ `;`ï¼‰çš„è§£æä¸ `let` è¯­å¥å®Œå…¨ç›¸åŒã€‚
///
/// ç›¸ä¿¡è¿™å¯¹ä½ æ¥è¯´å·²ç»éå¸¸ç®€å•äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_let_mut_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Let Mut Stmt Parsing Test" {
  let code =
    #|let mut x : Int = 42;
    #|let mut y = 100;
    #|let mut z : (Int, Double) = (1, 2.0);
  let tokens = @lexer.tokenize(code)
  let (s, tok_view) = parse_let_mut_stmt(tokens)
  assert_true(
    s.name is "x" &&
    s.ty is Some(ty) &&
    ty.kind is Int &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (s, tok_view) = parse_let_mut_stmt(tok_view)
  assert_true(
    s.name is "y" &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(100),
  )
  let (s, _) = parse_let_mut_stmt(tok_view)
  assert_true(
    s.name is "z" &&
    s.ty is Some(ty) &&
    ty.kind is Tuple(tys) &&
    tys is [ty1, ty2] &&
    ty1 is Int &&
    ty2 is Double &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Tuple(es) &&
    es is [e1, e2] &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Double(2.0),
  )
}
/// ================================================================================
/// # è¯­å¥çš„åŸºçŸ³ï¼šè§£æ let è¯­å¥
///
/// æˆ‘ä»¬å·²ç»æŒæ¡äº† MiniMoonBit ä¸­æ‰€æœ‰è¡¨è¾¾å¼ã€ç±»å‹å’Œæ¨¡å¼çš„è§£ææ–¹æ³•ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™å°†å®ƒä»¬ç»„åˆèµ·æ¥ï¼Œå¼€å§‹è§£æ**è¯­å¥ï¼ˆStatementsï¼‰**äº†ï¼
///
/// `let` è¯­å¥æ˜¯ MiniMoonBit ä¸­æœ€æ ¸å¿ƒçš„è¯­å¥ï¼Œç”¨äºå°†ä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ç»‘å®šåˆ°ä¸€ä¸ªæ¨¡å¼ä¸Šã€‚
///
/// ## `let` è¯­å¥çš„ EBNF èŒƒå¼
///
/// `let` è¯­å¥çš„ç»“æ„å¯ä»¥ç”¨ EBNFï¼ˆæ‰©å±•å·´ç§‘æ–¯-ç‘™å°”èŒƒå¼ï¼‰æ¸…æ™°åœ°æè¿°ï¼š
///
/// ```
/// let_stmt ::= "let" pattern (":" type)? "=" expr ";"
/// ```
///
/// è¿™æ®µèŒƒå¼å‘Šè¯‰æˆ‘ä»¬ï¼š
/// 1.  ä¸€ä¸ª `let` è¯­å¥ä»¥ `let` å…³é”®å­—å¼€å¤´ã€‚
/// 2.  åé¢è·Ÿç€ä¸€ä¸ªæˆ‘ä»¬å·²ç»ä¼šè§£æçš„ `pattern`ã€‚
/// 3.  å¯é€‰åœ°ï¼ˆ`?` è¡¨ç¤º 0 æ¬¡æˆ– 1 æ¬¡ï¼‰ï¼Œå¯ä»¥æœ‰ä¸€ä¸ªå†’å· `:` å’Œä¸€ä¸ª `type`ã€‚
/// 4.  æ¥ç€æ˜¯ä¸€ä¸ªå¿…é¡»æœ‰çš„ç­‰å· `=` å’Œä¸€ä¸ª `expr`ã€‚
/// 5.  æœ€åå¿…é¡»ä»¥åˆ†å· `;` ç»“å°¾ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_let_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/let_stmt.mbt` ä¸­å®ç° `parse_let_stmt` å‡½æ•°ã€‚
///
/// ç›¸ä¿¡å¯¹äºå·²ç»èº«ç»ç™¾æˆ˜çš„ä½ æ¥è¯´ï¼Œè¿™ä¸ªä»»åŠ¡å·²ç»æ²¡æœ‰ä»€ä¹ˆéš¾åº¦äº†ã€‚
/// ä½ åªéœ€è¦ä¸¥æ ¼æŒ‰ç…§ EBNF èŒƒå¼æè¿°çš„é¡ºåºï¼Œä¾æ¬¡è°ƒç”¨æˆ‘ä»¬å·²ç»å†™å¥½çš„
/// `parse_pattern`, `parse_type`, å’Œ `parse_expr` å‡½æ•°ï¼Œå¹¶æ­£ç¡®å¤„ç†åˆ†éš”ç¬¦ï¼ˆ`:`ã€`=`ã€`;`ï¼‰å³å¯ã€‚
///
/// åŠ æ²¹ï¼Œè¿™æ˜¯æˆ‘ä»¬é€šå‘å®Œæ•´ç¨‹åºè§£æçš„å€’æ•°ç¬¬äºŒæ­¥ï¼ğŸ‰
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_let_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Let Stmt Parsing Test" {
  let code =
    #|let x : Int = 42;
    #|let (a, b) = (1, 2);
    #|let _ = println();
    #|let (_, (p, q)) = (r, s);
  let tokens = @lexer.tokenize(code)
  let (s, tok_view) = parse_let_stmt(tokens)
  assert_true(
    s.pattern.kind is Ident("x") &&
    s.ty is Some(ty) &&
    ty.kind is Int &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (s, tok_view) = parse_let_stmt(tok_view)
  assert_true(
    s.pattern.kind is Tuple(ps) &&
    ps is [p1, p2] &&
    p1.kind is Ident("a") &&
    p2.kind is Ident("b") &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Tuple(es) &&
    es is [e1, e2] &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(2),
  )
  let (s, tok_view) = parse_let_stmt(tok_view)
  assert_true(
    s.pattern.kind is Wildcard &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is Call(callee, []) &&
    callee.kind is AtomExpr(atom) &&
    atom.kind is Ident("println"),
  )
  let (s, _) = parse_let_stmt(tok_view)
  assert_true(
    s.pattern.kind is Tuple(ps) &&
    ps is [p1, p2] &&
    p1.kind is Wildcard &&
    p2.kind is Tuple(ps2) &&
    ps2 is [p21, p22] &&
    p21.kind is Ident("p") &&
    p22.kind is Ident("q") &&
    s.ty is None &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Tuple(es) &&
    es is [e1, e2] &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Ident("r") &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Ident("s"),
  )
}
/// ================================================================================
/// # å‡½æ•°ä½œä¸ºä¸€ç­‰å…¬æ°‘ï¼šè§£æå±€éƒ¨å‡½æ•°ä¸é—­åŒ…
///
/// åœ¨ç°ä»£ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå‡½æ•°ä¸ä»…ä»…æ˜¯é¡¶å±‚çš„ä»£ç ç»„ç»‡å•å…ƒï¼Œå®ƒä»¬è¿˜å¯ä»¥è¢«å®šä¹‰åœ¨å…¶ä»–å‡½æ•°å†…éƒ¨ï¼Œ
/// ç”šè‡³å¯ä»¥ä½œä¸ºå€¼è¢«ä¼ é€’å’Œè¿”å›ã€‚è¿™ç§å¯ä»¥â€œæ•è·â€å…¶å®šä¹‰æ—¶æ‰€åœ¨ç¯å¢ƒï¼ˆå³è®¿é—®å¤–éƒ¨å˜é‡ï¼‰çš„å†…éƒ¨å‡½æ•°ï¼Œ
/// å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„**é—­åŒ…ï¼ˆClosureï¼‰**ã€‚
///
/// MiniMoonBit æ”¯æŒåœ¨ä»£ç å—ä¸­å®šä¹‰**å±€éƒ¨å‡½æ•°ï¼ˆLocal Functionï¼‰**ï¼Œè¿™æ˜¯å®ç°é—­åŒ…çš„ç¬¬ä¸€æ­¥ã€‚
///
/// ## å±€éƒ¨å‡½æ•°çš„ EBNF èŒƒå¼
///
/// ```
/// fn_decl ::= "fn" ident "(" (param ("," param)*)? ")" ("->" type)? block_expr
/// param   ::= ident (":" type)?
/// ```
///
/// è¿™æ®µèŒƒå¼æè¿°äº†å‡½æ•°å£°æ˜çš„å„ä¸ªéƒ¨åˆ†ï¼š
/// 1.  `fn` å…³é”®å­—å’Œå‡½æ•°å `ident`ã€‚
/// 2.  `()` åŒ…è£¹çš„å‚æ•°åˆ—è¡¨ï¼Œå‚æ•°ä¹‹é—´ç”¨ `,` åˆ†éš”ã€‚
/// 3.  æ¯ä¸ªå‚æ•° `param` åŒ…å«ä¸€ä¸ªåå­— `ident` å’Œä¸€ä¸ªå¯é€‰çš„ç±»å‹æ³¨è§£ã€‚
/// 4.  ä¸€ä¸ªå¯é€‰çš„ `->` å’Œè¿”å›ç±»å‹ `type`ã€‚
/// 5.  ä¸€ä¸ªå‡½æ•°ä½“ `block_expr`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_local_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/local_function.mbt` ä¸­å®ç° `parse_local_function` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è§£æå‡½æ•°çš„ç»“æ„éå¸¸æ¸…æ™°ï¼Œä½ å¯ä»¥ä¸¥æ ¼æŒ‰ç…§ EBNF çš„é¡ºåºè¿›è¡Œï¼š
/// 1.  è§£æ `fn` å…³é”®å­—å’Œå‡½æ•°åã€‚
/// 2.  è§£æ `()` åŒ…è£¹çš„å‚æ•°åˆ—è¡¨ã€‚è¿™éƒ¨åˆ†æ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œä½ éœ€è¦è§£æé€—å·åˆ†éš”çš„ `ident` å’Œå¯é€‰çš„ç±»å‹ã€‚
/// 3.  è§£æå¯é€‰çš„è¿”å›ç±»å‹ã€‚
/// 4.  è°ƒç”¨ `parse_block_expr` è§£æå‡½æ•°ä½“ã€‚
///
/// ç»è¿‡äº†å‰é¢ä¸€ç³»åˆ—çš„è®­ç»ƒï¼Œè¿™ä¸ªä»»åŠ¡å¯¹ä½ æ¥è¯´åº”è¯¥å·²ç»é©¾è½»å°±ç†Ÿäº†ã€‚
///
/// åŠ æ²¹ï¼Œè¿™æ˜¯æˆ‘ä»¬å‘ç€ä¸€ä¸ªåŠŸèƒ½æ›´å®Œå¤‡çš„è¯­è¨€è¿ˆå‡ºçš„é‡è¦ä¸€æ­¥ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_local_function_test.mbt
/// ```
/// ================================================================================

///|
test "Local Function Parsing Test - 1" {
  let code =
    #|fn add(x, y) -> Int {
    #|  x + y;
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_local_function(tokens)
  assert_true(func.fname is "add")
  assert_true(func.param_list.length() is 2)
  assert_true(func.param_list[0] is ("x", None))
  assert_true(func.param_list[1] is ("y", None))
  assert_true(func.ret_ty is Some({ kind: Int, .. }))
  assert_true(func.body.stmts.length() is 1)
  assert_true(func.body.stmts[0].kind is ExprStmt(_))
}

///|
test "Local Function Parsing Test - 2" {
  let code =
    #|fn sin_max(x: Double, y) {
    #|  let sinx = sin(x);
    #|  let siny = sin(y);
    #|  if sinx > siny {
    #|    sinx;
    #|  } else {
    #|    siny;
    #|  };
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_local_function(tokens)
  assert_true(func.fname is "sin_max")
  assert_true(func.param_list.length() is 2)
  assert_true(func.param_list[0] is ("x", Some({ kind: Double, .. })))
  assert_true(func.param_list[1] is ("y", None))
  assert_true(func.ret_ty is None)
  assert_true(func.body.stmts.length() is 3)
  assert_true(func.body.stmts[0].kind is LetStmt(_))
  assert_true(func.body.stmts[1].kind is LetStmt(_))
  assert_true(func.body.stmts[2].kind is ExprStmt(_))
}
/// ================================================================================
/// # æ‹¬å·çš„é­”æ³•ï¼šåˆ†ç»„ã€å…ƒç»„å’Œå•å…ƒç±»å‹
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿè§£æå¤æ‚çš„äºŒå…ƒè¡¨è¾¾å¼äº†ï¼Œä½†è¿˜æœ‰ä¸€ä¸ªå…³é”®çš„è¯­æ³•ç»“æ„æ²¡æœ‰å¤„ç†ï¼š**æ‹¬å· `()`**ã€‚
/// åœ¨ MiniMoonBitï¼ˆä»¥åŠè®¸å¤šå…¶ä»–è¯­è¨€ï¼‰ä¸­ï¼Œæ‹¬å·æ‰®æ¼”ç€å¤šç§è§’è‰²ï¼Œæˆ‘ä»¬çš„è§£æå™¨å¿…é¡»èƒ½å¤Ÿå‡†ç¡®åœ°è¯†åˆ«å®ƒä»¬ã€‚
///
/// ## æ‹¬å·çš„ä¸‰ç§èº«ä»½
///
/// 1.  **åˆ†ç»„ï¼ˆGroupingï¼‰ï¼š** `(1 + 2) * 3`
///     *   æ‹¬å·å¯ä»¥ç”¨æ¥å¼ºåˆ¶æ”¹å˜è¿ç®—çš„ä¼˜å…ˆçº§ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‹¬å·å†…åªåŒ…å«**ä¸€ä¸ª**è¡¨è¾¾å¼ã€‚
///
/// 2.  **å…ƒç»„ï¼ˆTupleï¼‰ï¼š** `(1, "hello", true)`
///     *   å½“æ‹¬å·å†…åŒ…å«ç”±é€—å·åˆ†éš”çš„**å¤šä¸ª**è¡¨è¾¾å¼æ—¶ï¼Œå®ƒå°±æ„æˆäº†ä¸€ä¸ªå…ƒç»„ã€‚
///
/// 3.  **å•å…ƒç±»å‹ï¼ˆUnitï¼‰ï¼š** `()`
///     *   å½“æ‹¬å·å†…**æ²¡æœ‰ä»»ä½•å†…å®¹**æ—¶ï¼Œå®ƒä»£è¡¨ä¸€ä¸ªç‰¹æ®Šçš„å€¼å’Œç±»å‹ï¼š`Unit`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_atom_expr` ä¸­å¤„ç†æ‹¬å·
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ `atom_expr.mbt` ä¸­ï¼Œé€šè¿‡ä¸€ä¸ªæ–°çš„è¾…åŠ©å‡½æ•° `parse_paren_expr` æ¥å®ç°å¯¹è¿™ä¸‰ç§æƒ…å†µçš„è§£æã€‚
/// `parse_atom_expr` å°†åœ¨é‡åˆ° `(` æ—¶è°ƒç”¨è¿™ä¸ªæ–°å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **å…¥å£ï¼š** å½“ `parse_atom_expr` é‡åˆ° `(` æ—¶ï¼Œå®ƒåº”è¯¥å°†è§£æå·¥ä½œå§”æ‰˜ç»™ `parse_paren_expr`ã€‚
///
/// 2.  **`parse_paren_expr` çš„é€»è¾‘ï¼š**
///     *   é¦–å…ˆï¼Œè·³è¿‡å¼€å¤´çš„ `(`ã€‚
///     *   ç„¶åï¼Œè¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œå¼€å§‹è§£æå†…éƒ¨çš„è¡¨è¾¾å¼ã€‚è¿™é‡Œå¯ä»¥é€’å½’åœ°è°ƒç”¨ `parse_expr`ã€‚
///     *   æ¯è§£æå®Œä¸€ä¸ªè¡¨è¾¾å¼åï¼Œä½ éœ€è¦æ£€æŸ¥ä¸‹ä¸€ä¸ª Tokenï¼š
///         *   å¦‚æœæ˜¯ `)`ï¼Œé‚£ä¹ˆæ‹¬å·å†…çš„å†…å®¹è§£æå®Œæ¯•ï¼Œå¯ä»¥ç»“æŸå¾ªç¯äº†ã€‚
///         *   å¦‚æœæ˜¯ `,`ï¼Œé‚£ä¹ˆè¯´æ˜åé¢å¯èƒ½è¿˜æœ‰å¦ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä½ éœ€è¦è·³è¿‡è¿™ä¸ªé€—å·ï¼Œç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯ã€‚
///
/// 3.  **åŒºåˆ†ä¸‰ç§æƒ…å†µï¼š**
///     *   å¾ªç¯ç»“æŸåï¼Œæ£€æŸ¥ä½ è§£æå‡ºäº†å¤šå°‘ä¸ªè¡¨è¾¾å¼ï¼š
///         *   **0 ä¸ªï¼š** è¿™æ˜¯ä¸€ä¸ª `Unit`ã€‚
///         *   **1 ä¸ªï¼š** è¿™æ˜¯ä¸€ä¸ªåˆ†ç»„è¡¨è¾¾å¼ `Paren(Expr)`ã€‚
///         *   **å¤šä¸ªï¼š** è¿™æ˜¯ä¸€ä¸ª `Tuple(Array[Expr])`ã€‚
///
/// 4.  æœ€åï¼Œåˆ«å¿˜äº†è·³è¿‡ç»“å°¾çš„ `)`ã€‚
///
/// ## ğŸ¤” æ·±å…¥æ€è€ƒï¼šå°¾éšé€—å·ï¼ˆTrailing Commasï¼‰
///
/// åœ¨è®¾è®¡è§£æå™¨æ—¶ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘ä¸€äº›è¾¹ç•Œæƒ…å†µã€‚è®¸å¤šç°ä»£è¯­è¨€å…è®¸åœ¨åˆ—è¡¨æˆ–å…ƒç»„çš„æœ«å°¾æœ‰ä¸€ä¸ªå°¾éšçš„é€—å·ã€‚
///
/// *   `(1, 2, 3,)` åº”è¯¥æ˜¯åˆæ³•çš„å—ï¼Ÿ
/// *   å¦‚æœå…è®¸ä¸€ä¸ªå°¾éšé€—å·ï¼Œé‚£ä¹ˆ `(1, 2, 3,,)` è¿™ç§åŒ…å«å¤šä¸ªå°¾éšé€—å·çš„æƒ…å†µåˆè¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Ÿ
///
/// åœ¨ä½ çš„å®ç°ä¸­ï¼Œå¯ä»¥æ€è€ƒä¸€ä¸‹å¦‚ä½•ä¼˜é›…åœ°å¤„ç†è¿™äº›æƒ…å†µã€‚ä¸€ä¸ªå¥å£®çš„è§£æå™¨é€šå¸¸ä¼šå…è®¸ä¸€ä¸ªå°¾éšé€—å·ï¼Œä½†ä¼šæ‹’ç»å¤šä¸ªã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_paren_expr_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼è§£æå™¨å¯¹è¯­è¨€çš„ç†è§£æ­£åœ¨å˜å¾—è¶Šæ¥è¶Šç²¾ç»†ï¼**
/// ================================================================================

///|
test "Tuple, Paren and Unit Expr Parisng Test " {
  let code =
    #|(42, 3.14, true)
    #|(foo)
    #|((3.15, false))
    #|()
    #|((), ())
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(
    a.kind is Tuple(tup) &&
    tup is [e1, e2, e3] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(42) &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Double(3.14) &&
    e3.kind is ApplyExpr(app3) &&
    app3.kind is AtomExpr(atom3) &&
    atom3.kind is Bool(true),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is Paren(expr) &&
    expr.kind is ApplyExpr(app) &&
    app.kind is AtomExpr(atom) &&
    atom.kind is Ident("foo"),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is Paren(expr) &&
    expr.kind is ApplyExpr(app) &&
    app.kind is AtomExpr(atom) &&
    atom.kind is Tuple(tup) &&
    tup is [e1, e2] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Double(3.15) &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Bool(false),
  )
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Unit)
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(
    a.kind is Tuple(tup) &&
    tup is [e1, e2] &&
    e1.kind is ApplyExpr(app1) &&
    app1.kind is AtomExpr(atom1) &&
    atom1.kind is Unit &&
    e2.kind is ApplyExpr(app2) &&
    app2.kind is AtomExpr(atom2) &&
    atom2.kind is Unit,
  )
}
/// ================================================================================
/// # è§£æ„çš„åŠ›é‡ï¼šè§£ææ¨¡å¼
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥è§£æç±»å‹å’Œå¤æ‚çš„è¡¨è¾¾å¼äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¥å¤„ç†ä¸€ä¸ªä¸å®ƒä»¬ç´§å¯†ç›¸å…³ï¼Œ
/// ä½†åˆæœ‰æ‰€ä¸åŒçš„æ¦‚å¿µï¼š**æ¨¡å¼ï¼ˆPatternï¼‰**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯æ¨¡å¼ï¼Ÿ
///
/// æ¨¡å¼æ˜¯ä¸€ç§ç”¨äºâ€œè§£æ„â€å’Œâ€œç»‘å®šâ€å€¼çš„è¯­æ³•ã€‚ä½ å…¶å®å·²ç»è§è¿‡å®ƒæœ€ç®€å•çš„å½¢å¼äº†ã€‚
/// åœ¨ `let x = ...` ä¸­ï¼Œ`x` å°±æ˜¯ä¸€ä¸ªæœ€ç®€å•çš„æ ‡è¯†ç¬¦æ¨¡å¼ï¼ˆIdentifier Patternï¼‰ï¼Œå®ƒå°† `=` å³ä¾§çš„å€¼ç»‘å®šåˆ°å˜é‡ `x` ä¸Šã€‚
///
/// åœ¨æ›´å®Œå¤‡çš„è¯­è¨€ä¸­ï¼ˆåŒ…æ‹¬ MoonBitï¼Œä½† MiniMoonBit æœªå®ç°ï¼‰ï¼Œæ¨¡å¼ä¼šå¤§æ”¾å¼‚å½©çš„åœ°æ–¹æ˜¯ `match` è¡¨è¾¾å¼ï¼š
///
/// ```moonbit
/// match my_tuple {
///   (x, 0) => // å½“å…ƒç»„ç¬¬äºŒä¸ªå…ƒç´ ä¸º 0 æ—¶ï¼Œå°†ç¬¬ä¸€ä¸ªå…ƒç´ ç»‘å®šåˆ° x
///   (_, y) => // å¿½ç•¥ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå°†ç¬¬äºŒä¸ªå…ƒç´ ç»‘å®šåˆ° y
/// }
/// ```
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦åœ¨ `let` è¯­å¥ä¸­ä½¿ç”¨æ¨¡å¼ï¼Œä¾‹å¦‚ `let (a, b) = (1, 2)` æ¥åŒæ—¶ç»‘å®šå¤šä¸ªå˜é‡ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_pattern`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/pattern.mbt` ä¸­å®ç° `parse_pattern` å‡½æ•°ã€‚
///
/// MiniMoonBit æ”¯æŒçš„æ¨¡å¼éå¸¸ç®€å•ï¼š
/// 1.  **é€šé…ç¬¦ï¼š** `_`
/// 2.  **æ ‡è¯†ç¬¦ï¼š** `x`
/// 3.  **å…ƒç»„ï¼š** `(p1, p2, ...)`ï¼Œå…¶ä¸­ `p1`, `p2` ç­‰æœ¬èº«ä¹Ÿæ˜¯æ¨¡å¼ã€‚
///
/// ç›¸ä¿¡èªæ˜çš„ä½ å·²ç»å‘ç°ï¼Œè§£ææ¨¡å¼çš„é€»è¾‘ä¸è§£æå…ƒç»„ç±»å‹ã€å…ƒç»„è¡¨è¾¾å¼çš„é€»è¾‘éå¸¸ç›¸ä¼¼ï¼Œ
/// åªæ˜¯æ„æˆå®ƒçš„åŸºæœ¬å…ƒç´ æ›´å°‘ï¼ˆåªæœ‰ `_`, `ident` å’Œ `(...)`ï¼‰ã€‚
///
/// é‰´äºä½ å·²ç»æ˜¯æˆ‘ä»¬è§£æå™¨å¼€å‘çš„â€œè€å…µâ€äº†ï¼Œè¿™é‡Œçš„æ•™ç¨‹å°±ä¸å†èµ˜è¿°ã€‚æ”¾æ‰‹å»å®ç°å§ï¼
///
/// åŠ æ²¹ï¼ğŸš€
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_pattern_test.mbt
/// ```
/// ================================================================================

///|
test "Pattern Parsing Test" {
  let code =
    #|_ 
    #|a
    #|(a, b, _)
    #|(a, (b, c), _)
    #|((a, b), (c, d))
  let tokens = @lexer.tokenize(code)
  let (p, tok_view) = parse_pattern(tokens[:])
  assert_true(p.kind is Wildcard)
  let (p, tok_view) = parse_pattern(tok_view)
  assert_true(p.kind is Ident("a"))
  let (p, tok_view) = parse_pattern(tok_view)
  assert_true(
    p.kind is Tuple(ps) &&
    ps is [p1, p2, p3] &&
    p1.kind is Ident("a") &&
    p2.kind is Ident("b") &&
    p3.kind is Wildcard,
  )
  let (p, tok_view) = parse_pattern(tok_view)
  assert_true(
    p.kind is Tuple(ps) &&
    ps is [p1, p2, p3] &&
    p1.kind is Ident("a") &&
    p2.kind is Tuple(ps2) &&
    ps2 is [p21, p22] &&
    p21.kind is Ident("b") &&
    p22.kind is Ident("c") &&
    p3.kind is Wildcard,
  )
  let (p, _) = parse_pattern(tok_view)
  assert_true(
    p.kind is Tuple(ps) &&
    ps is [p1, p2] &&
    p1.kind is Tuple(ps1) &&
    ps1 is [p11, p12] &&
    p11.kind is Ident("a") &&
    p12.kind is Ident("b") &&
    p2.kind is Tuple(ps2) &&
    ps2 is [p21, p22] &&
    p21.kind is Ident("c") &&
    p22.kind is Ident("d"),
  )
}
/// ================================================================================
/// # è¯­æ³•åˆ†æçš„ç»ˆç‚¹ï¼šè§£ææ•´ä¸ªç¨‹åº
///
/// ğŸ‰ **ç¥è´ºä½ ï¼ä½ å·²ç»æ¥åˆ°äº†è¯­æ³•åˆ†æé˜¶æ®µçš„æœ€åä¸€å…³ï¼** ğŸ‰
///
/// æˆ‘ä»¬å·²ç»åˆ†åˆ«æ„å»ºäº†ç”¨äºè§£æè¡¨è¾¾å¼ã€è¯­å¥ã€ç±»å‹å’Œå„ç§é¡¶å±‚å£°æ˜çš„è§£æå™¨ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™å°†å®ƒä»¬å…¨éƒ¨æ•´åˆèµ·æ¥ï¼Œæ„å»ºä¸€ä¸ªèƒ½å¤Ÿè§£æå®Œæ•´ MiniMoonBit ç¨‹åºçš„æœ€ç»ˆ `parse` å‡½æ•°äº†ã€‚
///
/// ## ä»€ä¹ˆæ˜¯ç¨‹åºï¼Ÿ
///
/// åœ¨ MiniMoonBit ä¸­ï¼Œä¸€ä¸ªç¨‹åºï¼ˆ`Program`ï¼‰å°±æ˜¯ä¸€ç³»åˆ—é¡¶å±‚å£°æ˜çš„é›†åˆã€‚è¿™äº›å£°æ˜å¯ä»¥æ˜¯ï¼š
/// *   é¡¶å±‚å‡½æ•° (`TopFunction`)
/// *   é¡¶å±‚ `let` ç»‘å®š (`TopLet`)
/// *   ç»“æ„ä½“å®šä¹‰ (`StructDef`)
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç°æœ€ç»ˆçš„ `parse` å‡½æ•°
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/parser.mbt` ä¸­å®ç° `parse` å‡½æ•°ã€‚
///
/// **è¯·æ³¨æ„ï¼š** è¿™ä¸ªæœ€ç»ˆçš„ `parse` å‡½æ•°çš„ç­¾åä¸æˆ‘ä»¬ä¹‹å‰å†™çš„è¾…åŠ©å‡½æ•°æœ‰æ‰€ä¸åŒã€‚
/// å®ƒæ¥æ”¶çš„æ˜¯ä¸€ä¸ªå®Œæ•´çš„ `Array[Token]`ï¼Œè€Œä¸æ˜¯ `ArrayView[Token]`ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **åˆå§‹åŒ–ï¼š** åˆ›å»ºç”¨äºå­˜å‚¨ `TopFunction`ã€`TopLet` å’Œ `StructDef` çš„ `Map`ã€‚
///
/// 2.  **å¾ªç¯è§£æï¼š**
///     *   å¯åŠ¨ä¸€ä¸ªå¾ªç¯ï¼ŒæŒç»­å¤„ç† Token è§†å›¾ã€‚
///     *   åœ¨å¾ªç¯çš„æ¯ä¸€æ­¥ï¼Œæ£€æŸ¥å½“å‰çš„ Token æ˜¯ä»€ä¹ˆï¼š
///         *   å¦‚æœæ˜¯ `fn` å…³é”®å­—ï¼Œè°ƒç”¨ `parse_top_function`ã€‚
///         *   å¦‚æœæ˜¯ `let` å…³é”®å­—ï¼Œè°ƒç”¨ `parse_top_let`ã€‚
///         *   å¦‚æœæ˜¯ `struct` å…³é”®å­—ï¼Œè°ƒç”¨ `parse_struct_def`ã€‚
///     *   å°†è§£æå¾—åˆ°çš„ç»“æœå­˜å…¥ç›¸åº”çš„ `Map` ä¸­ã€‚
///     *   ç”¨å‰©ä½™çš„ Token ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯ã€‚
///
/// 3.  **ç»ˆæ­¢æ¡ä»¶ï¼š** å½“ä½ é‡åˆ° `EOF` Token æ—¶ï¼Œæ„å‘³ç€æ‰€æœ‰æºä»£ç éƒ½å·²å¤„ç†å®Œæ¯•ï¼Œå¾ªç¯ç»“æŸã€‚
///
/// 4.  **ç»„è£… `Program`ï¼š** æœ€åï¼Œç”¨å¡«å……å¥½çš„ `Map` åˆ›å»ºå¹¶è¿”å›æœ€ç»ˆçš„ `Program` å¯¹è±¡ã€‚
///
/// ## ğŸš€ è§è¯ä½ çš„æˆæœï¼
///
/// å®Œæˆè¿™ä¸ªä»»åŠ¡åï¼Œä½ å°±æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½å®Œå¤‡çš„ MiniMoonBit è¯­æ³•åˆ†æå™¨ï¼
/// ä½ å¯ä»¥æ‰¾ä¸€ä¸ª `examples/` ç›®å½•ä¸‹çš„ `.mbt` æ–‡ä»¶ï¼Œç„¶åè¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œäº²çœ¼çœ‹çœ‹ä½ çš„è§£æå™¨çš„å·¥ä½œæˆæœï¼š
///
/// ```bash
/// moon run main -- --file examples/nbody.mbt -stop-after=parse
/// ```
///
/// è¿™ä¸ªå‘½ä»¤ä¼šè¿è¡Œä½ çš„ç¼–è¯‘å™¨ï¼Œä½†åœ¨è¯­æ³•åˆ†æé˜¶æ®µç»“æŸåå°±åœæ­¢ï¼Œå¹¶æ‰“å°å‡ºç”Ÿæˆçš„ ASTã€‚
///
/// **å†æ¬¡ç¥è´ºä½ å®Œæˆäº†è¯­æ³•åˆ†æè¿™ä¸€é‡è¦çš„é‡Œç¨‹ç¢‘ï¼æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¿›å…¥æ›´æ¿€åŠ¨äººå¿ƒçš„è¯­ä¹‰åˆ†æé˜¶æ®µï¼**
/// ================================================================================

///|
test "Parse Program Test" {
  let code =
    #|struct Circle {
    #|  radius: Double;
    #|}
    #|
    #|struct Rectangle {
    #|  a: Double;
    #|  b: Double;
    #|  c: Double;
    #|}
    #|
    #|let pi: Double = 3.14;
    #|
    #|fn area_circle(c: Circle) -> Double {
    #|  if c.radius < 0.0 {
    #|    return 0.0;
    #|  };
    #|  pi * c.radius * c.radius;
    #|}
    #|
    #|fn area_rectangle(r: Rectangle) -> Double {
    #|   let p = (r.a + r.b + r.c) / 2.0;
    #|   let x = p - r.a;
    #|   let y = p - r.b;
    #|   let z = p - r.c;
    #|   sqrt(p * x * y * z);
    #|}
    #|
    #|fn main {
    #|  let c = Circle::{ radius: 2.0 };
    #|  let r = Rectangle::{ a: 3.0, b: 4.0, c: 5.0 };
    #|  let ac = area_circle(c);
    #|  let ar = area_rectangle(r);
    #|  if ac > ar {
    #|    print_str("Circle area is larger");
    #|  } else {
    #|    print_str("Rectangle area is larger");
    #|  };
    #|}
  let tokens = @lexer.tokenize(code)
  let program = parse(tokens)
  assert_true(program.struct_defs.length() is 2)
  assert_true(program.top_lets.length() is 1)
  assert_true(program.top_functions.length() is 3)
  assert_true(program.struct_defs.get("Circle") is Some(_))
  assert_true(program.struct_defs.get("Rectangle") is Some(_))
  assert_true(program.top_lets.get("pi") is Some(_))
  assert_true(program.top_functions.get("area_circle") is Some(_))
  assert_true(program.top_functions.get("area_rectangle") is Some(_))
  assert_true(program.top_functions.get("main") is Some(_))
}
/// ================================================================================
/// # è¡¨è¾¾å¼çš„ç»„åˆï¼šApplyExpr
///
/// æ­å–œä½ ï¼Œæˆ‘ä»¬å·²ç»å¯ä»¥è§£ææœ€åŸºç¡€çš„åŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰äº†ã€‚
/// ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¿›å…¥ä¸€ä¸ªæ›´å¹¿é˜”çš„ä¸–ç•Œï¼š**ApplyExpr**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯ ApplyExprï¼Ÿ
///
/// åœ¨æˆ‘ä»¬çš„ MiniMoonBit è¯­è¨€ä¸­ï¼Œ`ApplyExpr` æ˜¯ä¸€ä¸ªå¤åˆæ¦‚å¿µï¼Œå®ƒä»£è¡¨äº†å¯ä»¥è¢«â€œåº”ç”¨â€æˆ–â€œè®¿é—®â€çš„è¡¨è¾¾å¼ã€‚
/// å®ƒåŒ…æ‹¬äº†ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š
///
/// 1.  **å‡½æ•°è°ƒç”¨ï¼š** `my_function(arg1, arg2)`
/// 2.  **æ•°ç»„ç´¢å¼•ï¼š** `my_array[index]`
/// 3.  **ç»“æ„ä½“å­—æ®µè®¿é—®ï¼š** `my_struct.field`
/// 4.  **ä»¥åŠæœ€åŸºç¡€çš„åŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰ï¼š** `42`, `my_variable` ç­‰
///
/// å¯ä»¥çœ‹åˆ°ï¼Œ`ApplyExpr` çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰ï¼Œåé¢å¯ä»¥è·Ÿä¸Šä¸€ç³»åˆ—çš„è°ƒç”¨ã€ç´¢å¼•æˆ–å­—æ®µè®¿é—®ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç°æœ€ç®€å•çš„ ApplyExpr
///
/// åœ¨è¿™ä¸€æ­¥ï¼Œæˆ‘ä»¬å…ˆä¸å¤„ç†å¤æ‚çš„å‡½æ•°è°ƒç”¨å’Œå­—æ®µè®¿é—®ã€‚
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å®ç° `ApplyExpr` çš„æœ€ç®€å½¢å¼ï¼š**ä¸€ä¸ªåªåŒ…å« `AtomExpr` çš„ `ApplyExpr`**ã€‚
///
/// è¯·ä¿®æ”¹ `parser/apply_expr.mbt` æ–‡ä»¶ä¸­çš„ `parse_apply_expr` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  åœ¨ `parse_apply_expr` å‡½æ•°å†…éƒ¨ï¼Œé¦–å…ˆè°ƒç”¨æˆ‘ä»¬å·²ç»å®Œæˆçš„ `parse_atom_expr` æ¥è§£æä¸€ä¸ªåŸå­è¡¨è¾¾å¼ã€‚
/// 2.  æˆåŠŸè§£æå‡º `AtomExpr` åï¼Œç›´æ¥ç”¨å®ƒæ¥æ„é€ ä¸€ä¸ª `ApplyExpr` èŠ‚ç‚¹ã€‚
///    ï¼ˆæç¤ºï¼š`ApplyExpr` çš„å®šä¹‰ä¸­æœ‰ä¸€ä¸ª `AtomExpr(AtomExpr)` çš„æ„é€ å™¨ï¼‰ã€‚
/// 3.  æš‚æ—¶ä¸éœ€è¦å¤„ç† `(`, `[` æˆ– `.` ç­‰ Tokenï¼Œæˆ‘ä»¬ä¼šåœ¨åç»­çš„æŒ‘æˆ˜ä¸­é€æ­¥å®Œå–„å®ƒã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_apply_expr_test.mbt
/// ```
///
/// è¿™ä¸ªæµ‹è¯•å°†éªŒè¯ä½ çš„ `parse_apply_expr` æ˜¯å¦èƒ½æ­£ç¡®åœ°å°†ä¸€ä¸ªåŸå­è¡¨è¾¾å¼åŒ…è£…æˆ `ApplyExpr`ã€‚
///
/// **ç¥ä½ é¡ºåˆ©ï¼è¿™æ˜¯æˆ‘ä»¬å‘æ›´å¤æ‚çš„è¡¨è¾¾å¼è§£æè¿ˆå‡ºçš„é‡è¦ä¸€æ­¥ï¼**
/// ================================================================================

///|
test "Parse Simple Apply Expr Test" {
  let code =
    #|42 3.14 true false
    #|foo bar
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(a.kind is AtomExpr(atom) && atom.kind is Int(42))
  let (a, tok_view) = parse_apply_expr(tok_view)
  assert_true(a.kind is AtomExpr(atom) && atom.kind is Double(3.14))
  let (a, tok_view) = parse_apply_expr(tok_view)
  assert_true(a.kind is AtomExpr(atom) && atom.kind is Bool(true))
  let (a, tok_view) = parse_apply_expr(tok_view)
  assert_true(a.kind is AtomExpr(atom) && atom.kind is Bool(false))
  let (a, tok_view) = parse_apply_expr(tok_view)
  assert_true(a.kind is AtomExpr(atom) && atom.kind is Ident("foo"))
  let (a, _) = parse_apply_expr(tok_view)
  assert_true(a.kind is AtomExpr(atom) && atom.kind is Ident("bar"))
}
/// ================================================================================
/// # ApplyExpr çš„æ‰©å±•ï¼šæ•°ç»„ç´¢å¼•
///
/// æˆ‘ä»¬å·²ç»ä¸º `ApplyExpr` å®ç°äº†ä¸€ä¸ªæœ€åŸºç¡€çš„åŠŸèƒ½ï¼šåŒ…è£…ä¸€ä¸ª `AtomExpr`ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™ä¸ºå®ƒæ·»åŠ çœŸæ­£çš„â€œåº”ç”¨â€èƒ½åŠ›äº†ï¼Œæˆ‘ä»¬ä»**æ•°ç»„ç´¢å¼•ï¼ˆArray Accessï¼‰**å¼€å§‹ã€‚
///
/// ## æ•°ç»„ç´¢å¼•è¯­æ³•
///
/// æ•°ç»„ç´¢å¼•çš„è¯­æ³•éå¸¸ç›´è§‚ï¼š`array_variable[index_expression]`ã€‚
/// è¿™é‡Œçš„ `array_variable` æ˜¯ä¸€ä¸ª `ApplyExpr`ï¼ˆåœ¨æœ€ç®€å•çš„æƒ…å†µä¸‹ï¼Œæ˜¯ä¸€ä¸ª `AtomExpr`ï¼‰ï¼Œ
/// è€Œ `index_expression` æ˜¯ä¸€ä¸ªå®Œæ•´çš„ `Expr`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_apply_expr` ä¸­å¤„ç† `[...]`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ‰©å±• `parser/apply_expr.mbt` ä¸­çš„ `parse_apply_expr` å‡½æ•°ï¼Œ
/// ä½¿å…¶èƒ½å¤Ÿåœ¨è§£æå®Œä¸€ä¸ª `AtomExpr` åï¼Œç»§ç»­æ£€æŸ¥å¹¶è§£æç´§éšå…¶åçš„æ•°ç»„ç´¢å¼•æ“ä½œã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  **è§£æåŸºç¡€ï¼š** å‡½æ•°é¦–å…ˆåƒä¹‹å‰ä¸€æ ·ï¼Œè°ƒç”¨ `parse_atom_expr` è§£æå‡ºä¸€ä¸ªåŸºç¡€çš„ `AtomExpr`ï¼Œå¹¶å°†å…¶åŒ…è£…æˆä¸€ä¸ª `ApplyExpr`ã€‚
///
/// 2.  **å‘åçœ‹ï¼š** è§£æå®ŒåŸºç¡€è¡¨è¾¾å¼åï¼Œä¸è¦ç«‹å³è¿”å›ï¼ä½ éœ€è¦æ£€æŸ¥**ä¸‹ä¸€ä¸ª** Tokenã€‚
///
/// 3.  **åŒ¹é… `[`ï¼š**
///     *   å¦‚æœä¸‹ä¸€ä¸ª Token æ˜¯ `[`ï¼Œé‚£ä¹ˆè¯´æ˜ä¸€ä¸ªæ•°ç»„ç´¢å¼•æ“ä½œå¼€å§‹äº†ã€‚
///     *   è·³è¿‡ `[`ã€‚
///     *   è°ƒç”¨æˆ‘ä»¬å¼ºå¤§çš„ `parse_expr` å‡½æ•°æ¥è§£ææ‹¬å·å†…çš„ç´¢å¼•è¡¨è¾¾å¼ã€‚
///     *   ç¡®ä¿ç´¢å¼•è¡¨è¾¾å¼åé¢ç´§è·Ÿç€ä¸€ä¸ª `]`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   ç°åœ¨ï¼Œä½ æ‹¥æœ‰äº†â€œè¢«ç´¢å¼•çš„æ•°ç»„â€ï¼ˆå°±æ˜¯ä½ ç¬¬ä¸€æ­¥è§£æå‡ºçš„é‚£ä¸ª `ApplyExpr`ï¼‰å’Œâ€œç´¢å¼•å€¼â€ï¼ˆä½ åˆšåˆšè§£æå‡ºçš„ `Expr`ï¼‰ã€‚
///       ç”¨å®ƒä»¬æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç±»å‹ä¸º `ArrayAccess` çš„ `ApplyExpr`ã€‚è¿™ä¸ªæ–°çš„ `ApplyExpr` ä¼šå°†æ—§çš„ `ApplyExpr` åŒ…è£¹åœ¨å†…ã€‚
///
/// 4.  **ä¸åŒ¹é…ï¼š** å¦‚æœä¸‹ä¸€ä¸ª Token ä¸æ˜¯ `[`ï¼Œé‚£ä¹ˆè¯´æ˜æ²¡æœ‰æ•°ç»„ç´¢å¼•æ“ä½œï¼Œç›´æ¥è¿”å›ç¬¬ä¸€æ­¥è§£æå‡ºçš„ `ApplyExpr` å³å¯ã€‚
///
/// ## ğŸ¤” æ·±å…¥æ€è€ƒï¼šé“¾å¼è°ƒç”¨ `arr[1][2]`
///
/// è¿™ä¸ªæŒ‘æˆ˜çš„æµ‹è¯•ç”¨ä¾‹åŒ…å« `matrix[3][4]` è¿™æ ·çš„é“¾å¼ç´¢å¼•ã€‚
/// å¦‚æœä½ çš„å®ç°æ˜¯æ­£ç¡®çš„ï¼Œå®ƒåº”è¯¥èƒ½è‡ªç„¶åœ°å¤„ç†è¿™ç§æƒ…å†µã€‚
///
/// æ€è€ƒä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆä¸€ä¸ªå¾ªç¯ç»“æ„ï¼ˆ`loop` æˆ– `while`ï¼‰ä¼šæ˜¯å¤„ç†è¿™ç§é“¾å¼è°ƒç”¨çš„ä¼˜é›…æ–¹å¼ï¼Ÿ
/// å½“ä½ è§£æå®Œ `arr[1]` åï¼Œä½ åº”è¯¥å¦‚ä½•å¤„ç†ä¸‹ä¸€ä¸ª `[2]`ï¼Ÿ
/// æ–°ç”Ÿæˆçš„ `ApplyExpr` å’Œä¸Šä¸€è½®çš„ `ApplyExpr` ä¹‹é—´æ˜¯ä»€ä¹ˆå…³ç³»ï¼Ÿ
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_array_access_expr_test.mbt
/// ```
///
/// **ç¥ä½ é¡ºåˆ©ï¼ä½ æ­£åœ¨æ„å»ºä¸€ä¸ªèƒ½å¤Ÿç†è§£è¡¨è¾¾å¼ç»„åˆçš„è§£æå™¨ï¼**
/// ================================================================================

///|
test "Simple Array Access Parsing Test" {
  let code =
    #|arr[42]
    #|matrix[3][4]
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(
    a.kind is ApplyExprKind::ArrayAccess(arr_access, index_expr) &&
    index_expr.kind is ApplyExpr(app_index) &&
    app_index.kind is AtomExpr(atom_index) &&
    atom_index.kind is Int(42) &&
    arr_access.kind is ApplyExprKind::AtomExpr(atom_arr) &&
    atom_arr.kind is AtomExprKind::Ident("arr"),
  )
  let (a, _) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::ArrayAccess(arr_access2, index_expr2) &&
    index_expr2.kind is ApplyExpr(app_index2) &&
    app_index2.kind is AtomExpr(atom_index2) &&
    atom_index2.kind is Int(4) &&
    arr_access2.kind is ApplyExprKind::ArrayAccess(arr_access1, index_expr1) &&
    index_expr1.kind is ApplyExpr(app_index1) &&
    app_index1.kind is AtomExpr(atom_index1) &&
    atom_index1.kind is Int(3) &&
    arr_access1.kind is ApplyExprKind::AtomExpr(atom_arr) &&
    atom_arr.kind is AtomExprKind::Ident("matrix"),
  )
}
/// ================================================================================
/// # âš”ï¸ ç¬¬äºŒæŒ‘æˆ˜ï¼šè¯­æ³•åˆ†æå™¨ (Parser) çš„ç»“æ„ä¹‹åŠ›
///
/// æ­å–œä½ å®Œæˆäº†è¯æ³•åˆ†æï¼ä½ å·²ç»æ‹¥æœ‰äº†ç¼–è¯‘å™¨å†’é™©çš„ç¬¬ä¸€æŠŠé’¥åŒ™â€”â€”Token åºåˆ—ã€‚
/// ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™äº› Tokenï¼Œæ¥æ„å»ºä»£ç çš„â€œéª¨æ¶â€ï¼š**æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰**ã€‚
///
/// ---
///
/// ## ğŸ—ºï¸ è¯­æ³•åˆ†æï¼ˆParsingï¼‰ï¼šä»åºåˆ—åˆ°å±‚æ¬¡
///
/// è¯­æ³•åˆ†æå™¨æ˜¯ç¼–è¯‘å™¨çš„â€œå»ºç­‘å¸ˆâ€ã€‚å®ƒçš„ä½¿å‘½æ˜¯å°†çº¿æ€§çš„ Token æµï¼Œ
/// æŒ‰ç…§è¯­è¨€çš„**è¯­æ³•è§„åˆ™**ï¼Œç»„ç»‡æˆå…·æœ‰å±‚æ¬¡ç»“æ„çš„ **AST èŠ‚ç‚¹**ã€‚
///
/// **ä¾‹å¦‚ï¼Œå¯¹äºä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š**
///
/// ```
/// let total : Int = price * count + 10;
/// ```
///
/// Parser ä¸ä»…è¦çœ‹åˆ° `*` å’Œ `+` è¿ç®—ç¬¦ï¼Œè¿˜è¦ç†è§£å®ƒä»¬ä¹‹é—´çš„**ä¼˜å…ˆçº§**å’Œ**ç»“åˆæ€§**ï¼Œ
/// æœ€ç»ˆç”Ÿæˆå¦‚ä¸‹ç»“æ„ï¼ˆç®€åŒ–è¡¨ç¤ºï¼‰ï¼š
///
/// ```
/// - LetStatement (å˜é‡å£°æ˜)
///   - Name: "total"
///   - Type: Int
///   - Value:
///     - BinaryExpr (äºŒå…ƒè¿ç®— '+')
///       - Left: BinaryExpr (äºŒå…ƒè¿ç®— '*')
///         - Left: Identifier "price"
///         - Right: Identifier "count"
///       - Right: Integer 10
/// ```
///
/// **æ ¸å¿ƒç›®æ ‡ï¼š** å°†å¹³é“ºçš„ `Array[Token]` è½¬æ¢ä¸ºåµŒå¥—çš„ `Program` ç»“æ„ã€‚
///
/// ```moonbit
/// parse(tokens: Array[Token]) -> Program
/// ```
///
/// ## ğŸ›ï¸ è§£ææŠ€æœ¯ï¼šé€’å½’ä¸‹é™ï¼ˆRecursive Descentï¼‰
///
/// åœ¨æœ¬é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å°†é‡‡ç”¨æœ€ç›´è§‚ä¸”å¼ºå¤§çš„è§£ææŠ€æœ¯ä¹‹ä¸€ï¼š**é€’å½’ä¸‹é™è§£æï¼ˆRecursive Descent Parsingï¼‰**ã€‚
///
/// è¿™ç§æŠ€æœ¯çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**æ¯ä¸€ä¸ªè¯­æ³•è§„åˆ™éƒ½å¯¹åº”ä¸€ä¸ªè§£æå‡½æ•°ã€‚**
/// * è§£æ `Expr` çš„å‡½æ•°ä¼šè°ƒç”¨è§£æ `BinaryExpr` çš„å‡½æ•°ã€‚
/// * è§£æ `BinaryExpr` çš„å‡½æ•°ä¼šè°ƒç”¨è§£æ `AtomExpr` çš„å‡½æ•°ã€‚
///
/// ğŸ“Œ **æˆ‘ä»¬çš„ç­–ç•¥ï¼šè‡ªåº•å‘ä¸Šæ„å»ºï¼**
/// æˆ‘ä»¬å°†ä»æœ€åº•å±‚ã€æœ€ç®€å•çš„è¯­æ³•å•å…ƒï¼ˆä¾‹å¦‚å•ä¸ªæ•°å­—ï¼‰å¼€å§‹å®ç°ï¼Œé€æ­¥å‘ä¸Šæ„å»ºå‡ºèƒ½å¤Ÿè§£ææ•´ä¸ªç¨‹åºçš„å‡½æ•°ã€‚
///
/// ---
///
/// ## ğŸ¯ ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼šè§£æåŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰
///
/// **åŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰**æ˜¯æ‰€æœ‰å¤æ‚è¡¨è¾¾å¼çš„åŸºçŸ³ã€‚å®ƒä»¬æ˜¯ä¸èƒ½å†è¢«åˆ†è§£çš„æœ€å°è¡¨è¾¾å¼å•å…ƒã€‚
///
/// è¯·åœ¨ `parser/atom_expr.mbt` æ–‡ä»¶ä¸­å®ç° `parse_atom_expr` å‡½æ•°ã€‚
///
/// **ä½ çš„ç›®æ ‡æ˜¯è®©å®ƒèƒ½å¤ŸæˆåŠŸè§£æä»¥ä¸‹åŸºç¡€å…ƒç´ ï¼š**
///
/// * **æ•°å­—ï¼š** `42`, `3.14`
/// * **å¸ƒå°”å€¼ï¼š** `true`, `false`
/// * **æ ‡è¯†ç¬¦ï¼š** `my_variable`
/// * **å­—ç¬¦ä¸²ï¼š** `"hello world"`
///
/// **å‡½æ•°ç­¾åï¼ˆå…³é”®ï¼ï¼‰:**
///
/// ```moonbit
/// parse_atom_expr: (ArrayView[Token]) -> (AtomExpr, ArrayView[Token])
/// ```
///
/// * **è¾“å…¥ï¼š** æ¥å—å½“å‰çš„ `Token` è§†å›¾ã€‚
/// * **è¾“å‡ºï¼š** è¿”å›ä¸€ä¸ª `Tuple`ï¼ŒåŒ…å«ï¼š
///     1.  è§£æå¾—åˆ°çš„ `AtomExpr` èŠ‚ç‚¹ã€‚
///     2.  **å‰©ä½™çš„ `Token` è§†å›¾ï¼ˆå¿…é¡»è·³è¿‡å·²æ¶ˆè€—çš„ Tokenï¼ï¼‰**ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
/// æ£€æŸ¥å½“å‰ Token çš„ `kind`ã€‚å¦‚æœå®ƒåŒ¹é… `Int(_)`ã€`Double(_)`ã€`Bool(_)`ã€`Lower(_)` æˆ– `String(_)`ï¼Œåˆ™ï¼š
/// 1.  æ„é€ å¯¹åº”çš„ `AtomExpr` ç»“æ„ä½“ã€‚
/// 2.  è¿”å›ç»“æœï¼Œå¹¶å°† `Token` è§†å›¾å‘å‰æ¨è¿›ä¸€ä½ã€‚
/// 3.  å¦‚æœä¸åŒ¹é…ï¼Œåˆ™æŠ›å‡ºé”™è¯¯ï¼ˆ`raise ParseError`ï¼‰ï¼Œè¡¨ç¤ºè¯­æ³•è§£æå¤±è´¥ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// åœ¨å®Œæˆå®ç°åï¼Œä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ç²¾ç¡®è¿è¡Œä½ çš„æµ‹è¯•ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_atom_expr_test.mbt
/// ```
///
/// ---
///
/// ## ğŸ’¡ æŠ€æœ¯å®å…¸ï¼šToken è§£æ„ä¸æ¨¡å¼åŒ¹é…
///
/// åœ¨è¯­æ³•åˆ†æé˜¶æ®µï¼ŒToken çš„è§£æ„æ˜¯ä½ çš„ä¸»è¦å·¥å…·ã€‚MoonBit å¼ºå¤§çš„æ¨¡å¼åŒ¹é…èƒ½è®©ä»£ç æå…¶ç®€æ´ï¼š
///
/// æˆ‘ä»¬çš„ `Token` ç»“æ„ï¼š`struct Token { kind: TokenKind }`
///
/// **ç›´æ¥åŒ¹é… Token æ•°ç»„å’Œç»“æ„ä½“ï¼š**
///
/// è¦è§£æä¸€ä¸ª `Int` ç±»å‹çš„åŸå­è¡¨è¾¾å¼ï¼Œä½ åªéœ€è¦ä¸€æ¬¡æ¨¡å¼åŒ¹é…å°±èƒ½å®Œæˆæå–å’Œæ¨è¿› Token è§†å›¾çš„æ“ä½œï¼š
///
/// ```moonbit
/// let tokens : ArrayView[Token] = ...
///
/// match tokens {
///     // æ¨¡å¼åŒ¹é…ï¼šå¦‚æœ Token è§†å›¾ä»¥ { kind: Int(value), ... } å¼€å¤´
///     [ { kind: Int(value) }, ..rest_tokens ] => {
///         // æˆåŠŸåŒ¹é…ï¼ value æ˜¯æ•´æ•°çš„å®é™…å€¼
///         // rest_tokens æ˜¯è§†å›¾ä¸­å‰©ä¸‹çš„éƒ¨åˆ†
///         // ... æ„é€  AtomExpr å¹¶è¿”å› (AtomExpr, rest_tokens)
///     }
///     // å…¶ä»– Token ç±»å‹...
///     _ => raise ParseError("æœŸæœ› ...ï¼Œä½†é‡åˆ°æ„å¤–çš„ Token ...")
/// }
/// ```
///
/// è¿™ç§å¼ºå¤§çš„è§£æ„èƒ½åŠ›èƒ½å¤Ÿè®©ä½ è½»æ¾å¤„ç†å„ç§ Token ç±»å‹ï¼Œå¹¶ä¸”ä»£ç ç®€æ´æ˜“è¯»ã€‚
///
/// **ç¥ä½ æˆåŠŸï¼è¿ˆå‡ºæ„å»º AST çš„ç¬¬ä¸€æ­¥ï¼**
/// ================================================================================

///|
test "Simple AtomExpr Parsing Test" {
  let code =
    #|42 3.14 true false
    #|foo bar "hello minimoonbit"
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_atom_expr(tokens[:])
  assert_true(a.kind is Int(42))
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Double(3.14))
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Bool(true))
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Bool(false))
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Ident("foo"))
  let (a, tok_view) = parse_atom_expr(tok_view)
  assert_true(a.kind is Ident("bar"))
  let (a, _) = parse_atom_expr(tok_view)
  assert_true(a.kind is String("hello minimoonbit"))
}
/// ================================================================================
/// # ç»ˆææŒ‘æˆ˜ï¼šè§£æäºŒå…ƒè¡¨è¾¾å¼ä¸è¿ç®—ç¬¦ä¼˜å…ˆçº§
///
/// æ¬¢è¿æ¥åˆ° `Expr` è§£æçš„ç»ˆææŒ‘æˆ˜ï¼æˆ‘ä»¬å³å°†è¦æ”»å…‹çš„ï¼Œæ˜¯ç¼–è¯‘å™¨ä¸­æœ€ç»å…¸ã€ä¹Ÿæœ€å…·æŒ‘æˆ˜æ€§çš„é—®é¢˜ä¹‹ä¸€ï¼š
/// **å¸¦æœ‰ä¼˜å…ˆçº§çš„äºŒå…ƒè¡¨è¾¾å¼è§£æï¼ˆBinary Expression Parsing with Precedenceï¼‰**ã€‚
///
/// âš ï¸ **é«˜èƒ½é¢„è­¦ï¼š** è¿™éƒ¨åˆ†å†…å®¹çš„å®ç°éš¾åº¦è¾ƒé«˜ï¼Œå…¶ç®—æ³•å¤æ‚åº¦ä¸äºšäºä¸€é“ LeetCode çš„ä¸­ç­‰åä¸Šéš¾åº¦çš„é¢˜ç›®ã€‚
/// è¯·åšå¥½å……åˆ†çš„å¿ƒç†å‡†å¤‡ï¼Œè¿™å°†æ˜¯ä¸€æ¬¡ç»ä½³çš„ç®—æ³•æ€ç»´é”»ç‚¼ï¼
///
/// ## ğŸ¤” æŒ‘æˆ˜çš„æ ¸å¿ƒï¼šè¿ç®—ç¬¦ä¼˜å…ˆçº§
///
/// ä¸ºä»€ä¹ˆè¿™å¾ˆéš¾ï¼Ÿæ€è€ƒä¸€ä¸‹è¡¨è¾¾å¼ `1 + 2 * 3`ã€‚
///
/// æˆ‘ä»¬äººç±»çŸ¥é“åº”è¯¥å…ˆç®— `2 * 3`ï¼Œå› ä¸º `*` çš„ä¼˜å…ˆçº§é«˜äº `+`ã€‚
/// ä½†æˆ‘ä»¬çš„è§£æå™¨æ˜¯è‡ªå·¦å‘å³è¯»å– Token çš„ã€‚å½“å®ƒçœ‹åˆ° `1 + 2` æ—¶ï¼Œå®ƒå¦‚ä½•çŸ¥é“ä¸èƒ½ç«‹åˆ»å°†å®ƒä»¬ç»„åˆï¼Œ
/// è€Œæ˜¯è¦â€œç­‰å¾…â€åé¢çš„ `*` è¿ç®—å…ˆå®Œæˆå‘¢ï¼Ÿ
///
/// è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦è§£å†³çš„æ ¸å¿ƒé—®é¢˜ï¼šå®ç°ä¸€ä¸ªèƒ½å¤Ÿç†è§£å¹¶æ­£ç¡®å¤„ç†ä¸åŒè¿ç®—ç¬¦ä¼˜å…ˆçº§çš„è§£æç®—æ³•ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_expr` ä¸­å®ç°å®Œæ•´çš„äºŒå…ƒè¡¨è¾¾å¼è§£æ
///
/// ç°åœ¨ï¼Œè¯·å†æ¬¡å›åˆ° `parser/expr.mbt`ï¼Œå‡†å¤‡å¯¹ `parse_expr` å‡½æ•°è¿›è¡Œä¸€æ¬¡â€œå¤§æ‰‹æœ¯â€ã€‚
///
/// **ğŸ’¡ æ ¸å¿ƒæ€è·¯æç¤ºï¼šåŒæ ˆ
///
/// 1.  **ä¸¤ä¸ªæ ˆï¼š** ä½ å¯ä»¥è€ƒè™‘ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼šä¸€ä¸ªç”¨äºå­˜æ”¾**å¾…å¤„ç†çš„è¿ç®—ç¬¦ï¼ˆOperator Stackï¼‰**ï¼Œå¦ä¸€ä¸ªç”¨äºå­˜æ”¾**å·²ç»è§£æå‡ºçš„è¡¨è¾¾å¼ï¼ˆExpression Stackï¼‰**ã€‚
///
/// 2.  **å¤„ç†æµç¨‹ï¼š**
///     *   å½“ä½ è§£æå‡ºä¸€ä¸ª `ApplyExpr`ï¼ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºä¸€ä¸ªæ“ä½œæ•°ï¼‰æ—¶ï¼Œå°†å®ƒå‹å…¥è¡¨è¾¾å¼æ ˆã€‚
///     *   å½“ä½ é‡åˆ°ä¸€ä¸ªè¿ç®—ç¬¦æ—¶ï¼Œä½ éœ€è¦å°†å®ƒä¸è¿ç®—ç¬¦æ ˆé¡¶çš„è¿ç®—ç¬¦è¿›è¡Œ**ä¼˜å…ˆçº§æ¯”è¾ƒ**ã€‚
///         *   å¦‚æœå½“å‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§**é«˜äº**æ ˆé¡¶è¿ç®—ç¬¦ï¼Œè¯´æ˜å®ƒå¯ä»¥â€œæŠ¢å…ˆâ€æ‰§è¡Œï¼Œå°†å®ƒå‹å…¥è¿ç®—ç¬¦æ ˆã€‚
///         *   å¦‚æœå½“å‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§**ä½äºæˆ–ç­‰äº**æ ˆé¡¶è¿ç®—ç¬¦ï¼Œè¯´æ˜æ ˆé¡¶çš„è¿ç®—éœ€è¦å…ˆè¿›è¡Œã€‚
///             æ­¤æ—¶ï¼Œä»è¿ç®—ç¬¦æ ˆå¼¹å‡ºä¸€ä¸ªè¿ç®—ç¬¦ï¼Œä»è¡¨è¾¾å¼æ ˆå¼¹å‡ºä¸¤ä¸ªè¡¨è¾¾å¼ï¼Œå°†å®ƒä»¬ç»„åˆæˆä¸€ä¸ªæ–°çš„ `BinaryExpr`ï¼Œ
///             ç„¶åå°†ç»“æœå‹å›è¡¨è¾¾å¼æ ˆã€‚é‡å¤æ­¤è¿‡ç¨‹ï¼Œç›´åˆ°å½“å‰è¿ç®—ç¬¦å¯ä»¥è¢«å‹å…¥æ ˆä¸­ã€‚
///
/// 3.  **æ”¶å°¾å·¥ä½œï¼š** å½“æ‰€æœ‰ Token éƒ½å¤„ç†å®Œæ¯•åï¼Œæ¸…ç©ºè¿ç®—ç¬¦æ ˆä¸­çš„æ‰€æœ‰å‰©ä½™è¿ç®—ç¬¦ï¼Œå®Œæˆæœ€åçš„ç»„åˆã€‚
///
/// è¿™åªæ˜¯ä¸€ä¸ªé«˜å±‚æ¬¡çš„æ€è·¯æ¦‚è¿°ã€‚ä½ éœ€è¦ä»”ç»†æ€è€ƒå…¶ä¸­çš„ç»†èŠ‚ï¼Œä¾‹å¦‚å¾ªç¯æ¡ä»¶ã€æ ˆçš„æ¸…ç©ºæ—¶æœºä»¥åŠå¦‚ä½•å¤„ç†æ‹¬å·ï¼ˆå°½ç®¡æœ¬æµ‹è¯•æš‚ä¸æ¶‰åŠï¼‰ã€‚
///
/// **precedence å‡½æ•°ï¼š**
///
/// ä¸ºäº†å¸®åŠ©ä½ ï¼Œ`parser/expr.mbt` ä¸­å·²ç»ä¸ºä½ æä¾›äº†ä¸€ä¸ª `precedence(op: BinaryOp) -> Int` çš„è¾…åŠ©å‡½æ•°ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨å®ƒæ¥è·å–è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆè¿™ä¸ªè‰°å·¨çš„ä»»åŠ¡åï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„æˆæœï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_binary_expr_test.mbt
/// ```
///
/// **ç¥ä½ æŒ‘æˆ˜æˆåŠŸï¼æ”»å…‹äº†å®ƒï¼Œä½ å¯¹è¡¨è¾¾å¼è§£æçš„ç†è§£å°†è¾¾åˆ°ä¸€ä¸ªæ–°çš„é«˜åº¦ï¼**
/// ================================================================================

///|
test "Binary Expr Parsing Test" {
  let code =
    #|1 + 2 * 3 ;
    #|4 * 5 - 6 / 2 ;
    #|a && b || c && d ;
    #|x << 2 + y >> 3 ;
    #|p > q != r < s
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = parse_expr(tokens[:])
  assert_true(
    e.kind is BinaryExpr(Add, left, right) &&
    left.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(1) &&
    right.kind is BinaryExpr(Mul, left, right) &&
    left.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(2) &&
    right.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(3),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(Sub, left1, right1) &&
    left1.kind is BinaryExpr(Mul, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(4) &&
    right2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(5) &&
    right1.kind is BinaryExpr(Div, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(6) &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(2),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(Or, left1, right1) &&
    left1.kind is BinaryExpr(And, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("a") &&
    right2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("b") &&
    right1.kind is BinaryExpr(And, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("c") &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("d"),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(ShiftRight, left1, right1) &&
    left1.kind is BinaryExpr(ShiftLeft, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("x") &&
    right2.kind is BinaryExpr(Add, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(2) &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("y") &&
    right1.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(3),
  )
  let (e, _) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is BinaryExpr(NE, left1, right1) &&
    left1.kind is BinaryExpr(GT, left2, right2) &&
    left2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("p") &&
    right2.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("q") &&
    right1.kind is BinaryExpr(LT, left3, right3) &&
    left3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("r") &&
    right3.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("s"),
  )
}
/// ================================================================================
/// # ApplyExpr çš„å†æ‰©å±•ï¼šå‡½æ•°è°ƒç”¨
///
/// æˆ‘ä»¬å·²ç»æˆåŠŸåœ°ä¸º `ApplyExpr` æ·»åŠ äº†æ•°ç»„ç´¢å¼•çš„åŠŸèƒ½ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å®Œæˆå®ƒçš„æœ€åä¸€å—æ‹¼å›¾ï¼š
/// **å‡½æ•°è°ƒç”¨ï¼ˆFunction Callsï¼‰**ã€‚
///
/// ## å‡½æ•°è°ƒç”¨è¯­æ³•
///
/// å‡½æ•°è°ƒç”¨çš„è¯­æ³•æ˜¯ `function_name(argument1, argument2, ...)`ã€‚
/// è¿™é‡Œçš„ `function_name` æ˜¯ä¸€ä¸ª `ApplyExpr`ï¼Œè€Œæ‹¬å·å†…çš„å‚æ•°åˆ—è¡¨æ˜¯ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„ `Expr` åˆ—è¡¨ã€‚
///
/// ä½ ä¼šå‘ç°ï¼Œè¿™ä¸ªå‚æ•°åˆ—è¡¨çš„ç»“æ„ä¸æˆ‘ä»¬ä¹‹å‰è§£æè¿‡çš„å…ƒç»„ï¼ˆTupleï¼‰å’Œæ•°ç»„å­—é¢é‡ï¼ˆArray Literalï¼‰å‡ ä¹å®Œå…¨ä¸€æ ·ï¼
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_apply_expr` ä¸­å¤„ç† `(...)`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯ç»§ç»­æ‰©å±• `parser/apply_expr.mbt` ä¸­çš„ `parse_apply_expr` å‡½æ•°ï¼Œ
/// ä½¿å…¶åœ¨è§£æå®Œä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼åï¼Œèƒ½å¤Ÿç»§ç»­æ£€æŸ¥å¹¶è§£æå‡½æ•°è°ƒç”¨ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è¿™éƒ¨åˆ†é€»è¾‘ä¸è§£ææ•°ç»„ç´¢å¼•éå¸¸ç›¸ä¼¼ï¼Œå¯ä»¥æ”¾åœ¨åŒä¸€ä¸ªå¾ªç¯ä¸­å¤„ç†ã€‚
///
/// 1.  **è§£æåŸºç¡€ï¼š** å‡½æ•°é¦–å…ˆè§£æå‡ºä¸€ä¸ªåŸºç¡€çš„ `ApplyExpr`ã€‚
///
/// 2.  **å¾ªç¯å‘åçœ‹ï¼š** è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œæ£€æŸ¥åŸºç¡€è¡¨è¾¾å¼åé¢çš„ Tokenã€‚
///
/// 3.  **åŒ¹é… `(`ï¼š**
///     *   å¦‚æœä¸‹ä¸€ä¸ª Token æ˜¯ `(`ï¼Œé‚£ä¹ˆè¯´æ˜ä¸€ä¸ªå‡½æ•°è°ƒç”¨å¼€å§‹äº†ã€‚
///     *   è·³è¿‡ `(`ã€‚
///     *   æ¥ä¸‹æ¥ï¼Œä½ éœ€è¦è§£ææ‹¬å·å†…çš„å‚æ•°åˆ—è¡¨ã€‚è¿™æ˜¯ä¸€ä¸ªç”±é€—å·åˆ†éš”çš„ `Expr` åˆ—è¡¨ã€‚
///       è¿™ä¸ªé€»è¾‘å’Œè§£æå…ƒç»„/æ•°ç»„çš„å†…éƒ¨éå¸¸ç›¸ä¼¼ï¼Œä½ å¯ä»¥è€ƒè™‘å°†è¿™éƒ¨åˆ†é€»è¾‘æŠ½è±¡æˆä¸€ä¸ªå¯å¤ç”¨çš„è¾…åŠ©å‡½æ•°ï¼Œ
///       ä¾‹å¦‚ `parse_expr_list`ï¼Œå®ƒæ¥æ”¶ Tokenï¼Œè¿”å›ä¸€ä¸ª `Array[Expr]` å’Œå‰©ä½™çš„ Tokenã€‚
///     *   ç¡®ä¿å‚æ•°åˆ—è¡¨åé¢ç´§è·Ÿç€ä¸€ä¸ª `)`ï¼Œå¹¶è·³è¿‡å®ƒã€‚
///     *   ç°åœ¨ï¼Œä½ æ‹¥æœ‰äº†â€œè¢«è°ƒç”¨çš„å‡½æ•°â€ï¼ˆ`callee`ï¼‰å’Œâ€œå‚æ•°åˆ—è¡¨â€ï¼ˆ`args`ï¼‰ã€‚
///       ç”¨å®ƒä»¬æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç±»å‹ä¸º `Call` çš„ `ApplyExpr`ã€‚
///
/// 4.  **ç»“åˆä¸å¾ªç¯ï¼š**
///     *   è¿™ä¸ªæ–°çš„ `Call` è¡¨è¾¾å¼ä¼šåŒ…è£¹ä½æ—§çš„ `ApplyExpr`ã€‚åœ¨ä¸‹ä¸€æ¬¡å¾ªç¯ä¸­ï¼Œè¿™ä¸ªæ–°çš„ `ApplyExpr`
///       åˆå¯ä»¥ä½œä¸ºæ›´å¤–å±‚è°ƒç”¨ï¼ˆä¾‹å¦‚ `foo(1)(2)`ï¼‰æˆ–è€…æ•°ç»„ç´¢å¼•ï¼ˆä¾‹å¦‚ `foo(1)[2]`ï¼‰çš„åŸºç¡€ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_call_expr_test.mbt
/// ```
///
/// **ç¥è´ºä½ ï¼å®Œæˆè¿™ä¸€æ­¥åï¼Œä½ çš„ `ApplyExpr` è§£æå™¨å°±åŠŸèƒ½å®Œå¤‡äº†ï¼Œèƒ½å¤Ÿå¤„ç†å¤æ‚çš„è¡¨è¾¾å¼ç»„åˆï¼**
/// ================================================================================

///|
test "Simple Call Expr Parsing Test" {
  let code =
    #|foo()
    #|bar(42, true)
    #|qux(1 + 3)
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(
    a.kind is ApplyExprKind::Call(callee, args) &&
    args is [] &&
    callee.kind is AtomExpr(callee_atom) &&
    callee_atom.kind is AtomExprKind::Ident("foo"),
  )
  let (a, tok_view) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::Call(callee, args) &&
    args is [arg1, arg2] &&
    arg1.kind is ApplyExpr(arg1_app) &&
    arg1_app.kind is AtomExpr(arg1_atom) &&
    arg1_atom.kind is AtomExprKind::Int(42) &&
    arg2.kind is ApplyExpr(arg2_app) &&
    arg2_app.kind is AtomExpr(arg2_atom) &&
    arg2_atom.kind is AtomExprKind::Bool(true) &&
    callee.kind is AtomExpr(callee_atom) &&
    callee_atom.kind is AtomExprKind::Ident("bar"),
  )
  let (a, _) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::Call(callee, args) &&
    args is [arg1] &&
    arg1.kind is BinaryExpr(Add, left, right) &&
    left.kind is ApplyExpr(left_app) &&
    left_app.kind is AtomExpr(left_atom) &&
    left_atom.kind is AtomExprKind::Int(1) &&
    right.kind is ApplyExpr(right_app) &&
    right_app.kind is AtomExpr(right_atom) &&
    right_atom.kind is AtomExprKind::Int(3) &&
    callee.kind is AtomExpr(callee_atom) &&
    callee_atom.kind is AtomExprKind::Ident("qux"),
  )
}
/// ================================================================================
/// # è¡¨è¾¾å¼çš„å±‚çº§ï¼šExpr
///
/// æˆ‘ä»¬å·²ç»æˆåŠŸåœ°å°† `AtomExpr` åŒ…è£…è¿›äº† `ApplyExpr`ã€‚ç°åœ¨ï¼Œæ˜¯æ—¶å€™å¼•å…¥æˆ‘ä»¬è¯­æ³•æ ‘ä¸­
/// æœ€æ ¸å¿ƒã€æœ€é€šç”¨çš„èŠ‚ç‚¹ä¹‹ä¸€ï¼š**`Expr`**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯ Exprï¼Ÿ
///
/// `Expr`ï¼ˆè¡¨è¾¾å¼ï¼‰æ˜¯ MiniMoonBit ä¸­èƒ½å¤Ÿäº§ç”Ÿä¸€ä¸ªå€¼çš„å‡ ä¹æ‰€æœ‰ä»£ç æ„é€ çš„ç»Ÿç§°ã€‚
/// å®ƒæ˜¯æˆ‘ä»¬è¯­æ³•è§„åˆ™çš„â€œç‘å£«å†›åˆ€â€ï¼Œæ¶µç›–äº†ä»æœ€ç®€å•çš„æ•°å­—åˆ°æœ€å¤æ‚çš„é€»è¾‘å—çš„æ‰€æœ‰å†…å®¹ã€‚
///
/// `Expr` ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ç§å½¢å¼ï¼š
///
/// 1.  **ä¸€å…ƒæ“ä½œï¼š** `-x` (å–å), `!b` (é€»è¾‘é)
/// 2.  **äºŒå…ƒæ“ä½œï¼š** `a + b`, `x > y`
/// 3.  **If è¡¨è¾¾å¼ï¼š** `if condition { ... } else { ... }`
/// 4.  **Block è¡¨è¾¾å¼ï¼š** `{ let a = 1; a + 1 }`
/// 5.  **ä»¥åŠæˆ‘ä»¬åˆšåˆšå®ç°çš„ `ApplyExpr`ï¼š** å®ƒä½œä¸ºæ‰€æœ‰å¤æ‚è¡¨è¾¾å¼çš„åŸºç¡€ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç°æœ€ç®€å•çš„ Expr
///
/// åœ¨è¿™ä¸ªæŒ‘æˆ˜ä¸­ï¼Œæˆ‘ä»¬å°†é‡‡ç”¨â€œç”±ç®€å…¥ç¹â€çš„ç­–ç•¥ã€‚æˆ‘ä»¬é¦–å…ˆè¦è®© `parse_expr` å‡½æ•°
/// èƒ½å¤Ÿå¤„ç†æœ€åŸºç¡€çš„æƒ…å†µï¼šä¸€ä¸ªå•ç‹¬çš„ `ApplyExpr`ã€‚
///
/// è¯·ä¿®æ”¹ `parser/expr.mbt` æ–‡ä»¶ä¸­çš„ `parse_expr` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  åœ¨ `parse_expr` å‡½æ•°å†…éƒ¨ï¼Œç›´æ¥è°ƒç”¨æˆ‘ä»¬å·²ç»å®Œæˆçš„ `parse_apply_expr`ã€‚
/// 2.  æˆåŠŸè§£æå‡º `ApplyExpr` åï¼Œç”¨å®ƒæ¥æ„é€ ä¸€ä¸ª `Expr` èŠ‚ç‚¹ã€‚
///    ï¼ˆæç¤ºï¼š`Expr` çš„å®šä¹‰ä¸­æœ‰ä¸€ä¸ª `ApplyExpr(ApplyExpr)` çš„æ„é€ å™¨ï¼‰ã€‚
/// 3.  æš‚æ—¶ä¸éœ€è¦è€ƒè™‘ä»»ä½•äºŒå…ƒæ“ä½œã€ä¸€å…ƒæ“ä½œæˆ–å…¶ä»–å¤æ‚æƒ…å†µã€‚æˆ‘ä»¬åªå¤„ç†ä¸€ä¸ª `ApplyExpr` å°±ç›´æ¥è¿”å›ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_expr_test.mbt
/// ```
///
/// è¿™ä¸ªæµ‹è¯•å°†ç¡®ä¿ä½ çš„ `parse_expr` èƒ½å¤Ÿæ­£ç¡®åœ°å°†ä¸€ä¸ª `ApplyExpr` åŒ…è£…æˆ `Expr`ã€‚
///
/// **ç¥ä½ é¡ºåˆ©ï¼æˆ‘ä»¬æ­£åœ¨é€æ­¥æ„å»ºèµ·èƒ½å¤Ÿç†è§£å¤æ‚ä»£ç é€»è¾‘çš„è§£æå™¨ï¼**
/// ================================================================================

///|
test "Simple Expr Parsing Test" {
  let code =
    #|42 3.14 true false
    #|a
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = parse_expr(tokens[:])
  assert_true(
    e.kind is ApplyExpr(a) && a.kind is AtomExpr(atom) && atom.kind is Int(42),
  )
  let (e, tok_view) = parse_expr(tok_view)
  assert_true(
    e.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Double(3.14),
  )
  let (e, tok_view) = parse_expr(tok_view)
  assert_true(
    e.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Bool(true),
  )
  let (e, tok_view) = parse_expr(tok_view)
  assert_true(
    e.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Bool(false),
  )
  let (e, _) = parse_expr(tok_view)
  assert_true(
    e.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("a"),
  )
}
/// ================================================================================
/// # ApplyExpr çš„ç»ˆç« ï¼šç»“æ„ä½“å­—æ®µè®¿é—®
///
/// æˆ‘ä»¬å·²ç»å®Œæˆäº† `ApplyExpr` çš„å¤§éƒ¨åˆ†åŠŸèƒ½ï¼Œç°åœ¨åªå‰©ä¸‹æœ€åä¸€ç§ï¼Œä¹Ÿæ˜¯éå¸¸é‡è¦çš„ä¸€ç§ï¼š
/// **ç»“æ„ä½“å­—æ®µè®¿é—®ï¼ˆStruct Field Accessï¼‰**ã€‚
///
/// ## å­—æ®µè®¿é—®è¯­æ³•
///
/// å­—æ®µè®¿é—®çš„è¯­æ³•æ˜¯é€šè¿‡ç‚¹å· `.` æ¥è®¿é—®ä¸€ä¸ªç»“æ„ä½“å®ä¾‹çš„æˆå‘˜ï¼š`my_struct.field_name`ã€‚
/// è¿™é‡Œçš„ `my_struct` æ˜¯ä¸€ä¸ª `ApplyExpr`ï¼Œè€Œ `field_name` æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼ˆ`Lower` Tokenï¼‰ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_apply_expr` ä¸­å¤„ç† `.`
///
/// æˆ‘ä»¬çš„ç›®æ ‡æ˜¯æœ€ç»ˆå®Œå–„ `parser/apply_expr.mbt` ä¸­çš„ `parse_apply_expr` å‡½æ•°ï¼Œ
/// ä½¿å…¶èƒ½å¤Ÿå¤„ç†å­—æ®µè®¿é—®ï¼Œå¹¶èƒ½å¤Ÿä¸æ•°ç»„ç´¢å¼•ã€å‡½æ•°è°ƒç”¨ç­‰æ— ç¼è¡”æ¥ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è¿™éƒ¨åˆ†é€»è¾‘å¯ä»¥å®Œç¾åœ°èå…¥æˆ‘ä»¬ä¸ºå¤„ç†æ•°ç»„ç´¢å¼•å’Œå‡½æ•°è°ƒç”¨è€Œæ„å»ºçš„å¾ªç¯ä¸­ã€‚
///
/// 1.  **è§£æåŸºç¡€ï¼š** å‡½æ•°é¦–å…ˆè§£æå‡ºä¸€ä¸ªåŸºç¡€çš„ `ApplyExpr`ã€‚
///
/// 2.  **å¾ªç¯å‘åçœ‹ï¼š** åœ¨å¾ªç¯ä¸­ï¼Œæ£€æŸ¥åŸºç¡€è¡¨è¾¾å¼åé¢çš„ Tokenã€‚
///
/// 3.  **åŒ¹é… `.`ï¼š**
///     *   å¦‚æœä¸‹ä¸€ä¸ª Token æ˜¯ `.`ï¼Œé‚£ä¹ˆè¯´æ˜ä¸€ä¸ªå­—æ®µè®¿é—®å¼€å§‹äº†ã€‚
///     *   è·³è¿‡ `.`ã€‚
///     *   **ç‰¹åˆ«æ³¨æ„ï¼š** å­—æ®µåå¿…é¡»æ˜¯ä¸€ä¸ªå°å†™å­—æ¯å¼€å¤´çš„æ ‡è¯†ç¬¦ã€‚æ‰€ä»¥ï¼Œä½ éœ€è¦æ£€æŸ¥ç´§è·Ÿåœ¨ `.` åé¢çš„ Token æ˜¯å¦ä¸º `TokenKind::Lower`ã€‚
///     *   å¦‚æœåŒ¹é…æˆåŠŸï¼Œæå–å‡ºå­—æ®µåï¼ˆä¸€ä¸ª `String`ï¼‰ã€‚
///     *   ç°åœ¨ï¼Œä½ æ‹¥æœ‰äº†â€œè¢«è®¿é—®çš„å¯¹è±¡â€ï¼ˆ`object`ï¼‰å’Œâ€œå­—æ®µåâ€ï¼ˆ`field`ï¼‰ã€‚
///       ç”¨å®ƒä»¬æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç±»å‹ä¸º `FieldAccess` çš„ `ApplyExpr`ã€‚
///
/// 4.  **é“¾å¼è®¿é—®ï¼š**
///     *   è¿™ä¸ªæ–°çš„ `FieldAccess` è¡¨è¾¾å¼ä¼šåŒ…è£¹ä½æ—§çš„ `ApplyExpr`ã€‚åœ¨ä¸‹ä¸€æ¬¡å¾ªç¯ä¸­ï¼Œå®ƒåˆå¯ä»¥ä½œä¸º
///       `obj.field1.field2` æˆ– `obj.field[0]` æˆ– `obj.method()` ç­‰æ›´å¤æ‚é“¾å¼æ“ä½œçš„åŸºç¡€ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_field_access_expr_test.mbt
/// ```
///
/// **ç¥è´ºä½ ï¼å®Œæˆè¿™ä¸€æ­¥åï¼Œä½ çš„ `parse_apply_expr` å‡½æ•°å°±å½»åº•å®Œå·¥äº†ã€‚ä½ å·²ç»æ„å»ºäº†ä¸€ä¸ªèƒ½å¤Ÿè§£æ MiniMoonBit ä¸­æ‰€æœ‰å¤æ‚è¡¨è¾¾å¼ç»„åˆçš„å¼ºå¤§è§£æå™¨ï¼**
/// ================================================================================

///|
test "Simple Field Access Parsing Test" {
  let code =
    #|obj.field
    #|obj.nested.field
  let tokens = @lexer.tokenize(code)
  let (a, tok_view) = parse_apply_expr(tokens[:])
  assert_true(
    a.kind is ApplyExprKind::FieldAccess(obj_access, field) &&
    field == "field" &&
    obj_access.kind is ApplyExprKind::AtomExpr(atom_obj) &&
    atom_obj.kind is AtomExprKind::Ident("obj"),
  )
  let (a, _) = parse_apply_expr(tok_view)
  assert_true(
    a.kind is ApplyExprKind::FieldAccess(nested_access, field2) &&
    field2 == "field" &&
    nested_access.kind is ApplyExprKind::FieldAccess(obj_access2, field1) &&
    field1 == "nested" &&
    obj_access2.kind is ApplyExprKind::AtomExpr(atom_obj2) &&
    atom_obj2.kind is AtomExprKind::Ident("obj"),
  )
}
/// ================================================================================
/// # è¯­å¥çš„â€œæ€»æŒ‡æŒ¥â€ï¼šè§£æ Stmt
///
/// æˆ‘ä»¬å·²ç»é›†é½äº† `let`ã€`let mut` å’Œ `assign` ç­‰è¯­å¥çš„è§£æå™¨ã€‚
/// ç°åœ¨ï¼Œæ˜¯æ—¶å€™åˆ›å»ºä¸€ä¸ªâ€œæ€»æŒ‡æŒ¥â€â€”â€”`parse_stmt` å‡½æ•°ï¼Œæ¥ç»Ÿä¸€è°ƒåº¦å®ƒä»¬äº†ã€‚
///
/// ## Stmt çš„æ„æˆ
///
/// ä¸€ä¸ªé€šç”¨çš„è¯­å¥ï¼ˆ`Stmt`ï¼‰å¯ä»¥æ˜¯å¤šç§å…·ä½“è¯­å¥ä¸­çš„ä»»ä½•ä¸€ç§ï¼š
///
/// ```
/// stmt ::= let_stmt | let_mut_stmt | assign_stmt | expr_stmt
/// ```
///
/// `expr_stmt` æŒ‡çš„æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼æœ¬èº«ä¹Ÿå¯ä»¥ä½œä¸ºä¸€æ¡è¯­å¥ï¼Œä¾‹å¦‚ä¸€ä¸ªå‡½æ•°è°ƒç”¨ `println("hello");`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/stmt.mbt` ä¸­å®ç° `parse_stmt` å‡½æ•°ã€‚
/// è¿™ä¸ªå‡½æ•°éœ€è¦æ ¹æ®å¼€å¤´çš„ Token æ¥åˆ¤æ–­åº”è¯¥è°ƒç”¨å“ªä¸ªå…·ä½“çš„è¯­å¥è§£æå™¨ã€‚
///
/// *   å¦‚æœå¼€å¤´æ˜¯ `let` å…³é”®å­—ï¼Œä½ éœ€è¦è¿›ä¸€æ­¥åˆ¤æ–­ç¬¬äºŒä¸ª Token æ˜¯ä¸æ˜¯ `mut`ï¼Œç„¶ååˆ†åˆ«è°ƒç”¨ `parse_let_stmt` æˆ– `parse_let_mut_stmt`ã€‚
///
/// ### ğŸ¤” ä¸€ä¸ªæ£˜æ‰‹çš„é—®é¢˜ï¼š`assign_stmt` vs `expr_stmt`
///
/// æœ€å¤§çš„æŒ‘æˆ˜åœ¨äºåŒºåˆ† `assign_stmt` å’Œ `expr_stmt`ã€‚
///
/// *   `x = 1;` æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ã€‚
/// *   `x(1);` æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è¯­å¥ã€‚
///
/// å®ƒä»¬éƒ½ä»¥ä¸€ä¸ªæ ‡è¯†ç¬¦ `x` å¼€å¤´ï¼æˆ‘ä»¬æ— æ³•ä»…å‡­ç¬¬ä¸€ä¸ª Token å°±åšå‡ºåˆ¤æ–­ã€‚
/// è¿™ç§â€œæ— æ³•ä»…é€šè¿‡å‘å‰çœ‹ä¸€ä¸ª Token æ¥ç¡®å®šè¯­æ³•ç»“æ„â€çš„é—®é¢˜ï¼Œåœ¨è§£æå™¨ä¸­è¢«ç§°ä¸º **LL(1) å†²çª**ã€‚
///
/// **è§£å†³æ€è·¯ï¼ˆé¢„æµ‹ä¸å›æº¯ï¼‰ï¼š**
///
/// æˆ‘ä»¬å¯ä»¥é‡‡ç”¨ä¸€ç§â€œè¯•æ¢-å›æº¯â€çš„ç­–ç•¥ï¼š
///
/// 1.  **å¤§èƒ†é¢„æµ‹ï¼š** å½“è¯­å¥ä»¥ä¸€ä¸ªæ ‡è¯†ç¬¦å¼€å¤´æ—¶ï¼Œæˆ‘ä»¬**ä¹è§‚åœ°**å‡è®¾å®ƒå¯èƒ½æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å…ˆå°è¯•è°ƒç”¨ `parse_left_value` æ¥è§£æä¸€ä¸ªå·¦å€¼ã€‚
///
/// 2.  **éªŒè¯é¢„æµ‹ï¼š** è§£æå®Œå·¦å€¼åï¼Œæ£€æŸ¥ç´§è·Ÿå…¶åçš„ Tokenï¼š
///     *   å¦‚æœæ˜¯ä¸€ä¸ª**èµ‹å€¼æ“ä½œç¬¦**ï¼ˆ`=`ã€`+=` ç­‰ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„é¢„æµ‹æ˜¯æ­£ç¡®çš„ï¼è¿™ç¡®å®æ˜¯ä¸€ä¸ª `assign_stmt`ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬ç»§ç»­è°ƒç”¨ `parse_assign_stmt` æ¥å®Œæˆå‰©ä½™éƒ¨åˆ†çš„è§£æã€‚
///     *   å¦‚æœ**ä¸æ˜¯**èµ‹å€¼æ“ä½œç¬¦ï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„é¢„æµ‹å¤±è´¥äº†ã€‚è¿™æ„å‘³ç€å®ƒä¸æ˜¯ä¸€ä¸ªèµ‹å€¼è¯­å¥ï¼Œè€Œåº”è¯¥æ˜¯ä¸€ä¸ª `expr_stmt`ã€‚
///
/// 3.  **å›æº¯ï¼š** é¢„æµ‹å¤±è´¥åï¼Œæˆ‘ä»¬éœ€è¦â€œå›æº¯â€ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬è¦**ä¸¢å¼ƒ**åˆšåˆš `parse_left_value` çš„è§£æç»“æœï¼Œå°† Token è§†å›¾**é€€å›**åˆ°æœ€åˆçš„ä½ç½®ï¼Œç„¶åè°ƒç”¨ `parse_expr` å°†æ•´æ¡è¯­å¥ä½œä¸º `expr_stmt` æ¥é‡æ–°è§£æã€‚
///
/// è¿™ç§â€œé¢„æµ‹-éªŒè¯-å›æº¯â€çš„æœºåˆ¶æ˜¯æ‰‹åŠ¨ç¼–å†™é€’å½’ä¸‹é™è§£æå™¨æ—¶å¤„ç†è¯­æ³•æ­§ä¹‰çš„å¸¸ç”¨æŠ€å·§ã€‚
///
/// åŠ æ²¹ï¼Œè¿™æ˜¯æˆ‘ä»¬è§£æå™¨éƒ¨åˆ†çš„æœ€åä¸€ä¸ªæ ¸å¿ƒæŒ‘æˆ˜ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_simple_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Stmt Parsing Test" {
  let code =
    #|let x = 5;
    #|let mut y = 10;
    #|y = y + x;
    #|y();
    #|println(123);
    #|print_int(foo(1, 2));
    #|foo.bar[3][4] = 42;
    #|return 0;
    #|return ;
  let tokens = @lexer.tokenize(code)
  let (s, tok_view) = parse_stmt(tokens[:])
  assert_true(s.kind is LetStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is LetMutStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is AssignStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is ExprStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is ExprStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is ExprStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is AssignStmt(_))
  let (s, tok_view) = parse_stmt(tok_view)
  assert_true(s.kind is ReturnStmt(_))
  let (s, _) = parse_stmt(tok_view)
  assert_true(s.kind is ReturnStmt(_))
}
/// ================================================================================
/// # è¡¨è¾¾å¼çš„æ‰©å±•ï¼šä¸€å…ƒæ“ä½œ
///
/// æ­å–œä½ ï¼æˆ‘ä»¬å·²ç»å®ç°äº† `parse_expr` çš„åŸºç¡€ç‰ˆæœ¬ï¼Œå®ƒç°åœ¨èƒ½å¤Ÿå¤„ç†æœ€ç®€å•çš„è¡¨è¾¾å¼äº†ã€‚
/// æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä¸ºå®ƒæ·»åŠ æ–°çš„èƒ½åŠ›ï¼š**è§£æä¸€å…ƒæ“ä½œï¼ˆUnary Expressionsï¼‰**ã€‚
///
/// ## ä»€ä¹ˆæ˜¯ä¸€å…ƒæ“ä½œï¼Ÿ
///
/// ä¸€å…ƒæ“ä½œæ˜¯æŒ‡åªä½œç”¨äºä¸€ä¸ªæ“ä½œæ•°çš„è¡¨è¾¾å¼ã€‚åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬æ”¯æŒä¸¤ç§ä¸€å…ƒæ“ä½œï¼š
///
/// 1.  **é€»è¾‘éï¼š** `!true`
/// 2.  **å–åï¼š** `-42`
///
/// è¿™äº›æ“ä½œç¬¦ä½äºå®ƒä»¬æ‰€ä½œç”¨çš„è¡¨è¾¾å¼ä¹‹å‰ï¼Œè¿™ä¸ºæˆ‘ä»¬çš„é€’å½’ä¸‹é™è§£æå™¨æä¾›äº†ä¸€ä¸ªæ¸…æ™°çš„ä¿¡å·ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šåœ¨ `parse_expr` ä¸­æ”¯æŒä¸€å…ƒæ“ä½œ
///
/// ç°åœ¨ï¼Œè¯·å†æ¬¡ä¿®æ”¹ `parser/expr.mbt` æ–‡ä»¶ä¸­çš„ `parse_expr` å‡½æ•°ï¼Œä¸ºå…¶å¢åŠ è§£æä¸€å…ƒæ“ä½œçš„åŠŸèƒ½ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// åœ¨ `parse_expr` å‡½æ•°çš„å¼€å¤´ï¼Œæˆ‘ä»¬éœ€è¦â€œå‘å‰çœ‹â€ä¸€ä¸ª Tokenï¼š
///
/// 1.  **æ£€æŸ¥ Token ç±»å‹ï¼š**
///     *   å¦‚æœå½“å‰çš„ Token æ˜¯ `!` (å³ `TokenKind::Not`)ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æ˜¯ä¸€ä¸ªé€»è¾‘éè¡¨è¾¾å¼ã€‚
///     *   å¦‚æœå½“å‰çš„ Token æ˜¯ `-` (å³ `TokenKind::BinaryOp(Sub)`)ï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æ˜¯ä¸€ä¸ªå–åè¡¨è¾¾å¼ã€‚
///
/// 2.  **é€’å½’è°ƒç”¨ `parse_expr`ï¼š**
///     *   å¦‚æœåŒ¹é…åˆ°ä¸€å…ƒæ“ä½œç¬¦ï¼Œæˆ‘ä»¬éœ€è¦**è·³è¿‡è¿™ä¸ªæ“ä½œç¬¦ Token**ï¼Œç„¶å**é€’å½’åœ°è°ƒç”¨ `parse_expr`** æ¥è§£æåé¢çš„è¡¨è¾¾å¼éƒ¨åˆ†ã€‚
///
/// 3.  **æ„é€  `Expr` èŠ‚ç‚¹ï¼š**
///     *   åœ¨é€’å½’è°ƒç”¨è¿”å›åï¼Œæˆ‘ä»¬å°†å¾—åˆ°çš„å­è¡¨è¾¾å¼åŒ…è£…åœ¨ä¸€ä¸ªæ–°çš„ä¸€å…ƒè¡¨è¾¾å¼èŠ‚ç‚¹ä¸­ï¼ˆ`NotExpr` æˆ– `NegExpr`ï¼‰ã€‚
///
/// 4.  **é»˜è®¤æƒ…å†µï¼š**
///     *   å¦‚æœå¼€å¤´çš„ Token ä¸æ˜¯ä¸€å…ƒæ“ä½œç¬¦ï¼Œé‚£ä¹ˆå°±æ‰§è¡Œæˆ‘ä»¬ä¹‹å‰å®ç°çš„é€»è¾‘â€”â€”è°ƒç”¨ `parse_apply_expr`ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®Œæˆåï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®ç°ï¼š
///
/// ```bash
/// moon test -p parser -f parse_simple_unary_expr_test.mbt
/// ```
///
/// è¿™ä¸ªæµ‹è¯•å°†éªŒè¯ä½ çš„ `parse_expr` æ˜¯å¦èƒ½æ­£ç¡®å¤„ç† `!` å’Œ `-` æ“ä½œã€‚
///
/// **ç¥ä½ é¡ºåˆ©ï¼é€šè¿‡é€’å½’ï¼Œæˆ‘ä»¬çš„è§£æå™¨æ­£åœ¨å˜å¾—è¶Šæ¥è¶Šå¼ºå¤§ï¼**
/// ================================================================================

///|
test "Unary Expr Parsing Test" {
  let code =
    #|-42 ;
    #|!true ;
    #|-res ;
    #|!cond ;
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = parse_expr(tokens[:])
  assert_true(
    e.kind is NegExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is NotExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Bool(true),
  )
  let (e, tok_view) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is NegExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("res"),
  )
  let (e, _) = parse_expr(tok_view[1:])
  assert_true(
    e.kind is NotExpr(inner) &&
    inner.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Ident("cond"),
  )
}
/// ================================================================================
/// # åˆ›å»ºå®ä¾‹ï¼šè§£æç»“æ„ä½“æ„é€ è¡¨è¾¾å¼
///
/// æˆ‘ä»¬å·²ç»å®šä¹‰äº†ç»“æ„ä½“ï¼ˆStructï¼‰ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥åˆ›å»ºå®ƒçš„å®ä¾‹ã€‚
/// è¿™å°±æ˜¯**ç»“æ„ä½“æ„é€ è¡¨è¾¾å¼ï¼ˆStruct Construction Expressionï¼‰**çš„ä½œç”¨ã€‚
///
/// ## ç»“æ„ä½“æ„é€ çš„ EBNF èŒƒå¼
///
/// ```
/// struct_construct ::= Upper "::" "{" (field_init ("," field_init)* ","? )? "}"
/// field_init       ::= ident ":" expr
/// ```
///
/// è¿™æ®µèŒƒå¼æè¿°äº†å¦‚ä½•åˆ›å»ºä¸€ä¸ªç»“æ„ä½“å®ä¾‹ï¼š
/// 1.  ä»¥ç»“æ„ä½“ç±»å‹åï¼ˆ`Upper` Tokenï¼‰å’Œ `::` å¼€å§‹ã€‚
/// 2.  `{}` å†…éƒ¨æ˜¯å­—æ®µçš„åˆå§‹åŒ–åˆ—è¡¨ã€‚
/// 3.  æ¯ä¸ª `field_init` åŒ…å«ä¸€ä¸ªå­—æ®µå `ident`ã€ä¸€ä¸ªå†’å· `:` å’Œä¸€ä¸ªåˆå§‹åŒ– `expr`ã€‚
/// 4.  å­—æ®µä¹‹é—´ç”¨é€—å· `,` åˆ†éš”ï¼Œå¹¶ä¸”å…è®¸æœ‰ä¸€ä¸ªå°¾éšçš„é€—å·ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_struct_construct`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/struct_construct_expr.mbt` ä¸­å®ç° `parse_struct_construct` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è¿™ä¸ªè§£æé€»è¾‘ä¸æˆ‘ä»¬ä¹‹å‰è§£æå…ƒç»„ã€æ•°ç»„å’Œå‡½æ•°å‚æ•°åˆ—è¡¨çš„é€»è¾‘éå¸¸ç›¸ä¼¼ã€‚
///
/// 1.  åŒ¹é…ç»“æ„ä½“åç§°ï¼ˆ`Upper`ï¼‰å’Œ `::{`ã€‚
/// 2.  è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œè§£æç”±é€—å·åˆ†éš”çš„ `ident: expr` é”®å€¼å¯¹ã€‚
/// 3.  å¾ªç¯ç›´åˆ°é‡åˆ° `}`ã€‚
/// 4.  å°†è§£æå‡ºçš„å­—æ®µå’Œå€¼å­˜å…¥ä¸€ä¸ª `Array`ï¼Œå¹¶åˆ›å»ºä¸€ä¸ª `StructConstructExpr` èŠ‚ç‚¹ã€‚
///
/// ### âš ï¸ ä¸è¦å¿˜è®°ï¼
///
/// å®Œæˆ `parse_struct_construct` åï¼Œä½ è¿˜éœ€è¦å›åˆ° `parser/atom_expr.mbt` ä¸­çš„ `parse_atom_expr` å‡½æ•°ï¼Œ
/// å°†è¿™ä¸ªæ–°çš„è§£æå™¨æ•´åˆè¿›å»ã€‚å½“ `parse_atom_expr` é‡åˆ°ä¸€ä¸ªå¤§å†™å­—æ¯å¼€å¤´çš„æ ‡è¯†ç¬¦ï¼ˆ`Upper` Tokenï¼‰æ—¶ï¼Œ
/// å®ƒéœ€è¦èƒ½å¤Ÿåˆ¤æ–­è¿™ç©¶ç«Ÿæ˜¯ä¸€ä¸ª `Array::make` è¿˜æ˜¯ä¸€ä¸ªç»“æ„ä½“æ„é€ ã€‚
///
/// ç›¸ä¿¡è¿™å¯¹ä½ æ¥è¯´å·²ç»ä¸éš¾äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_struct_construct_test.mbt
/// ```
/// ================================================================================

///|
test "Parse Struct Construct Expr" {
  let code =
    #|Data::{ x: [1, 2, 3], y: (4, 5, 6) }
  let tokens = @lexer.tokenize(code)
  let (e, _) = parse_struct_construct(tokens[:])
  assert_true(
    e.kind is StructConstruct(s) &&
    s.name == "Data" &&
    s.fields is [f1, f2] &&
    f1 is ("x", expr1) &&
    f2 is ("y", expr2) &&
    expr1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Array([_, _, _]) &&
    expr2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Tuple([_, _, _]),
  )
}
/// ================================================================================
/// # è‡ªå®šä¹‰ç±»å‹ï¼šè§£æç»“æ„ä½“å®šä¹‰
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿè§£æ MiniMoonBit çš„æ‰€æœ‰å†…ç½®ç±»å‹å’Œè¯­å¥äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬æ¥æ·»åŠ ä¸€ä¸ªå¼ºå¤§çš„åŠŸèƒ½ï¼š
/// å…è®¸ç”¨æˆ·**è‡ªå®šä¹‰ç±»å‹**ï¼Œå³**ç»“æ„ä½“ï¼ˆStructï¼‰**ã€‚
///
/// ç»“æ„ä½“å…è®¸æˆ‘ä»¬å°†å¤šä¸ªä¸åŒç±»å‹çš„å€¼ç»„åˆæˆä¸€ä¸ªæ–°çš„ã€æœ‰åå­—çš„ç±»å‹ã€‚
///
/// ## ç»“æ„ä½“å®šä¹‰çš„ EBNF èŒƒå¼
///
/// ```
/// struct_def ::= "struct" ident "{" (field_def (";" field_def)* ";"? )? "}"
/// field_def  ::= ("mut")? ident ":" type
/// ```
///
/// è¿™æ®µèŒƒå¼å‘Šè¯‰æˆ‘ä»¬ï¼š
/// 1.  ä»¥ `struct` å…³é”®å­—å’Œç±»å‹åï¼ˆå¤§å†™å­—æ¯å¼€å¤´çš„ `ident`ï¼‰å¼€å§‹ã€‚
/// 2.  `{}` å†…éƒ¨æ˜¯å­—æ®µåˆ—è¡¨ã€‚
/// 3.  æ¯ä¸ªå­—æ®µ `field_def` åŒ…å«ä¸€ä¸ªå¯é€‰çš„ `mut` å…³é”®å­—ã€ä¸€ä¸ªå­—æ®µåï¼ˆå°å†™å­—æ¯å¼€å¤´çš„ `ident`ï¼‰å’Œä¸€ä¸ªç±»å‹ã€‚
/// 4.  å­—æ®µä¹‹é—´å¿…é¡»ç”¨åˆ†å· `;` åˆ†éš”ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_struct_def`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/struct_def.mbt` ä¸­å®ç° `parse_struct_def` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// 1.  è§£æ `struct` å…³é”®å­—å’Œç»“æ„ä½“åç§°ã€‚
/// 2.  è§£æå¼€å¤´çš„ `{"{"`ã€‚
/// 3.  è¿›å…¥ä¸€ä¸ªå¾ªç¯ï¼Œè§£æ `{"{""}"}` å†…éƒ¨çš„å­—æ®µåˆ—è¡¨ã€‚å¾ªç¯çš„ç»ˆæ­¢æ¡ä»¶æ˜¯é‡åˆ° `"}"`ã€‚
/// 4.  åœ¨å¾ªç¯å†…éƒ¨ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªè¾…åŠ©å‡½æ•° `parse_struct_field` æ¥è§£æå•ä¸ªå­—æ®µã€‚è¿™ä¸ªå‡½æ•°è´Ÿè´£è§£æå¯é€‰çš„ `mut`ã€å­—æ®µåã€å†’å·å’Œç±»å‹ï¼Œå¹¶è¦æ±‚åé¢å¿…é¡»è·Ÿä¸€ä¸ªåˆ†å·ã€‚
/// 5.  è§£æç»“å°¾çš„ `"}"`ã€‚
///
/// è¿™ä¸ªç»“æ„ä¸è§£æä»£ç å— `block_expr` éå¸¸ç›¸ä¼¼ï¼Œç›¸ä¿¡ä½ å·²ç»å¾ˆç†Ÿæ‚‰äº†ã€‚
///
/// åŠ æ²¹ï¼è¿™æ˜¯æˆ‘ä»¬ä¸ºè¯­è¨€æ·»åŠ å¤åˆæ•°æ®ç±»å‹çš„å…³é”®ä¸€æ­¥ã€‚
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_struct_def_test.mbt
/// ```
/// ================================================================================

///|
test "Struct Def Parsing Test" {
  let code =
    #|struct Point {
    #|  x: Int;
    #|  mut y: Int;
    #|  z: Double;
    #|}
  let tokens = @lexer.tokenize(code)
  let (struct_def, _) = parse_struct_def(tokens)
  assert_true(struct_def.name is "Point")
  assert_true(struct_def.fields.length() is 3)
  assert_true(struct_def.fields[0] is { name: "x", is_mut: false, .. })
  assert_true(struct_def.fields[0].ty is { kind: Int, .. })
  assert_true(struct_def.fields[1] is { name: "y", is_mut: true, .. })
  assert_true(struct_def.fields[1].ty is { kind: Int, .. })
  assert_true(struct_def.fields[2] is { name: "z", is_mut: false, .. })
  assert_true(struct_def.fields[2].ty is { kind: Double, .. })
}
/// ================================================================================
/// # ç¨‹åºçš„é¡¶å±‚ç»“æ„ï¼šè§£æé¡¶å±‚å‡½æ•°
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿè§£æè¯­å¥å’Œå—å†…çš„å±€éƒ¨å‡½æ•°äº†ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬ç»ˆäºæ¥åˆ°äº†æ„æˆä¸€ä¸ªå®Œæ•´ç¨‹åºçš„
/// åŸºæœ¬å•å…ƒï¼š**é¡¶å±‚å‡½æ•°ï¼ˆTop-level Functionï¼‰**ã€‚
///
/// ## é¡¶å±‚å‡½æ•° vs. å±€éƒ¨å‡½æ•°
///
/// é¡¶å±‚å‡½æ•°ä¸æˆ‘ä»¬ä¹‹å‰è§£æçš„å±€éƒ¨å‡½æ•°éå¸¸ç›¸ä¼¼ï¼Œä½†æœ‰å‡ ä¸ªå…³é”®çš„ã€æ›´ä¸¥æ ¼çš„çº¦æŸï¼š
///
/// 1.  **ç±»å‹æ³¨è§£ï¼š** é¡¶å±‚å‡½æ•°çš„æ‰€æœ‰å‚æ•°éƒ½**å¿…é¡»**æœ‰æ˜ç¡®çš„ç±»å‹æ³¨è§£ã€‚
/// 2.  **è¿”å›ç±»å‹ï¼š** é¡¶å±‚å‡½æ•°**å¿…é¡»**æœ‰æ˜ç¡®çš„è¿”å›ç±»å‹æ³¨è§£ã€‚
/// 3.  **main å‡½æ•°ç‰¹ä¾‹ï¼š** `fn main { ... }` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„é¡¶å±‚å‡½æ•°ï¼Œå®ƒæ²¡æœ‰å‚æ•°ï¼Œè¿”å›ç±»å‹é»˜è®¤ä¸º `Unit`ã€‚
///
/// ## é¡¶å±‚å‡½æ•°çš„ EBNF èŒƒå¼
///
/// ```
/// top_fn ::= "fn" ident "(" (param ("," param)*)? ")" "->" type block_expr
/// param  ::= ident ":" type
/// ```
///
/// **æ³¨æ„ï¼š** è¿™ä¸ª EBNF æè¿°çš„æ˜¯ä¸€èˆ¬æƒ…å†µã€‚ä½ éœ€è¦ç‰¹æ®Šå¤„ç† `fn main`ã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_top_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/top_function.mbt` ä¸­å®ç° `parse_top_function` å‡½æ•°ã€‚
///
/// **å®ç°æ€è·¯ï¼š**
///
/// è¿™ä¸ªå‡½æ•°çš„è§£æé€»è¾‘ä¸ `parse_local_function` é«˜åº¦é‡åˆï¼Œä½ ç”šè‡³å¯ä»¥å¤ç”¨ä¸€äº›è¾…åŠ©å‡½æ•°ï¼ˆä¾‹å¦‚è§£æå‚æ•°åˆ—è¡¨ï¼‰ã€‚
/// ä¸»è¦çš„åŒºåˆ«åœ¨äºä½ éœ€è¦æ›´ä¸¥æ ¼åœ°æ£€æŸ¥ç±»å‹æ³¨è§£æ˜¯å¦å­˜åœ¨ã€‚
///
/// 1.  è§£æ `fn` å…³é”®å­—å’Œå‡½æ•°åã€‚
/// 2.  **æ£€æŸ¥æ˜¯å¦ä¸º `main` å‡½æ•°**ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å‚æ•°åˆ—è¡¨ä¸ºç©ºï¼Œè¿”å›ç±»å‹ä¸º `Unit`ï¼Œç„¶åç›´æ¥è§£æå‡½æ•°ä½“ã€‚
/// 3.  å¦‚æœä¸æ˜¯ `main`ï¼Œåˆ™ä¸¥æ ¼æŒ‰ç…§ EBNF è§£æå¸¦ç±»å‹æ³¨è§£çš„å‚æ•°åˆ—è¡¨å’Œè¿”å›ç±»å‹ã€‚
/// 4.  è°ƒç”¨ `parse_block_expr` è§£æå‡½æ•°ä½“ã€‚
///
/// ç›¸ä¿¡è¿™å¯¹ä½ æ¥è¯´åªæ˜¯å°è¯•ç‰›åˆ€ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_top_function_test.mbt
/// ```
/// ================================================================================

///|
test "Top Function Parsing Test - 1" {
  let code =
    #|fn add(x: Int, y: Int) -> Int {
    #|  x + y;
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_top_function(tokens)
  assert_true(func.fname is "add")
  assert_true(func.param_list.length() is 2)
  assert_true(func.param_list[0] is { name: "x", ty: { kind: Int, .. } })
  assert_true(func.param_list[1] is { name: "y", ty: { kind: Int, .. } })
  assert_true(func.ret_ty is { kind: Int, .. })
  assert_true(func.body.stmts.length() is 1)
  assert_true(func.body.stmts[0].kind is ExprStmt(_))
}

///|
test "Main Function Parsing Test - 2 (main)" {
  let code =
    #|fn main {
    #|  let x = 10;
    #|  let y = 20;
    #|  println(x + y);
    #|}
  let tokens = @lexer.tokenize(code)
  let (func, _) = parse_top_function(tokens)
  assert_true(func.fname is "main")
  assert_true(func.param_list.length() is 0)
  assert_true(func.ret_ty is { kind: Unit, .. })
  assert_true(func.body.stmts.length() is 3)
  assert_true(func.body.stmts[0].kind is LetStmt(_))
  assert_true(func.body.stmts[1].kind is LetStmt(_))
  assert_true(func.body.stmts[2].kind is ExprStmt(_))
}
/// ================================================================================
/// # ç¨‹åºçš„é¡¶å±‚ç»“æ„ï¼šè§£æé¡¶å±‚ let ç»‘å®š
///
/// é™¤äº†é¡¶å±‚å‡½æ•°ï¼Œä¸€ä¸ª MiniMoonBit ç¨‹åºè¿˜å¯ä»¥åŒ…å«é¡¶å±‚çš„ `let` ç»‘å®šï¼Œ
/// ç”¨äºå®šä¹‰å…¨å±€å¸¸é‡ã€‚
///
/// ## é¡¶å±‚ `let` vs. è¯­å¥ `let`
///
/// é¡¶å±‚ `let` ä¸æˆ‘ä»¬åœ¨å‡½æ•°ä½“å†…è§£æçš„ `let` è¯­å¥éå¸¸ç›¸ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªæ ¸å¿ƒåŒºåˆ«ï¼š
///
/// **é¡¶å±‚ `let` çš„å·¦è¾¹åªèƒ½æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œä¸èƒ½æ˜¯å¤æ‚çš„æ¨¡å¼ã€‚**
///
/// ## é¡¶å±‚ `let` çš„ EBNF èŒƒå¼
///
/// ```
/// top_let ::= "let" ident (":" type)? "=" expr ";"
/// ```
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_top_let`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/top_let.mbt` ä¸­å®ç° `parse_top_let` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°çš„é€»è¾‘ä¸æˆ‘ä»¬ä¹‹å‰å®ç°çš„ `parse_let_mut_stmt` å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œ
/// åªæ˜¯å°† `let mut` æ¢æˆäº† `let`ã€‚
///
/// ç›¸ä¿¡è¿™ä¸ªä»»åŠ¡å¯¹ä½ æ¥è¯´å·²ç»éå¸¸è½»æ¾äº†ã€‚
///
/// åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_top_let_test.mbt
/// ```
/// ================================================================================

///|
test "Top Let Parsing Test" {
  let code =
    #|let x: Int = 42;
    #|let y: Bool = true;
    #|let z: Array[Int] = [1, 2, 3];
  let tokens = @lexer.tokenize(code)
  let (s, tok_view) = parse_top_let(tokens)
  assert_true(
    s.name is "x" &&
    s.ty is Some(ty) &&
    ty.kind is Int &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Int(42),
  )
  let (s, tok_view) = parse_top_let(tok_view)
  assert_true(
    s.name is "y" &&
    s.ty is Some(ty) &&
    ty.kind is Bool &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Bool(true),
  )
  let (s, _) = parse_top_let(tok_view)
  assert_true(
    s.name is "z" &&
    s.ty is Some(ty) &&
    ty.kind is Array(Int) &&
    s.expr.kind is ApplyExpr(a) &&
    a.kind is AtomExpr(atom) &&
    atom.kind is Array([e1, e2, e3]) &&
    e1.kind is ApplyExpr(a1) &&
    a1.kind is AtomExpr(atom1) &&
    atom1.kind is Int(1) &&
    e2.kind is ApplyExpr(a2) &&
    a2.kind is AtomExpr(atom2) &&
    atom2.kind is Int(2) &&
    e3.kind is ApplyExpr(a3) &&
    a3.kind is AtomExpr(atom3) &&
    atom3.kind is Int(3),
  )
}
/// ================================================================================
/// # è¯­æ³•è§£æçš„å¦ä¸€åˆ†æ”¯ï¼šè§£æç±»å‹
///
/// æ­å–œä½ ï¼ä½ å·²ç»å¾æœäº†è¡¨è¾¾å¼è§£æä¸­æœ€è‰°éš¾ã€æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ã€‚
/// ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†ç›®å…‰ä»â€œå€¼â€çš„ä¸–ç•Œæš‚æ—¶ç§»å¼€ï¼Œè½¬å‘â€œç±»å‹â€çš„ä¸–ç•Œã€‚
///
/// åœ¨ `parser/typedef.mbt` ä¸­ï¼Œä½ éœ€è¦å®ç° `parse_type` å‡½æ•°ï¼Œ
/// å®ƒè´Ÿè´£å°† Token åºåˆ—è§£æä¸º MiniMoonBit ä¸­çš„å„ç§ç±»å‹ï¼Œä¾‹å¦‚ `Int`ã€`Array[Bool]`ã€`(Int, Double) -> Bool` ç­‰ã€‚
///
/// ç›¸ä¿¡åœ¨ç»å†äº†è¡¨è¾¾å¼è§£æçš„é‡é‡è€ƒéªŒä¹‹åï¼Œç±»å‹çš„è§£æå¯¹ä½ æ¥è¯´åº”è¯¥å·²ç»æ˜¯å°èœä¸€ç¢Ÿäº†ã€‚
/// å®ƒçš„é€»è¾‘ä¸è§£æè¡¨è¾¾å¼æœ‰è®¸å¤šç›¸ä¼¼ä¹‹å¤„ï¼Œä½†é€šå¸¸æ›´ç®€å•ï¼Œå› ä¸ºå®ƒä¸æ¶‰åŠè¿ç®—ç¬¦ä¼˜å…ˆçº§ç­‰å¤æ‚é—®é¢˜ã€‚
///
/// å› æ­¤ï¼Œè¿™ä¸ªæŒ‘æˆ˜çš„æ•™ç¨‹å°±ä¸å†åšè¿‡å¤šå±•å¼€äº†ï¼Œè¯·ä½ å°½æƒ…æ–½å±•å§ï¼
///
/// åŠ æ²¹ï¼ğŸ’ª
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_type_test.mbt
/// ```
/// ================================================================================

///|
test "Simple Type Parsing" {
  let code =
    #|Unit Int Bool Double
  let tokens = @lexer.tokenize(code)
  let (ty, tok_view) = parse_type(tokens[:])
  assert_true(ty.kind is Unit)
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Int)
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Bool)
  let (ty, _) = parse_type(tok_view)
  assert_true(ty.kind is Double)
}

///|
test "Complex Type Parsing" {
  let code =
    #|Array[Int]
    #|(Int, Double) 
    #|() -> Double
    #|((Int, Double), Unit)
    #|(Array[Bool], Unit) -> Double
    #|Array[(Int, Double)]
    #|Array[() -> Double]
    #|Array[((Int, Double), Unit)]
  let tokens = @lexer.tokenize(code)
  let (ty, tok_view) = parse_type(tokens[:])
  assert_true(ty.kind is Array(Int))
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Tuple([Int, Double]))
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Function([], Double))
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Tuple([Tuple([Int, Double]), Unit]))
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Function([Array(Bool), Unit], Double))
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Array(Tuple([Int, Double])))
  let (ty, tok_view) = parse_type(tok_view)
  assert_true(ty.kind is Array(Function([], Double)))
  let (ty, _) = parse_type(tok_view)
  assert_true(ty.kind is Array(Tuple([Tuple([Int, Double]), Unit])))
}
/// ================================================================================
/// # å¾ªç¯çš„åŠ›é‡ï¼šè§£æ while è¯­å¥
///
/// æˆ‘ä»¬å·²ç»æœ‰äº† `if-else` ä½œä¸ºåˆ†æ”¯ç»“æ„ï¼Œç°åœ¨è®©æˆ‘ä»¬æ¥æ·»åŠ  MiniMoonBit ä¸­å”¯ä¸€çš„å¾ªç¯ç»“æ„ï¼š
/// **`while` è¯­å¥**ã€‚
///
/// `while` è¯­å¥å…è®¸æˆ‘ä»¬æ ¹æ®ä¸€ä¸ªæ¡ä»¶é‡å¤åœ°æ‰§è¡Œä¸€ä¸ªä»£ç å—ã€‚
///
/// ## `while` è¯­å¥çš„ EBNF èŒƒå¼
///
/// `while` è¯­å¥çš„ç»“æ„éå¸¸ç®€å•æ˜äº†ï¼š
///
/// ```
/// while_stmt ::= "while" expr block_expr
/// ```
///
/// å®ƒç”± `while` å…³é”®å­—ã€ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼å’Œä¸€ä¸ªå¾ªç¯ä½“ä»£ç å—ç»„æˆã€‚
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç° `parse_while_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `parser/while_stmt.mbt` ä¸­å®ç° `parse_while_stmt` å‡½æ•°ã€‚
///
/// è¿™ä¸ªè§£æä»»åŠ¡éå¸¸ç›´æ¥ï¼š
/// 1.  åŒ¹é… `while` å…³é”®å­—ã€‚
/// 2.  è°ƒç”¨ `parse_expr` è§£ææ¡ä»¶è¡¨è¾¾å¼ã€‚
/// 3.  è°ƒç”¨ `parse_block_expr` è§£æå¾ªç¯ä½“ã€‚
///
/// ç›¸ä¿¡è¿™å¯¹ä½ æ¥è¯´å·²ç»è½»è€Œæ˜“ä¸¾äº†ã€‚åŠ æ²¹ï¼
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p parser -f parse_while_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Parse While Stmt Test" {
  let code =
    #|while a < b { a += 1; b -=2; }
    #|while a < b { println(a); a += b % 3; } 
  let tokens = @lexer.tokenize(code)
  let (while_stmt1, tok_view) = parse_while_stmt(tokens[:])
  assert_true(while_stmt1.body.stmts.length() is 2)
  let (while_stmt2, _) = parse_while_stmt(tok_view)
  assert_true(while_stmt2.body.stmts.length() is 2)
}
