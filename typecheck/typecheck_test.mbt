/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥ Apply è¡¨è¾¾å¼ï¼šæœ€ç»ˆç« 
///
/// æˆ‘ä»¬å·²ç»ä¸º `check_apply_expr` å®žçŽ°äº†åŸºç¡€çš„ `AtomExpr` åŒ…è£…ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å®Œæˆ `check_apply_expr` çš„æ‰€æœ‰å‰©ä½™åˆ†æ”¯ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†æ‰€æœ‰å¤æ‚çš„ `ApplyExpr` ç±»åž‹äº†ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œæˆ `check_apply_expr` çš„æ‰€æœ‰åˆ†æ”¯
///
/// ä½ çš„ä»»åŠ¡æ˜¯å›žåˆ° `typecheck/apply_expr.mbt` æ–‡ä»¶ï¼Œå®Œæˆ `Context::check_apply_expr` å‡½æ•°ä¸­å‰©ä½™çš„ `match` åˆ†æ”¯ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// `check_apply_expr` çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¾ªçŽ¯æˆ–é€’å½’ç»“æž„ï¼Œå®ƒé¦–å…ˆæ£€æŸ¥ä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼ï¼ˆ`AtomExpr`ï¼‰ï¼Œç„¶åŽä¸æ–­æ£€æŸ¥åŽé¢æ˜¯å¦è·Ÿéš `()`ã€`[]` æˆ– `.`ï¼Œå¹¶æŒç»­å°†è¡¨è¾¾å¼â€œåŒ…è£…â€æˆæ›´å¤æ‚çš„ `ApplyExpr`ã€‚
///
/// ä½ éœ€è¦ä¸º `check_apply_expr` ä¸­çš„ä»¥ä¸‹ `ApplyExprKind` åˆ†æ”¯ç¼–å†™ç±»åž‹æ£€æŸ¥é€»è¾‘ï¼š
///
/// 1.  **`ArrayAccess(array_expr, index_expr)` (æ•°ç»„ç´¢å¼• `array[index]`)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `array_expr`ï¼Œå¹¶è°ƒç”¨ `check_expr` æ£€æŸ¥ `index_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š
///         *   `array_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Array[T]`ã€‚
///         *   `index_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Int`ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹æ˜¯æ•°ç»„çš„å…ƒç´ ç±»åž‹ `T`ã€‚
///
/// 2.  **`FieldAccess(object_expr, field_name)` (å­—æ®µè®¿é—® `object.field`)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `object_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š
///         *   å¦‚æžœ `object_expr` çš„ç±»åž‹æ˜¯ `Struct(struct_name)`ï¼šä½ éœ€è¦ä»Ž `Context` çš„ `struct_defs` ä¸­æŸ¥æ‰¾è¯¥ç»“æž„ä½“çš„å®šä¹‰ï¼Œå¹¶æ‰¾åˆ° `field_name` å¯¹åº”çš„å­—æ®µç±»åž‹ã€‚
///         *   **ç‰¹æ®Šæƒ…å†µï¼šæ•°ç»„çš„å†…ç½®æ–¹æ³•**ã€‚åœ¨ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ `FieldAccess` è¯­æ³•æ¥è®¿é—®æ•°ç»„çš„å†…ç½®æ–¹æ³•ï¼Œä¾‹å¦‚ `arr.push(value)` å’Œ `arr.length()`ã€‚ä½ éœ€è¦è¯†åˆ« `object_expr` çš„ç±»åž‹æ˜¯å¦ä¸º `Array[T]`ï¼Œç„¶åŽæ ¹æ® `field_name`ï¼ˆ`"push"` æˆ– `"length"`ï¼‰è¿”å›žå¯¹åº”çš„å‡½æ•°ç±»åž‹ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹å°±æ˜¯è¯¥å­—æ®µæˆ–æ–¹æ³•çš„ç±»åž‹ã€‚
///
/// 3.  **`Call(callee_expr, arg_exprs)` (å‡½æ•°è°ƒç”¨ `func(arg1, arg2, ...)`)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `callee_expr`ï¼ˆè¢«è°ƒç”¨çš„å‡½æ•°ï¼‰ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š
///         *   `callee_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Function` ç±»åž‹ï¼Œä¾‹å¦‚ `Function([ArgT1, ArgT2], RetT)`ã€‚
///         *   éåŽ† `arg_exprs`ï¼Œå¯¹æ¯ä¸ªå‚æ•°è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `check_expr`ã€‚
///         *   **å…³é”®ä¸€æ­¥**ï¼šæ£€æŸ¥æ¯ä¸ªä¼ å…¥å‚æ•°çš„ç±»åž‹æ˜¯å¦ä¸Žå‡½æ•°ç­¾åä¸­å¯¹åº”å‚æ•°çš„ç±»åž‹ `ArgT` **å…¼å®¹**ã€‚è¿™é‡Œéœ€è¦å¤§é‡ä½¿ç”¨ `is_type_compatible`ï¼Œå®ƒä¼šé©±åŠ¨æˆ‘ä»¬ä¹‹å‰å®žçŽ°çš„ç±»åž‹å˜é‡åˆä¸€ï¼ˆUnificationï¼‰é€»è¾‘ã€‚
///         *   å‚æ•°çš„æ•°é‡ä¹Ÿå¿…é¡»åŒ¹é…ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹æ˜¯å‡½æ•°ç­¾åçš„è¿”å›žç±»åž‹ `RetT`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_apply_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Apply Expression Type Check" {
  let code =
    #|arr[3] ; fact(5) ; print("Hello, World!")
    #|mat[3][4] ; sum(arr); max(x, y);
    #|arr.push(10); mat.length();
  let ctx = Context::new()
  ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  ctx.type_env.set("mat", { kind: Array(Array(Int)), mutable: false })
  ctx.type_env.set("fact", { kind: Function([Int], Int), mutable: false })
  ctx.type_env.set("print", { kind: Function([String], Unit), mutable: false })
  ctx.type_env.set("sum", { kind: Function([Array(Int)], Int), mutable: false })
  // Note: max is local function without type annotations
  // like: fn max(a, b) { ... }
  ctx.type_env.set("max", {
    kind: Function([TypeVar(0), TypeVar(1)], TypeVar(2)),
    mutable: false,
  })
  ctx.type_env.set("x", { kind: Double, mutable: true })
  ctx.type_env.set("y", { kind: Double, mutable: true })
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(0))
  ctx.type_vars.set(2, TypeVar(0))
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of arr[3]
  let (a, tok_view) = @parser.parse_apply_expr(tokens[:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of fact(5)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of print("Hello, World!")
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Unit)
  // Type of mat[3][4]
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of sum(arr)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of max(x, y)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Double)
  // Type of arr.push(10)
  let (a, tok_view) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Unit)
  // Type of mat.length()
  let (a, _) = @parser.parse_apply_expr(tok_view[1:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¯­å¥ï¼šèµ‹å€¼è¯­å¥
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿé€šè¿‡ `let` å’Œ `let mut` å‘çŽ¯å¢ƒä¸­æ·»åŠ æ–°çš„å˜é‡äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬è¦æ£€æŸ¥å¯¹è¿™äº›å˜é‡çš„**èµ‹å€¼ï¼ˆAssignmentï¼‰**æ“ä½œã€‚
///
/// èµ‹å€¼è¯­å¥æ˜¯å‘½ä»¤å¼ç¼–ç¨‹çš„æ ¸å¿ƒï¼Œå®ƒä¼šæ”¹å˜ä¸€ä¸ªå·²å­˜åœ¨å˜é‡çš„å€¼ã€‚ç±»åž‹æ£€æŸ¥å™¨çš„èŒè´£æ˜¯ç¡®ä¿è¿™ç§æ”¹å˜æ˜¯**ç±»åž‹å®‰å…¨**ä¸”**åˆæ³•**çš„ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_assign_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/assign_stmt.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_assign_stmt` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// 1.  **æ£€æŸ¥å·¦å€¼ï¼ˆL-Valueï¼‰ï¼š**
///     *   èµ‹å€¼è¯­å¥çš„å·¦ä¾§ä¸æ˜¯ä»»æ„è¡¨è¾¾å¼ï¼Œè€Œæ˜¯ä¸€ä¸ªâ€œå·¦å€¼â€â€”â€”å¯ä»¥è¢«èµ‹å€¼çš„ç›®æ ‡ï¼Œä¾‹å¦‚å˜é‡ `x`ã€æ•°ç»„å…ƒç´  `arr[0]` æˆ–ç»“æž„ä½“å­—æ®µ `obj.field`ã€‚
///     *   ä½ éœ€è¦é¦–å…ˆå®žçŽ°ä¸€ä¸ª `check_left_value` è¾…åŠ©å‡½æ•°ï¼Œå®ƒè´Ÿè´£æ£€æŸ¥å·¦å€¼çš„ç±»åž‹ã€‚ä¾‹å¦‚ï¼Œå¯¹äºŽ `x`ï¼Œå®ƒéœ€è¦åˆ°ç±»åž‹çŽ¯å¢ƒä¸­æŸ¥æ‰¾ `x` çš„ç±»åž‹ã€‚
///
/// 2.  **æ£€æŸ¥å¯å˜æ€§ï¼ˆMutabilityï¼‰ï¼š**
///     *   **è¿™æ˜¯èµ‹å€¼æ£€æŸ¥ä¸­æœ€å…³é”®çš„ä¸€æ­¥ï¼** ä½ ä¸èƒ½ç»™ä¸€ä¸ªä¸å¯å˜çš„å˜é‡èµ‹å€¼ã€‚
///     *   å½“ä½ ä»Žç±»åž‹çŽ¯å¢ƒä¸­æŸ¥æ‰¾åˆ°å·¦ä¾§å˜é‡çš„ç±»åž‹åŽï¼Œå¿…é¡»æ£€æŸ¥å…¶ `mutable` æ ‡å¿—æ˜¯å¦ä¸º `true`ã€‚å¦‚æžœä¸æ˜¯ï¼Œå°±åº”è¯¥æŠ›å‡ºç±»åž‹é”™è¯¯ã€‚
///     *   æ€è€ƒä¸€ä¸‹ï¼šå¯¹äºŽ `arr[0]` è¿™æ ·çš„å·¦å€¼ï¼Œå®ƒçš„å¯å˜æ€§åº”è¯¥å¦‚ä½•ç¡®å®šï¼Ÿï¼ˆæç¤ºï¼šå®ƒå–å†³äºŽ `arr` æœ¬èº«æ˜¯å¦å¯å˜ï¼Œè¿˜æ˜¯æ•°ç»„å…ƒç´ æ€»æ˜¯å¯å˜çš„ï¼Ÿï¼‰åœ¨æˆ‘ä»¬çš„ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬åšä¸€ä¸ªç®€åŒ–ï¼Œè®¤ä¸ºåªè¦æ•°ç»„æœ¬èº«æ˜¯å¯è®¿é—®çš„ï¼Œå…¶å…ƒç´ å°±æ˜¯å¯å˜çš„ã€‚
///
/// 3.  **æ£€æŸ¥å³å€¼ï¼ˆR-Valueï¼‰ï¼š**
///     *   è°ƒç”¨ `self.check_expr` æ£€æŸ¥ `=` å³ä¾§è¡¨è¾¾å¼çš„ç±»åž‹ã€‚
///
/// 4.  **æ£€æŸ¥ç±»åž‹å…¼å®¹æ€§ï¼š**
///     *   ç¡®ä¿å³ä¾§è¡¨è¾¾å¼çš„ç±»åž‹ä¸Žå·¦å€¼çš„ç±»åž‹æ˜¯å…¼å®¹çš„ã€‚
///
/// 5.  **å¤„ç†å¤åˆèµ‹å€¼ï¼ˆCompound Assignmentï¼‰ï¼š**
///     *   å¯¹äºŽ `+=`, `-=` ç­‰æ“ä½œï¼Œä½ è¿˜éœ€è¦é¢å¤–æ£€æŸ¥å·¦å³ä¸¤ä¾§çš„ç±»åž‹æ˜¯å¦é€‚ç”¨äºŽè¯¥ç®—æœ¯è¿ç®—ï¼ˆä¾‹å¦‚ï¼Œå®ƒä»¬å¿…é¡»æ˜¯ `Int` æˆ– `Double`ï¼‰ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_assign_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Assign Stmt Type Check" {
  let code =
    #|let mut x = 10;
    #|x = 5;
    #|let arr = [1, 2, 3];
    #|arr[0] = 10;
    #|x += true;  // Shoule fail
    #|let mut a = xxx;  // xxx's type is typevar
    #|a += 33;  // `a` and `xxx` should be inferred as Int
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of let mut x = 10; x = 5; 
  let (s, tok_view) = @parser.parse_let_mut_stmt(tokens[:])
  let _ = ctx.check_let_mut_stmt(s)
  let (a, tok_view) = @parser.parse_assign_stmt(tok_view)
  let a = ctx.check_assign_stmt(a)
  assert_true(a.left_value.ty.kind is Int)
  assert_true(a.expr.ty is Int)
  // Type of `let arr = [1, 2, 3]; arr[0] = 10;`
  let (s, tok_view) = @parser.parse_let_stmt(tok_view)
  let _ = ctx.check_let_stmt(s)
  let (a, tok_view) = @parser.parse_assign_stmt(tok_view)
  let a = ctx.check_assign_stmt(a)
  assert_true(a.left_value.ty.kind is Int)
  assert_true(a.left_value.ty.mutable is true)
  assert_true(a.expr.ty is Int)
  // Type of `x += true;` should fail
  let (a, tok_view) = @parser.parse_assign_stmt(tok_view)
  let t = try? ctx.check_assign_stmt(a)
  assert_true(t is Err(_))
  // Type of `let mut a = xxx; a += 33;`
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_env.set("xxx", { kind: TypeVar(0), mutable: false })
  let (s, tok_view) = @parser.parse_let_mut_stmt(tok_view)
  let _ = ctx.check_let_mut_stmt(s)
  let (a, _) = @parser.parse_assign_stmt(tok_view)
  let _ = ctx.check_assign_stmt(a)
  assert_true(ctx.lookup_type("a") is Some({ kind: Int, .. }))
  assert_true(ctx.lookup_type("xxx") is Some({ kind: Int, .. }))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥åŽŸå­è¡¨è¾¾å¼ï¼šå®Œæ•´ç¯‡
///
/// æˆ‘ä»¬å·²ç»å®žçŽ°äº† `check_atom_expr` çš„åŸºç¡€éƒ¨åˆ†ï¼Œèƒ½å¤Ÿå¤„ç†å­—é¢é‡å’Œæ ‡è¯†ç¬¦ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å®Œæˆ `check_atom_expr` çš„æ‰€æœ‰å‰©ä½™åˆ†æ”¯ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†æ‰€æœ‰ç±»åž‹çš„åŽŸå­è¡¨è¾¾å¼äº†ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œæˆ `check_atom_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯å›žåˆ° `typecheck/atom_expr.mbt` æ–‡ä»¶ï¼Œå®Œæˆ `Context::check_atom_expr` å‡½æ•°ä¸­å‰©ä½™çš„ `match` åˆ†æ”¯ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// ä½ éœ€è¦ä¸º `check_atom_expr` ä¸­çš„ä»¥ä¸‹ `AtomExprKind` åˆ†æ”¯ç¼–å†™ç±»åž‹æ£€æŸ¥é€»è¾‘ï¼š
///
/// 1.  **`Paren(expr)` (æ‹¬å·è¡¨è¾¾å¼ `(expr)`)**
///     *   é€’å½’è°ƒç”¨ `self.check_expr(expr)` æ£€æŸ¥å†…éƒ¨è¡¨è¾¾å¼ã€‚
///     *   `Paren` è¡¨è¾¾å¼çš„ç±»åž‹å°±æ˜¯å…¶å†…éƒ¨è¡¨è¾¾å¼çš„ç±»åž‹ã€‚
///
/// 2.  **`Tuple(exprs)` (å…ƒç»„è¡¨è¾¾å¼ `(expr1, expr2, ...)`)**
///     *   éåŽ† `exprs` æ•°ç»„ï¼Œå¯¹æ¯ä¸ªå­è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `self.check_expr`ã€‚
///     *   å°†æ‰€æœ‰å­è¡¨è¾¾å¼çš„ç±»åž‹æ”¶é›†èµ·æ¥ï¼Œæž„æˆä¸€ä¸ª `TypeKind::Tuple` ç±»åž‹ã€‚
///     *   **æç¤ºï¼š** ä½ å¯ä»¥å®žçŽ°ä¸€ä¸ªè¾…åŠ©å‡½æ•° `check_tuple_expr` æ¥å¤„ç†è¿™ä¸ªé€»è¾‘ã€‚
///
/// 3.  **`Array(exprs)` (æ•°ç»„å­—é¢é‡ `[expr1, expr2, ...]`)**
///     *   éåŽ† `exprs` æ•°ç»„ï¼Œå¯¹æ¯ä¸ªå­è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `self.check_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™ï¼š** æ•°ç»„çš„æ‰€æœ‰å…ƒç´ å¿…é¡»å…·æœ‰å…¼å®¹çš„ç±»åž‹ã€‚ä½ éœ€è¦ä½¿ç”¨ `self.is_type_compatible` æ¥ç¡®ä¿è¿™ä¸€ç‚¹ã€‚
///     *   **ç©ºæ•°ç»„ `[]` çš„ç‰¹æ®Šå¤„ç†ï¼š** å¦‚æžœæ•°ç»„ä¸ºç©ºï¼Œå®ƒçš„å…ƒç´ ç±»åž‹æ˜¯æœªçŸ¥çš„ã€‚æ­¤æ—¶ï¼Œä½ åº”è¯¥åˆ›å»ºä¸€ä¸ª `TypeVar` ä½œä¸ºå…¶å…ƒç´ ç±»åž‹çš„å ä½ç¬¦ï¼Œä¾‹å¦‚ `Array(TypeVar(N))`ã€‚
///     *   **æç¤ºï¼š** ä½ å¯ä»¥å®žçŽ°ä¸€ä¸ªè¾…åŠ©å‡½æ•° `check_array_expr` æ¥å¤„ç†è¿™ä¸ªé€»è¾‘ã€‚
///
/// 4.  **`ArrayMake(size_expr, init_expr)` (`Array::make(size, init)`)**
///     *   è°ƒç”¨ `self.check_expr` æ£€æŸ¥ `size_expr`ï¼Œå…¶ç±»åž‹å¿…é¡»æ˜¯ `Int`ã€‚
///     *   è°ƒç”¨ `self.check_expr` æ£€æŸ¥ `init_expr`ã€‚
///     *   æ•´ä¸ª `ArrayMake` è¡¨è¾¾å¼çš„ç±»åž‹æ˜¯ `Array(init_expr.ty)`ã€‚
///     *   **æç¤ºï¼š** ä½ å¯ä»¥å®žçŽ°ä¸€ä¸ªè¾…åŠ©å‡½æ•° `check_array_make_expr` æ¥å¤„ç†è¿™ä¸ªé€»è¾‘ã€‚
///
/// 5.  **`StructConstruct(sc_expr)` (`StructName::{ field: value, ... }`)**
///     *   è°ƒç”¨ `self.check_struct_construct_expr(sc_expr)` æ¥æ£€æŸ¥ç»“æž„ä½“æž„é€ è¡¨è¾¾å¼ã€‚
///     *   **æç¤ºï¼š** è¿™ä¸ªå‡½æ•°æˆ‘ä»¬å·²ç»åœ¨ä¹‹å‰çš„æŒ‘æˆ˜ä¸­å®žçŽ°è¿‡äº†ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_atom_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Atom Expression Type Check" {
  let code =
    #|[1, 2+3, 3+4+5, 6*7+8] (1+3, !y, "Hello") Array::make(5, 0) []
  let ctx = Context::new()
  ctx.type_env.set("x", { kind: Double, mutable: false })
  ctx.type_env.set("y", { kind: Bool, mutable: false })
  ctx.type_env.set("z", { kind: String, mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of [1, 2+3, 3+4+5, 6*7+8]
  let (a, tok_view) = @parser.parse_atom_expr(tokens[:])
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Array(Int))
  // Type of (1+3, !y, "Hello")
  let (b, tok_view) = @parser.parse_atom_expr(tok_view)
  let b = ctx.check_atom_expr(b)
  assert_true(b.ty is Tuple([Int, Bool, String]))
  // Type of Array::make(5, 0)
  let (c, tok_view) = @parser.parse_atom_expr(tok_view)
  let c = ctx.check_atom_expr(c)
  assert_true(c.ty is Array(Int))
  // Type of []
  let (d, _) = @parser.parse_atom_expr(tok_view)
  let d = ctx.check_atom_expr(d)
  assert_true(d.ty is Array(TypeVar(_)))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¯­å¥å’Œä»£ç å—
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥ç‹¬ç«‹åœ°æ£€æŸ¥å„ç§è¯­å¥äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªâ€œæ€»æŒ‡æŒ¥â€æ¥è°ƒåº¦å®ƒä»¬ï¼Œå¹¶å¤„ç†è¯­å¥çš„é›†åˆâ€”â€”ä»£ç å—ï¼ˆBlockï¼‰ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼šå®žçŽ° `check_stmt`
///
/// ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡æ˜¯åœ¨ `typecheck/stmt.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_stmt` å‡½æ•°ã€‚
/// è¿™ä¸ªå‡½æ•°å°†ä½œä¸ºä¸€ä¸ªåˆ†å‘å™¨ï¼ˆDispatcherï¼‰ã€‚
///
/// ### ðŸ’¡ `check_stmt` å®žçŽ°æ€è·¯
///
/// `match` ä¼ å…¥çš„ `stmt.kind`ï¼Œç„¶åŽè°ƒç”¨æˆ‘ä»¬å·²ç»å®žçŽ°çš„ç›¸åº”çš„æ£€æŸ¥å‡½æ•°ï¼š
/// *   `LetStmt(...)` -> `check_let_stmt(...)`
/// *   `LetMutStmt(...)` -> `check_let_mut_stmt(...)`
/// *   `AssignStmt(...)` -> `check_assign_stmt(...)`
/// *   `ExprStmt(expr)` -> `check_expr(expr)`
/// *   ...ç­‰ç­‰
///
/// ### â­ ç‰¹åˆ«å…³æ³¨ï¼š`ReturnStmt`
///
/// åœ¨å¤„ç† `ReturnStmt` æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å›žç­”ä¸€ä¸ªå…³é”®é—®é¢˜ï¼šå¦‚ä½•çŸ¥é“ `return` è¯­å¥çš„ç±»åž‹æ˜¯å¦æ­£ç¡®ï¼Ÿ
///
/// > æˆ‘ä»¬å¿…é¡»å°† `return` åŽé¢è¡¨è¾¾å¼çš„ç±»åž‹ä¸Ž**å½“å‰å‡½æ•°ç­¾åä¸­å£°æ˜Žçš„è¿”å›žç±»åž‹**è¿›è¡Œæ¯”è¾ƒã€‚
///
/// è¿™ä¸ªâ€œå½“å‰å‡½æ•°çš„è¿”å›žç±»åž‹â€ä¿¡æ¯å°±å­˜æ”¾åœ¨ `Context` ä¸­ã€‚æˆ‘ä»¬çº¦å®šä½¿ç”¨ `current_func_ret_ty: Option[TypeKind]` å­—æ®µæ¥è®°å½•å®ƒã€‚
///
/// *   å½“æ£€æŸ¥ `ReturnStmt(Some(expr))` æ—¶ï¼Œä½ éœ€è¦æ£€æŸ¥ `expr` çš„ç±»åž‹æ˜¯å¦ä¸Ž `self.current_func_ret_ty` å…¼å®¹ã€‚
/// *   å½“æ£€æŸ¥ `ReturnStmt(None)` æ—¶ï¼ˆå³ `return;`ï¼‰ï¼Œä½ éœ€è¦æ£€æŸ¥ `self.current_func_ret_ty` æ˜¯å¦ä¸º `Unit`ã€‚
/// *   å¦‚æžœ `self.current_func_ret_ty` æ˜¯ `None`ï¼Œè¯´æ˜Ž `return` è¯­å¥å‡ºçŽ°åœ¨äº†å‡½æ•°ä¹‹å¤–ï¼Œåº”è¯¥æŠ›å‡ºé”™è¯¯ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ç¬¬äºŒä¸ªä»»åŠ¡ï¼šå®žçŽ° `check_block_expr`
///
/// å®Œæˆäº† `check_stmt` åŽï¼Œä½ éœ€è¦åœ¨ `typecheck/block_expr.mbt` ä¸­å®žçŽ° `check_block_expr`ã€‚
///
/// ### ðŸ’¡ `check_block_expr` å®žçŽ°æ€è·¯
///
/// 1.  **å¤„ç†ä½œç”¨åŸŸï¼ˆScopingï¼‰ï¼š**
///     *   ä»£ç å— `{...}` ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸã€‚åœ¨å—å†…å®šä¹‰çš„å˜é‡ä¸åº”è¯¥â€œæ³„éœ²â€åˆ°å¤–éƒ¨ã€‚
///     *   åœ¨å¼€å§‹æ£€æŸ¥å—å†…è¯­å¥**ä¹‹å‰**ï¼Œè°ƒç”¨ `self.enter_scope()` æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡çŽ¯å¢ƒã€‚
///     *   åœ¨æ‰€æœ‰è¯­å¥æ£€æŸ¥å®Œæˆ**ä¹‹åŽ**ï¼Œå¿…é¡»è°ƒç”¨ `self.exit_scope()` æ¥é”€æ¯è¿™ä¸ªçŽ¯å¢ƒï¼Œæ¢å¤åˆ°ä¸Šä¸€å±‚ã€‚
///
/// 2.  **éåŽ†è¯­å¥ï¼š**
///     *   éåŽ†å—å†…çš„æ¯ä¸€æ¡è¯­å¥ï¼Œè°ƒç”¨ä½ åˆšåˆšå®Œæˆçš„ `self.check_stmt` æ¥æ£€æŸ¥å®ƒã€‚
///
/// 3.  **ç¡®å®šå—çš„ç±»åž‹ï¼š**
///     *   ä»£ç å—æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒæœ‰è‡ªå·±çš„ç±»åž‹ã€‚
///     *   è§„åˆ™æ˜¯ï¼šå—çš„ç±»åž‹å°±æ˜¯**æœ€åŽä¸€æ¡è¡¨è¾¾å¼è¯­å¥çš„ç±»åž‹**ã€‚
///     *   å¦‚æžœä»£ç å—ä¸ºç©ºï¼Œæˆ–è€…æœ€åŽä¸€æ¡è¯­å¥ä»¥åˆ†å·ç»“å°¾ï¼ˆå³ä¸æ˜¯è¡¨è¾¾å¼è¯­å¥ï¼‰ï¼Œé‚£ä¹ˆæ•´ä¸ªå—çš„ç±»åž‹å°±æ˜¯ `Unit`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_block_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Block Expr TypeCheck Test" {
  let code =
    #|let arr = [];
    #|
    #|{
    #|  let (x, y) = (1, 2);
    #|  let mut z = x + y;
    #|  z += 10;
    #|  arr.push(z);
    #|}
    #|
    #|{
    #|  let (x, y) = (1.0, 2.0);
    #|  let z = x * y;
    #|  let arr = [1.0, z, 5.0];
    #|  arr[2] = arr[1];
    #|  arr[2]
    #|}
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  let (let_stmt, tok_view) = @parser.parse_let_stmt(tokens[:])
  let _ = ctx.check_let_stmt(let_stmt)
  // TypeCheck first block expr
  let (block_expr1, tok_view) = @parser.parse_block_expr(tok_view)
  let checked_block1 = ctx.check_block_expr(block_expr1)
  assert_true(checked_block1.stmts.length() is 4)
  assert_true(checked_block1.ty is Unit)
  // TypeCheck second block expr
  let (block_expr2, _) = @parser.parse_block_expr(tok_view)
  let checked_block2 = ctx.check_block_expr(block_expr2)
  assert_true(checked_block2.stmts.length() is 5)
  assert_true(checked_block2.ty is Double)
  // TypeCheck third block expr (should raise type error)
  assert_true(ctx.lookup_type("arr") is Some({ kind: Array(Int), .. }))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¡¨è¾¾å¼ï¼šç»„åˆçš„åŠ›é‡
///
/// æˆ‘ä»¬å·²ç»ä¸º `check_expr` å’Œ `check_apply_expr` æ­å»ºäº†åŸºç¡€çš„æ¡†æž¶ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™ä¸º `check_apply_expr` æ·»åŠ å¤„ç†å¤æ‚ç»„åˆçš„èƒ½åŠ›äº†ï¼Œä¾‹å¦‚å‡½æ•°è°ƒç”¨ã€æ•°ç»„ç´¢å¼•å’Œå­—æ®µè®¿é—®ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®Œæˆ `check_apply_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯å›žåˆ° `typecheck/apply_expr.mbt` æ–‡ä»¶ï¼Œå®Œæˆ `Context::check_apply_expr` å‡½æ•°ä¸­å‰©ä½™çš„ `match` åˆ†æ”¯ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// `check_apply_expr` çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¾ªçŽ¯æˆ–é€’å½’ç»“æž„ï¼Œå®ƒé¦–å…ˆæ£€æŸ¥ä¸€ä¸ªåŸºç¡€è¡¨è¾¾å¼ï¼ˆ`AtomExpr`ï¼‰ï¼Œç„¶åŽä¸æ–­æ£€æŸ¥åŽé¢æ˜¯å¦è·Ÿéš `()`ã€`[]` æˆ– `.`ï¼Œå¹¶æŒç»­å°†è¡¨è¾¾å¼â€œåŒ…è£…â€æˆæ›´å¤æ‚çš„ `ApplyExpr`ã€‚
///
/// 1.  **`ArrayAccess(array_expr, index_expr)` (æ•°ç»„ç´¢å¼•)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `array_expr`ï¼Œå¹¶è°ƒç”¨ `check_expr` æ£€æŸ¥ `index_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š
///         *   `array_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Array[T]`ã€‚
///         *   `index_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Int`ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹æ˜¯æ•°ç»„çš„å…ƒç´ ç±»åž‹ `T`ã€‚
///
/// 2.  **`FieldAccess(struct_expr, field_name)` (å­—æ®µè®¿é—®)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `struct_expr`ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š`struct_expr` çš„ç±»åž‹å¿…é¡»æ˜¯æŸä¸ª `Struct(struct_name)`ã€‚
///     *   ä½ éœ€è¦ä»Ž `Context` çš„ `struct_defs` ä¸­æŸ¥æ‰¾è¯¥ç»“æž„ä½“çš„å®šä¹‰ï¼Œå¹¶æ‰¾åˆ° `field_name` å¯¹åº”çš„å­—æ®µç±»åž‹ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹å°±æ˜¯è¯¥å­—æ®µçš„ç±»åž‹ã€‚
///
/// 3.  **`Call(callee_expr, arg_exprs)` (å‡½æ•°è°ƒç”¨)**
///     *   é€’å½’è°ƒç”¨ `check_apply_expr` æ£€æŸ¥ `callee_expr`ï¼ˆè¢«è°ƒç”¨çš„å‡½æ•°ï¼‰ã€‚
///     *   **ç±»åž‹è§„åˆ™**ï¼š`callee_expr` çš„ç±»åž‹å¿…é¡»æ˜¯ `Function` ç±»åž‹ï¼Œä¾‹å¦‚ `Function([ArgT1, ArgT2], RetT)`ã€‚
///     *   éåŽ† `arg_exprs`ï¼Œå¯¹æ¯ä¸ªå‚æ•°è¡¨è¾¾å¼é€’å½’è°ƒç”¨ `check_expr`ã€‚
///     *   **å…³é”®ä¸€æ­¥**ï¼šæ£€æŸ¥æ¯ä¸ªä¼ å…¥å‚æ•°çš„ç±»åž‹æ˜¯å¦ä¸Žå‡½æ•°ç­¾åä¸­å¯¹åº”å‚æ•°çš„ç±»åž‹ `ArgT` **å…¼å®¹**ã€‚è¿™é‡Œéœ€è¦å¤§é‡ä½¿ç”¨ `is_type_compatible`ï¼Œå®ƒä¼šé©±åŠ¨æˆ‘ä»¬ä¸Šä¸€å…³å®žçŽ°çš„ç±»åž‹å˜é‡åˆä¸€ï¼ˆUnificationï¼‰é€»è¾‘ã€‚
///     *   å‚æ•°çš„æ•°é‡ä¹Ÿå¿…é¡»åŒ¹é…ã€‚
///     *   **è¿”å›žç±»åž‹**ï¼šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹æ˜¯å‡½æ•°ç­¾åçš„è¿”å›žç±»åž‹ `RetT`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// æœ¬æ¬¡æµ‹è¯•åŒ…å«äº†å¤šç§å¤æ‚çš„è¡¨è¾¾å¼ç»„åˆï¼Œå°†å…¨é¢è€ƒéªŒä½ çš„ `check_apply_expr` å®žçŽ°ã€‚
///
/// ```bash
/// moon test -p typecheck -f typecheck_expr_test.mbt
/// ```
/// ================================================================================

///|
test "Expr TypeCheck Test" {
  let code =
    #|arr[3] + arr[5] ; fact(5) + fib(10) ; print_string("Hello, World!");
    #|mat.data[3][4] ; sum(arr); 3.0 > max(x, y);
  let ctx = Context::new()
  ctx.struct_defs.set("Matrix", StructDef::{
    name: "Matrix",
    fields: [{ name: "data", ty: { kind: Array(Array(Int)), mutable: false } }],
    methods: Map::new(),
  })
  ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  ctx.type_env.set("mat", { kind: Struct("Matrix"), mutable: false })
  // Note: Matrix struct has a field `data` of type Array(Array(Int))
  ctx.type_env.set("fact", { kind: Function([TypeVar(0)], Int), mutable: false })
  ctx.type_env.set("fib", { kind: Function([Int], Int), mutable: false })
  ctx.type_env.set("print_string", {
    kind: Function([String], Unit),
    mutable: false,
  })
  ctx.type_env.set("sum", { kind: Function([Array(Int)], Int), mutable: false })
  // Note: max is local function without type annotations
  ctx.type_env.set("max", {
    kind: Function([TypeVar(1), TypeVar(2)], TypeVar(3)),
    mutable: false,
  })
  ctx.type_env.set("x", { kind: Double, mutable: true })
  ctx.type_env.set("y", { kind: Double, mutable: true })
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_vars.set(2, TypeVar(1))
  ctx.type_vars.set(3, TypeVar(1))

  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of arr[3] + arr[5]
  let (a, tok_view) = @parser.parse_expr(tokens[:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of fact(5) + fib(10)
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of print_string("Hello, World!")
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Unit)
  // Type of mat.data[3][4]
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of sum(arr)
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of 3.0 > max(x, y)
  let (a, _) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  assert_true(ctx.lookup_type("x") is Some({ kind: Double, .. }))
  assert_true(ctx.lookup_type("y") is Some({ kind: Double, .. }))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥æŽ§åˆ¶æµï¼šif-else è¡¨è¾¾å¼
///
/// `if-else` æ˜¯æˆ‘ä»¬è¯­è¨€ä¸­ç¬¬ä¸€ä¸ªçœŸæ­£çš„æŽ§åˆ¶æµç»“æž„ã€‚åœ¨ MiniMoonBit ä¸­ï¼Œ`if-else` è‡ªèº«ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒå¯ä»¥äº§ç”Ÿä¸€ä¸ªå€¼ã€‚
/// ç±»åž‹æ£€æŸ¥å™¨å¿…é¡»ä¿è¯å®ƒçš„é€»è¾‘æ˜¯å¥å…¨çš„ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_if_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/if_expr.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_if_expr` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// æ£€æŸ¥ `if-else` è¡¨è¾¾å¼éœ€è¦éµå¾ªå‡ æ¡æ ¸å¿ƒè§„åˆ™ï¼š
///
/// 1.  **æ£€æŸ¥æ¡ä»¶ï¼š**
///     *   `if` åŽé¢çš„æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»æ˜¯ä¸€ä¸ª `Bool` ç±»åž‹ã€‚ä½ éœ€è¦é¦–å…ˆè°ƒç”¨ `check_expr` æ£€æŸ¥æ¡ä»¶ï¼Œå¹¶éªŒè¯å…¶ç±»åž‹ã€‚
///
/// 2.  **æ£€æŸ¥ `then` åˆ†æ”¯ï¼š**
///     *   è°ƒç”¨ `check_block_expr` æ¥æ£€æŸ¥ `then` ä»£ç å—ï¼Œå¹¶è®°å½•ä¸‹å®ƒçš„ç±»åž‹ `T_then`ã€‚
///
/// 3.  **æ£€æŸ¥ `else` åˆ†æ”¯ï¼š**
///     *   **å¦‚æžœå­˜åœ¨ `else` åˆ†æ”¯**ï¼ˆæ— è®ºæ˜¯ `else if` è¿˜æ˜¯ `else`ï¼‰ï¼š
///         *   ä½ éœ€è¦é€’å½’åœ°æ£€æŸ¥ `else` åˆ†æ”¯ï¼ˆè°ƒç”¨ `check_if_expr` æˆ– `check_block_expr`ï¼‰ï¼Œå¹¶èŽ·å¾—å…¶ç±»åž‹ `T_else`ã€‚
///         *   **æ ¸å¿ƒè§„åˆ™ï¼š** `then` åˆ†æ”¯çš„ç±»åž‹ `T_then` å¿…é¡»ä¸Ž `else` åˆ†æ”¯çš„ç±»åž‹ `T_else` å…¼å®¹ã€‚ä½ éœ€è¦è°ƒç”¨ `self.is_type_compatible(T_then, T_else)`ã€‚
///         *   **è¡¨è¾¾å¼ç±»åž‹ï¼š** æ•´ä¸ª `if-else` è¡¨è¾¾å¼çš„ç±»åž‹å°±æ˜¯ `T_then`ï¼ˆåœ¨åˆä¸€åŽå¯èƒ½è¢«æ›´æ–°çš„ `T_then`ï¼‰ã€‚
///
///     *   **å¦‚æžœä¸å­˜åœ¨ `else` åˆ†æ”¯**ï¼š
///         *   è¿™æ„å‘³ç€ `if` è¡¨è¾¾å¼åœ¨æ¡ä»¶ä¸º `false` æ—¶ä¸äº§ç”Ÿä»»ä½•å€¼ã€‚
///         *   **æ ¸å¿ƒè§„åˆ™ï¼š** åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ•´ä¸ª `if` è¡¨è¾¾å¼çš„ç±»åž‹è¢«å®šä¸º `Unit`ã€‚
///         *   è¿™ä¹Ÿåè¿‡æ¥å¯¹ `then` åˆ†æ”¯æ–½åŠ äº†ä¸€ä¸ªçº¦æŸï¼šå®ƒçš„ç±»åž‹ `T_then` å¿…é¡»ä¸Ž `Unit` å…¼å®¹ã€‚ä¸€ä¸ªè¿”å›ž `Int` çš„ `then` åˆ†æ”¯ä¸èƒ½åœ¨æ²¡æœ‰ `else` çš„æƒ…å†µä¸‹ç‹¬ç«‹å­˜åœ¨ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_if_expr_test.mbt
/// ```
/// ================================================================================

///|
test "If Expr TypeCheck Test" {
  let code =
    #|let arr = [];
    #|
    #|if a > b {
    #|  arr.push(1);
    #|} else {
    #|  arr.push(2);
    #|}
    #|
    #|if a < b {
    #|  arr.push(a);
    #|  a
    #|}else if a == b {
    #|  arr.push(1);
    #|  a - b
    #|} else {
    #|  arr.push(b);
    #|  b
    #|}
    #|
  let ctx = Context::new()
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_env.set("a", { kind: TypeVar(0), mutable: false })
  ctx.type_env.set("b", { kind: TypeVar(1), mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  let (let_stmt, tok_view) = @parser.parse_let_stmt(tokens[:])
  let _ = ctx.check_let_stmt(let_stmt)
  // TypeCheck first if expr
  let (if_expr1, tok_view) = @parser.parse_if_expr(tok_view)
  let checked_if1 = ctx.check_if_expr(if_expr1)
  assert_true(checked_if1.ty is Unit)
  assert_true(ctx.lookup_type("arr") is Some({ kind: Array(Int), .. }))
  // TypeCheck second if expr
  let (if_expr2, _) = @parser.parse_if_expr(tok_view)
  let checked_if2 = ctx.check_if_expr(if_expr2)
  assert_true(checked_if2.ty is Int)
  assert_true(ctx.lookup_type("a") is Some({ kind: Int, .. }))
  assert_true(ctx.lookup_type("b") is Some({ kind: Int, .. }))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¯­å¥ï¼šlet mut
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿæ£€æŸ¥å„ç§å¤æ‚çš„è¡¨è¾¾å¼äº†ã€‚çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å°†ç›®å…‰è½¬å‘**è¯­å¥ï¼ˆStatementsï¼‰**çš„ç±»åž‹æ£€æŸ¥äº†ã€‚
///
/// è¯­å¥ä¸Žè¡¨è¾¾å¼çš„æ ¸å¿ƒåŒºåˆ«åœ¨äºŽï¼šè¯­å¥ä¸ä¸€å®šæœ‰â€œå€¼â€ï¼Œä½†å®ƒä»¬é€šå¸¸ä¼šäº§ç”Ÿ**å‰¯ä½œç”¨ï¼ˆSide Effectsï¼‰**ã€‚
/// åœ¨ç±»åž‹æ£€æŸ¥ä¸­ï¼Œæœ€é‡è¦çš„å‰¯ä½œç”¨å°±æ˜¯**æ”¹å˜ç±»åž‹çŽ¯å¢ƒï¼ˆType Environmentï¼‰**ã€‚
///
/// `let mut` è¯­å¥å°±æ˜¯ä¸€ä¸ªå…¸åž‹çš„ä¾‹å­ï¼Œå®ƒä¼šå‘å½“å‰ä½œç”¨åŸŸå¼•å…¥ä¸€ä¸ªæ–°çš„å¯å˜å˜é‡ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_let_mut_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/let_mut_stmt.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_let_mut_stmt` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// `check_let_mut_stmt` çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š
///
/// 1.  **æ£€æŸ¥è¡¨è¾¾å¼ï¼š** é¦–å…ˆï¼Œè°ƒç”¨ `self.check_expr` æ¥ç¡®å®š `=` å³ä¾§è¡¨è¾¾å¼çš„ç±»åž‹ã€‚
///
/// 2.  **å¤„ç†ç±»åž‹æ³¨è§£ï¼ˆå¦‚æžœå­˜åœ¨ï¼‰ï¼š**
///     *   `let mut` è¯­å¥å¯èƒ½å¸¦æœ‰æ˜¾å¼çš„ç±»åž‹æ³¨è§£ï¼Œä¾‹å¦‚ `let mut x: Double = ...`ã€‚
///     *   å¦‚æžœå­˜åœ¨ç±»åž‹æ³¨è§£ï¼Œä½ éœ€è¦è°ƒç”¨ `self.check_parser_type` æ¥è½¬æ¢å®ƒã€‚
///     *   ç„¶åŽï¼Œ**å…³é”®ä¸€æ­¥**ï¼šä½¿ç”¨ `self.is_type_compatible` éªŒè¯è¡¨è¾¾å¼çš„ç±»åž‹æ˜¯å¦ä¸Žæ³¨è§£çš„ç±»åž‹å…¼å®¹ã€‚å¦‚æžœä¸å…¼å®¹ï¼Œåˆ™åº”æŠ›å‡ºç±»åž‹é”™è¯¯ã€‚
///
/// 3.  **ç¡®å®šå˜é‡ç±»åž‹ï¼š**
///     *   å¦‚æžœå­˜åœ¨ç±»åž‹æ³¨è§£ï¼Œå˜é‡çš„ç±»åž‹å°±æ˜¯è¯¥æ³¨è§£çš„ç±»åž‹ã€‚
///     *   å¦‚æžœä¸å­˜åœ¨ï¼Œå˜é‡çš„ç±»åž‹å°±ä»Žè¡¨è¾¾å¼çš„ç±»åž‹ä¸­**æŽ¨æ–­**å‡ºæ¥ã€‚
///
/// 4.  **æ›´æ–°ç±»åž‹çŽ¯å¢ƒï¼š**
///     *   è¿™æ˜¯æœ€é‡è¦çš„ä¸€æ­¥ï¼ä¸€æ—¦ç¡®å®šäº†æ–°å˜é‡çš„åç§°å’Œç±»åž‹ï¼Œä½ å¿…é¡»å°†å®ƒæ·»åŠ åˆ°ç±»åž‹çŽ¯å¢ƒ `self.type_env` ä¸­ã€‚
///     *   åœ¨æ·»åŠ åˆ°çŽ¯å¢ƒæ—¶ï¼Œè¯·åŠ¡å¿…æ ‡è®°è¯¥ç±»åž‹ä¸º**å¯å˜çš„ï¼ˆmutable: trueï¼‰**ã€‚è¿™å¯¹äºŽåŽç»­çš„èµ‹å€¼è¯­å¥æ£€æŸ¥è‡³å…³é‡è¦ã€‚
///
/// ### ðŸ¤” æ·±å…¥æ€è€ƒï¼šç©ºæ•°ç»„çš„ç±»åž‹æŽ¨æ–­
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„æµ‹è¯•ç”¨ä¾‹åŒ…å« `let mut z = []`ã€‚
///
/// > å½“æˆ‘ä»¬çœ‹åˆ°ä¸€ä¸ªç©ºæ•°ç»„æ—¶ï¼Œå®ƒçš„å…ƒç´ ç±»åž‹æ˜¯ä»€ä¹ˆï¼Ÿ`Int`? `String`?
///
/// åœ¨è¿™ä¸€åˆ»ï¼Œæˆ‘ä»¬**æ— æ³•çŸ¥é“**ã€‚è¿™å°±æ˜¯**ç±»åž‹å˜é‡ï¼ˆType Variableï¼‰**ç™»åœºçš„æ—¶æœºã€‚
/// å½“é‡åˆ°æ— æ³•ç«‹å³ç¡®å®šçš„ç±»åž‹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„â€œå ä½ç¬¦â€ç±»åž‹ï¼Œä¾‹å¦‚ `Array(TypeVar(0))`ã€‚
///
/// åœ¨åŽç»­ä»£ç ä¸­ï¼Œå½“æˆ‘ä»¬ç¬¬ä¸€æ¬¡å¯¹ `z` è¿›è¡Œæ“ä½œæ—¶ï¼ˆä¾‹å¦‚ `z.push(3.14)`ï¼‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°† `TypeVar(0)` çš„å®žé™…ç±»åž‹â€œç»‘å®šâ€ä¸º `Double`ã€‚
/// è¿™å°±æ˜¯ç±»åž‹æŽ¨æ–­çš„æ ¸å¿ƒæ€æƒ³ä¹‹ä¸€ã€‚ä½ çš„ `check_array_expr` å‡½æ•°å¯èƒ½éœ€è¦æ”¯æŒè¿™ç§è¡Œä¸ºã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_let_mut_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "Let Mut Stmt Type Check" {
  let code =
    #|let mut x : Double = 42.0;
    #|let mut y = 10;
    #|let mut z = [];
    #|let _ = z.push(3.14);
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type check for `let mut x : Double = 42.0;`
  let (let_mut_stmt1, tok_view) = @parser.parse_let_mut_stmt(tokens[:])
  let checked_let_mut_stmt1 = ctx.check_let_mut_stmt(let_mut_stmt1)
  assert_true(checked_let_mut_stmt1.ty is Double)
  // Type check for `let mut y = 10;`
  let (let_mut_stmt2, tok_view) = @parser.parse_let_mut_stmt(tok_view)
  let checked_let_mut_stmt2 = ctx.check_let_mut_stmt(let_mut_stmt2)
  assert_true(checked_let_mut_stmt2.ty is Int)
  // Type check for `let mut z = [];`
  let (let_mut_stmt3, tok_view) = @parser.parse_let_mut_stmt(tok_view)
  let checked_let_mut_stmt3 = ctx.check_let_mut_stmt(let_mut_stmt3)
  assert_true(checked_let_mut_stmt3.ty is Array(TypeVar(_)))
  // Type check for `let _ = z.push(3.14);`
  // Parse Let Stmt
  let (let_stmt4, _) = @parser.parse_let_stmt(tok_view)
  let checked_let_stmt4 = ctx.check_let_stmt(let_stmt4)
  assert_true(checked_let_stmt4.ty is Unit)
  assert_true(ctx.lookup_type("z") is Some({ kind: Array(Double), .. }))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¯­å¥ï¼šlet ä¸Žæ¨¡å¼åŒ¹é…
///
/// æˆ‘ä»¬å·²ç»å¤„ç†äº† `let mut` å’Œé¡¶å±‚çš„ `let`ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ¥å¤„ç†å‡½æ•°ä½“å†…éƒ¨æœ€å¸¸è§çš„ `let` è¯­å¥ã€‚
///
/// å®ƒä¸Žæˆ‘ä»¬ä¹‹å‰å®žçŽ°çš„ `let` æ£€æŸ¥æœ€å¤§çš„ä¸åŒåœ¨äºŽï¼š**å·¦ä¾§å¯ä»¥æ˜¯ä¸€ä¸ªå¤æ‚çš„æ¨¡å¼ï¼ˆPatternï¼‰**ã€‚
///
/// ```moonbit
/// let (a, (b, c)) = (1, (true, "hello"));
/// ```
///
/// ç±»åž‹æ£€æŸ¥å™¨éœ€è¦èƒ½å¤Ÿâ€œè§£å¼€â€ç­‰å·ä¸¤è¾¹çš„ç»“æž„ï¼Œå¹¶å°†å³ä¾§å€¼çš„ç±»åž‹æ­£ç¡®åœ°èµ‹äºˆå·¦ä¾§æ¨¡å¼ä¸­çš„æ¯ä¸€ä¸ªå˜é‡ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_let_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/let_stmt.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_let_stmt` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// 1.  **æ£€æŸ¥è¡¨è¾¾å¼ç±»åž‹ï¼š** å’Œä¹‹å‰ä¸€æ ·ï¼Œé¦–å…ˆè°ƒç”¨ `check_expr` èŽ·å¾— `=` å³ä¾§è¡¨è¾¾å¼çš„ç±»åž‹ `T`ã€‚
///
/// 2.  **å¤„ç†ç±»åž‹æ³¨è§£ï¼š** å¦‚æžœ `let` è¯­å¥å¸¦æœ‰ç±»åž‹æ³¨è§£ï¼ˆä¾‹å¦‚ `let (a, b): (Int, Int) = ...`ï¼‰ï¼Œåˆ™éœ€è¦æ£€æŸ¥è¡¨è¾¾å¼ç±»åž‹ `T` æ˜¯å¦ä¸Žè¯¥æ³¨è§£å…¼å®¹ã€‚
///
/// 3.  **ç»‘å®šæ¨¡å¼ä¸Žç±»åž‹ï¼ˆæ ¸å¿ƒï¼ï¼‰ï¼š**
///     *   è¿™æ˜¯æœ¬æ¬¡æŒ‘æˆ˜æœ€æ ¸å¿ƒçš„éƒ¨åˆ†ã€‚ä½ éœ€è¦å°†å·¦ä¾§çš„ `pattern` å’Œå³ä¾§çš„ç±»åž‹ `T` è¿›è¡ŒåŒ¹é…å’Œç»‘å®šã€‚
///     *   å»ºè®®ä¸ºæ­¤å®žçŽ°ä¸€ä¸ªå•ç‹¬çš„è¾…åŠ©å‡½æ•°ï¼Œä¾‹å¦‚ `bind_pattern_type(pattern: Pattern, ty: TypeKind)`ã€‚
///     *   è¿™ä¸ªå‡½æ•°éœ€è¦é€’å½’åœ°å¤„ç†æ¨¡å¼ï¼š
///         *   **`Ident(name)`ï¼š** æœ€ç®€å•çš„æƒ…å†µã€‚å°† `name` å’Œç±»åž‹ `ty` æ·»åŠ åˆ°ç±»åž‹çŽ¯å¢ƒä¸­ï¼ˆæ³¨æ„æ˜¯**ä¸å¯å˜**çš„ `mutable: false`ï¼‰ã€‚
///         *   **`Wildcard` (`_`)ï¼š** å¿½ç•¥å³å¯ï¼Œå®ƒä¸å¼•å…¥ä»»ä½•æ–°çš„å˜é‡ç»‘å®šã€‚
///         *   **`Tuple(sub_patterns)`ï¼š** è¿™æ˜¯é€’å½’çš„å…³é”®ã€‚
///             *   é¦–å…ˆï¼Œæ£€æŸ¥ç±»åž‹ `ty` æ˜¯å¦ä¹Ÿæ˜¯ä¸€ä¸ªå…ƒç»„ç±»åž‹ `Tuple(element_types)`ã€‚å¦‚æžœä¸æ˜¯ï¼ˆä¾‹å¦‚ï¼Œè¯•å›¾ç”¨å…ƒç»„æ¨¡å¼åŒ¹é…ä¸€ä¸ª `Int`ï¼‰ï¼Œåˆ™æŠ›å‡ºç±»åž‹é”™è¯¯ã€‚
///             *   ç„¶åŽï¼Œæ£€æŸ¥æ¨¡å¼å’Œç±»åž‹çš„é•¿åº¦æ˜¯å¦ä¸€è‡´ã€‚
///             *   æœ€åŽï¼ŒéåŽ† `sub_patterns` å’Œ `element_types`ï¼Œå¯¹æ¯ä¸€å¯¹ `(sub_pattern, element_type)` **é€’å½’è°ƒç”¨ `bind_pattern_type`**ã€‚
///
/// é€šè¿‡è¿™ç§æ–¹å¼ï¼Œä½ å¯ä»¥ä¼˜é›…åœ°å°†ä»»æ„å¤æ‚çš„ç±»åž‹â€œè§£æž„â€å¹¶ç»‘å®šåˆ°å¯¹åº”çš„å˜é‡ä¸Šã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_let_stmt_test.mbt
/// ```
///
/// æ­å–œä½ ï¼å®Œæˆè¿™ä¸€æ­¥ï¼Œä½ çš„ç±»åž‹æ£€æŸ¥å™¨å°±å‡ ä¹Žæ‹¥æœ‰å¤„ç†æ‰€æœ‰æ ¸å¿ƒè¯­è¨€ç‰¹æ€§çš„èƒ½åŠ›äº†ï¼
/// ================================================================================

///|
test "Let Stmt Type Check" {
  let code =
    #|let x : Double = 42.0;
    #|let (x, y) = (1, 2);
    #|let z = [];
    #|let mat = [[1, 2], z];
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type check for `let x : Int = 42;`
  let (let_stmt1, tok_view) = @parser.parse_let_stmt(tokens[:])
  let checked_let_stmt1 = ctx.check_let_stmt(let_stmt1)
  assert_true(checked_let_stmt1.ty is Double)
  // Type check for `let (x, y) = (1, 2);`
  let (let_stmt2, tok_view) = @parser.parse_let_stmt(tok_view)
  let checked_let_stmt2 = ctx.check_let_stmt(let_stmt2)
  assert_true(checked_let_stmt2.ty is Tuple([Int, Int]))
  assert_true(ctx.lookup_type("x") is Some({ kind: Int, .. }))
  assert_true(ctx.lookup_type("y") is Some({ kind: Int, .. }))
  // Type check for `let z = [];`
  let (let_stmt3, tok_view) = @parser.parse_let_stmt(tok_view)
  let checked_let_stmt3 = ctx.check_let_stmt(let_stmt3)
  assert_true(checked_let_stmt3.ty is Array(TypeVar(_)))
  // Type check for `let mat = [[1, 2], z];`
  let (let_stmt4, _) = @parser.parse_let_stmt(tok_view)
  let checked_let_stmt4 = ctx.check_let_stmt(let_stmt4)
  assert_true(checked_let_stmt4.ty is Array(Array(Int)))
  assert_true(ctx.lookup_type("mat") is Some({ kind: Array(Array(Int)), .. }))
  let zty = ctx.lookup_type("z")
  assert_true(
    ctx.lookup_type("z") is Some({ kind: Array(Int), .. }),
    msg="Type of z is \{zty}",
  )
}
/// ================================================================================
/// # ç»ˆæžæŒ‘æˆ˜ï¼šç±»åž‹æ£€æŸ¥å±€éƒ¨å‡½æ•°ä¸Žé—­åŒ…
///
/// æ¬¢è¿Žæ¥åˆ°ç±»åž‹æ£€æŸ¥é˜¶æ®µæœ€å…·æŒ‘æˆ˜æ€§ã€ä¹Ÿæœ€è§åŠŸåŠ›çš„éƒ¨åˆ†ï¼š**æ£€æŸ¥å±€éƒ¨å‡½æ•°ï¼ˆLocal Functionsï¼‰**ã€‚
///
/// ä¸Žå¿…é¡»æ˜Žç¡®æ ‡æ³¨æ‰€æœ‰ç±»åž‹çš„é¡¶å±‚å‡½æ•°ä¸åŒï¼Œå±€éƒ¨å‡½æ•°å…è®¸çœç•¥ç±»åž‹ï¼Œè¿™å°±è¦æ±‚æˆ‘ä»¬çš„ç¼–è¯‘å™¨å…·å¤‡çœŸæ­£çš„**ç±»åž‹æŽ¨æ–­**èƒ½åŠ›ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_local_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/local_function.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_local_function` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯ï¼šç«‹å³æ£€æŸ¥ä¸Žåˆä¸€
///
/// æ£€æŸ¥ä¸€ä¸ªå±€éƒ¨å‡½æ•° `fn f(a, b: T) { ... }` çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š
///
/// 1.  **åˆ›å»ºå‡½æ•°ç±»åž‹ï¼š**
///     *   éåŽ†å‡½æ•°çš„å‚æ•°åˆ—è¡¨ã€‚
///     *   å¦‚æžœå‚æ•°æœ‰ç±»åž‹æ³¨è§£ï¼ˆå¦‚ `b: T`ï¼‰ï¼Œåˆ™è½¬æ¢è¯¥ç±»åž‹ã€‚
///     *   å¦‚æžœå‚æ•°æ²¡æœ‰ç±»åž‹æ³¨è§£ï¼ˆå¦‚ `a`ï¼‰ï¼Œåˆ™**åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»åž‹å˜é‡ `TypeVar`** ä½œä¸ºå…¶ç±»åž‹çš„å ä½ç¬¦ã€‚
///     *   å¯¹è¿”å›žå€¼æ‰§è¡ŒåŒæ ·çš„æ“ä½œï¼šæœ‰æ³¨è§£åˆ™ä½¿ç”¨ï¼Œæ— æ³¨è§£åˆ™åˆ›å»º `TypeVar`ã€‚
///     *   å°†è¿™äº›å‚æ•°ç±»åž‹å’Œè¿”å›žç±»åž‹ç»„åˆæˆä¸€ä¸ª `Function` ç±»åž‹ã€‚ä¾‹å¦‚ `fn f(a, b: Int)` çš„ç±»åž‹å°±æ˜¯ `Function([TypeVar(0), Int], TypeVar(1))`ã€‚
///
/// 2.  **æ›´æ–°çŽ¯å¢ƒï¼ˆä¸´æ—¶ï¼‰ï¼š**
///     *   å°†è¿™ä¸ªæ–°åˆ›å»ºçš„ã€å¯èƒ½åŒ…å« `TypeVar` çš„å‡½æ•°ç±»åž‹ï¼Œä¸Žå…¶åå­— `f` ä¸€èµ·ï¼Œæ·»åŠ åˆ°**å½“å‰**çš„ç±»åž‹çŽ¯å¢ƒä¸­ã€‚è¿™ä½¿å¾—å‡½æ•°å¯ä»¥é€’å½’åœ°è°ƒç”¨è‡ªå·±ã€‚
///
/// 3.  **æ£€æŸ¥å‡½æ•°ä½“ï¼ˆç«‹å³æ‰§è¡Œï¼ï¼‰ï¼š**
///     *   **è¿›å…¥æ–°ä½œç”¨åŸŸï¼š** è°ƒç”¨ `enter_scope()`ã€‚
///     *   **è®¾ç½®è¿”å›žç±»åž‹ï¼š** å°† `Context` çš„ `current_func_ret_ty` è®¾ç½®ä¸ºåˆšåˆšåˆ›å»ºçš„å‡½æ•°è¿”å›žç±»åž‹ï¼ˆå¯èƒ½æ˜¯ `TypeVar`ï¼‰ã€‚
///     *   **æ·»åŠ å‚æ•°åˆ°çŽ¯å¢ƒï¼š** å°†æ‰€æœ‰å‚æ•°ï¼ˆåŒ…æ‹¬ç±»åž‹ä¸º `TypeVar` çš„å‚æ•°ï¼‰æ·»åŠ åˆ°è¿™ä¸ªæ–°çš„ä½œç”¨åŸŸä¸­ã€‚
///     *   **æ£€æŸ¥å‡½æ•°ä½“ï¼š** è°ƒç”¨ `check_block_expr` æ£€æŸ¥å‡½æ•°ä½“ã€‚åœ¨æ£€æŸ¥è¿‡ç¨‹ä¸­ï¼Œ`is_type_compatible` ä¼šè¢«å¤§é‡è°ƒç”¨ï¼Œé©±åŠ¨ç±»åž‹å˜é‡çš„**åˆä¸€**ï¼ˆUnificationï¼‰ï¼Œä»Žè€ŒæŽ¨æ–­å‡ºå…·ä½“ç±»åž‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æžœå‡½æ•°ä½“ä¸­æœ‰ `a > b`ï¼Œé‚£ä¹ˆ `a` å’Œ `b` çš„ç±»åž‹å˜é‡å°±ä¼šè¢«åˆä¸€ã€‚
///     *   **éªŒè¯è¿”å›žç±»åž‹ï¼š** æ£€æŸ¥å‡½æ•°ä½“çš„æœ€ç»ˆç±»åž‹æ˜¯å¦ä¸Žå‡½æ•°çš„è¿”å›žç±»åž‹å…¼å®¹ã€‚
///     *   **ç¦»å¼€ä½œç”¨åŸŸï¼š** è°ƒç”¨ `exit_scope()`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_local_func_test.mbt
/// ```
/// ================================================================================

///|
test "Local Function Type Check Test" {
  let code =
    #|fn max(a, b) {
    #|  if a > b { a } else { b }
    #|}
    #|
    #|let _ = max(10, 20);
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  let (local_func, tok_view) = @parser.parse_local_function(tokens[:])
  // TypeCheck
  let _ = ctx.check_local_function(local_func)
  // parse and check let statement
  let (let_stmt, _) = @parser.parse_let_stmt(tok_view)
  let let_stmt = ctx.check_let_stmt(let_stmt)
  assert_true(let_stmt.ty is Int)
}
/// ================================================================================
/// # ç¬¬ä¸‰æŒ‘æˆ˜ï¼šç±»åž‹æ£€æŸ¥å™¨ï¼ˆType Checkerï¼‰
///
/// æ­å–œä½ å®Œæˆäº†è¯­æ³•åˆ†æžï¼ä½ å·²ç»æ‹¥æœ‰äº†ç¼–è¯‘å™¨å†’é™©çš„ç¬¬äºŒæŠŠé’¥åŒ™â€”â€”æŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰ã€‚
/// çŽ°åœ¨ï¼Œæˆ‘ä»¬å°†èµ‹äºˆè¿™äº›ç»“æž„ä»¥â€œæ„ä¹‰â€ï¼š**ç±»åž‹æ£€æŸ¥ï¼ˆType Checkingï¼‰**ã€‚
///
/// ---
///
/// ## ç±»åž‹æ£€æŸ¥ï¼ˆType Checkingï¼‰ï¼šèµ‹äºˆç»“æž„ä»¥æ„ä¹‰
///
/// ç±»åž‹æ£€æŸ¥å™¨æ˜¯ç¼–è¯‘å™¨çš„â€œå®ˆæŠ¤è€…â€ã€‚å®ƒçš„ä½¿å‘½æ˜¯ç¡®ä¿ä»£ç åœ¨è¯­ä¹‰ä¸Šæ˜¯æ­£ç¡®çš„ï¼Œ
/// å³å˜é‡å’Œè¡¨è¾¾å¼çš„ç±»åž‹ç¬¦åˆé¢„æœŸã€‚
///
/// **ä¾‹å¦‚ï¼Œå¯¹äºŽä»¥ä¸‹ä»£ç ç‰‡æ®µï¼š**
///
/// ```
/// let triangle_area = base * height / 2.0;
/// ```
///
/// ç±»åž‹æ£€æŸ¥å™¨éœ€è¦ç¡®ä¿ï¼š
///
/// - `base` å’Œ `height` æ˜¯Doubleç±»åž‹
/// - ä¹˜æ³•å’Œé™¤æ³•æ“ä½œç¬¦é€‚ç”¨äºŽDoubleç±»åž‹
/// - æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æžœä¹Ÿæ˜¯Doubleç±»åž‹
/// - å˜é‡ `triangle_area` è¢«æ­£ç¡®åœ°æŽ¨æ–­ä¸ºDoubleç±»åž‹
///
/// å¦‚æžœç±»åž‹æ£€æŸ¥å™¨å‘çŽ°ä»»ä½•ä¸åŒ¹é…çš„ç±»åž‹ï¼ˆä¾‹å¦‚ï¼Œå°†å­—ç¬¦ä¸²ä¸Žæ•´æ•°ç›¸ä¹˜ï¼‰ï¼Œ
/// å®ƒå°†æŠ›å‡ºé”™è¯¯ï¼Œé˜»æ­¢ç¼–è¯‘è¿‡ç¨‹ç»§ç»­è¿›è¡Œã€‚
///
/// åœ¨å·¥ä¸šçº§ç¼–è¯‘å™¨ä¸­ï¼Œè¿˜ä¼šç»™å‡ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ï¼Œå¸®åŠ©å¼€å‘è€…å®šä½å’Œä¿®å¤ç±»åž‹é”™è¯¯ã€‚
///
/// ä¼˜ç§€çš„ç±»åž‹æ£€æŸ¥å™¨èƒ½å¤Ÿå¤§å¹…æå‡ä»£ç çš„å¯é æ€§å’Œå®‰å…¨æ€§ï¼Œä¸Žæ­¤åŒæ—¶ï¼Œä¹Ÿæ˜¯å­¦æœ¯ç ”ç©¶çš„çƒ­é—¨é¢†åŸŸã€‚
///
/// åœ¨æˆ‘ä»¬çš„MiniMoonBitç¼–è¯‘å™¨ä¸­ï¼Œæ‰€è®¾è®¡çš„ç±»åž‹ç³»ç»Ÿç›¸å¯¹ç®€å•ï¼Œä¸»è¦æ˜¯æ²¡æœ‰æ³›åž‹ï¼Œä½†ä¾ç„¶æœ‰ä¸€å®šçš„æŒ‘æˆ˜æ€§ã€‚
///
/// ä¾‹å¦‚ï¼ŒMiniMoonBitæ”¯æŒå¯¹letè¯­å¥ä¸è¿›è¡Œæ˜¾å¼ç±»åž‹å£°æ˜Žï¼š
///
/// ```
/// let a = 42; // aè¢«æŽ¨æ–­ä¸ºIntç±»åž‹
/// ```
///
/// å†æ¯”å¦‚ï¼ŒMiniMoonBitæ”¯æŒå®šä¹‰é—­åŒ…ï¼Œä¸”å¯ä»¥ä¸è¿›è¡Œæ˜¾å¼ç±»åž‹å£°æ˜Žï¼š
///
/// ```
/// fn max(x, y) { if x > y { x } else { y } }
/// ...
/// let _ = max(10, 20); // ç›´åˆ°è¿™ä¸€å¥ï¼Œmaxæ‰è¢«æŽ¨æ–­ä¸º (Int, Int) -> Int ç±»åž‹
/// ```
///
/// é‚£ä¹ˆï¼Œç±»åž‹æ£€æŸ¥å™¨ï¼Œåˆ°åº•è¦å¦‚ä½•å®žçŽ°å‘¢ï¼Ÿ
///
/// æˆ‘ä»¬è¿™ä¸€ç« ï¼Œå°±æ¥å¸¦ä½ ä¸€æ­¥ä¸€æ­¥åœ°å®žçŽ°ä¸€ä¸ªç®€å•çš„ç±»åž‹æ£€æŸ¥å™¨ï¼
/// 
/// ---
///
/// ## ðŸŽ¯ ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼šè½¬æ¢ç±»åž‹è¡¨ç¤º
///
/// æˆ‘ä»¬çš„ç±»åž‹æ£€æŸ¥å™¨ä¹Ÿéœ€è¦æœ‰è‡ªå·±çš„ç±»åž‹è¡¨ç¤ºã€‚
/// ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå°±æ˜¯å®žçŽ°ä¸€ä¸ªè½¬æ¢å‡½æ•°ï¼Œå°† `Parser` è§£æžå‡ºçš„ç±»åž‹ï¼Œè½¬æ¢ä¸º `TypeChecker` å†…éƒ¨çš„ç±»åž‹è¡¨ç¤ºã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// 1.  **å¯¹æ¯”ç±»åž‹å®šä¹‰ï¼š**
///     *   è¯·æ‰“å¼€ `parser/typedef.mbt` å’Œ `typecheck/typedef.mbt`ã€‚
///     *   ä½ ä¼šå‘çŽ° `parser::TypeKind` å’Œ `typecheck::TypeKind` çš„å®šä¹‰éžå¸¸ç›¸ä¼¼ï¼Œä½†åŽè€…é¢å¤–å¢žåŠ äº† `Struct`ã€`Any` å’Œ `TypeVar` ç­‰æž„é€ å™¨ã€‚è¿™ä¸ºæˆ‘ä»¬åŽç»­å®žçŽ°æ›´å¼ºå¤§çš„ç±»åž‹åŠŸèƒ½ï¼ˆå¦‚ç»“æž„ä½“å’Œç±»åž‹æŽ¨æ–­ï¼‰é¢„ç•™äº†ç©ºé—´ã€‚
///
/// 2.  **ä¸Šä¸‹æ–‡ `Context` çš„ä½œç”¨ï¼š**
///     *   åœ¨ `typecheck/typedef.mbt` ä¸­ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ä¸ªæ ¸å¿ƒæ•°æ®ç»“æž„ `Context`ã€‚
///     *   `Context` ç”¨äºŽåœ¨ç±»åž‹æ£€æŸ¥è¿‡ç¨‹ä¸­å­˜å‚¨å’Œç®¡ç†ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œä¾‹å¦‚å·²çŸ¥çš„ç»“æž„ä½“å®šä¹‰ã€å‡½æ•°ç­¾åã€å˜é‡ç±»åž‹ç­‰ã€‚
///     *   åœ¨æœ¬æ¬¡ä»»åŠ¡ä¸­ï¼Œæˆ‘ä»¬æš‚æ—¶ä¸ä¼šç”¨åˆ° `Context` çš„å¤æ‚åŠŸèƒ½ï¼Œä½†è½¬æ¢å‡½æ•°ä¼šä½œä¸º `Context` çš„æ–¹æ³•æ¥å®žçŽ°ã€‚
///
/// ### ðŸš€ å…·ä½“æ“ä½œ
///
/// è¯·åœ¨ `typecheck/typedef.mbt` æ–‡ä»¶ä¸­ï¼Œå®Œæˆä»¥ä¸‹ä¸¤ä¸ªå‡½æ•°çš„å®žçŽ°ï¼š
///
/// *   `Context::check_parser_type`
/// *   `Context::check_parser_typekind`
///
/// ä½ çš„ç›®æ ‡æ˜¯é€’å½’åœ°å°† `parser` AST ä¸­çš„ `Type` å’Œ `TypeKind`ï¼Œè½¬æ¢ä¸º `typecheck` AST ä¸­å¯¹åº”çš„ `Type` å’Œ `TypeKind`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// åœ¨ä½ å®žçŽ°å®ŒæˆåŽï¼Œä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥å•ç‹¬è¿è¡Œå½“å‰æµ‹è¯•ï¼š
///
/// ```
/// moon test -p typecheck -f typecheck_normal_type_test.mbt
/// ```
///
/// å‡†å¤‡å¥½äº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹ä¸ºä»£ç èµ‹äºˆâ€œæ„ä¹‰â€çš„ç¬¬ä¸€æ­¥ï¼
/// ================================================================================

///|
test "TypeCheck Normal Type Test" {
  let ctx = Context::new()
  let code =
    #|Unit Int Bool Double String
    #|(Int, Bool, String) Array[Int]
    #|Array[(Int, Double)]
    #|(Int, Bool) -> Double
  let tokens = @lexer.tokenize(code)
  let (t, tok_view) = @parser.parse_type(tokens)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Unit)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Int)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Bool)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Double)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is String)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Tuple([t1, t2, t3]) && t1 is Int && t2 is Bool && t3 is String,
  )
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Array(t1) && t1 is Int)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Array(t1) && t1 is Tuple([t2, t3]) && t2 is Int && t3 is Double,
  )
  let (t, _) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Function([t1, t2], t3) && t1 is Int && t2 is Bool && t3 is Double,
  )
}

///|
test "TypeCheck Defined Type Test" {
  let ctx = Context::new()
  ctx.struct_defs.set("Point", {
    name: "Point",
    fields: [],
    methods: Map::new(),
  })
  ctx.struct_defs.set("Circle", {
    name: "Circle",
    fields: [],
    methods: Map::new(),
  })
  ctx.struct_defs.set("Rectangle", {
    name: "Rectangle",
    fields: [],
    methods: Map::new(),
  })
  // Note: No Triangle
  let code =
    #|Point Circle Rectangle Triangle
    #|Array[Point] (Point, Circle)
    #|(Rectangle, Point) -> Circle
    #|Array[Triangle]
  let tokens = @lexer.tokenize(code)
  let (t, tok_view) = @parser.parse_type(tokens)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Struct("Point"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Struct("Circle"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Struct("Rectangle"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = try? ctx.check_parser_type(t)
  assert_true(t is Err(_)) // Triangle is not defined
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(t.kind is Array(t1) && t1 is Struct("Point"))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Tuple([t1, t2]) && t1 is Struct("Point") && t2 is Struct("Circle"),
  )
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = ctx.check_parser_type(t)
  assert_true(
    t.kind is Function([t1, t2], t3) &&
    t1 is Struct("Rectangle") &&
    t2 is Struct("Point") &&
    t3 is Struct("Circle"),
  )
  let (t, _) = @parser.parse_type(tok_view)
  let t = try? ctx.check_parser_type(t)
  assert_true(t is Err(_)) // Triangle is not defined
}
/// ================================================================================
/// # å€’æ•°ç¬¬äºŒç« ï¼šæ£€æŸ¥æ•´ä¸ªç¨‹åº
///
/// ðŸŽ‰ **ç¥è´ºä½ ï¼ä½ å·²ç»åˆ°è¾¾äº†ç±»åž‹æ£€æŸ¥é˜¶æ®µçš„é‡è¦é‡Œç¨‹ç¢‘ï¼** ðŸŽ‰
///
/// æˆ‘ä»¬å·²ç»åˆ†åˆ«æž„å»ºäº†ç”¨äºŽæ£€æŸ¥è¡¨è¾¾å¼ã€è¯­å¥ã€å‡½æ•°å’Œç»“æž„ä½“çš„æ‰€æœ‰ç»„ä»¶ã€‚
/// çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å°†å®ƒä»¬å…¨éƒ¨æ•´åˆèµ·æ¥ï¼Œåœ¨ `typecheck/program.mbt` ä¸­å®žçŽ°æœ€ç»ˆçš„å…¥å£å‡½æ•° `check_program`ï¼Œ
/// å®ƒå°†è´Ÿè´£å¯¹æ•´ä¸ªç¨‹åºè¿›è¡Œå®Œæ•´çš„ç±»åž‹æ£€æŸ¥ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_program`
///
/// `check_program` å‡½æ•°æ˜¯æ•´ä¸ªç±»åž‹æ£€æŸ¥é˜¶æ®µçš„æ€»æŒ‡æŒ¥ã€‚å®ƒçš„æ ¸å¿ƒæ˜¯é‡‡ç”¨ä¸€ä¸ªç»å…¸çš„ä¸¤é˜¶æ®µï¼ˆTwo-Passï¼‰ç­–ç•¥æ¥è§£å†³å‰å‘å¼•ç”¨ï¼ˆForward Referenceï¼‰å’Œäº’ç›¸é€’å½’çš„é—®é¢˜ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯ï¼šä¸¤é˜¶æ®µæ£€æŸ¥ï¼ˆTwo-Pass Checkingï¼‰
///
/// **ç¬¬ä¸€é˜¶æ®µï¼šæ³¨å†Œï¼ˆRegistration Passï¼‰**
///
/// åœ¨çœŸæ­£æ£€æŸ¥ä»»ä½•å‡½æ•°ä½“æˆ–è¡¨è¾¾å¼ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦â€œæ€»è§ˆâ€æ•´ä¸ªç¨‹åºï¼Œäº†è§£æ‰€æœ‰é¡¶å±‚å®šä¹‰çš„åå­—å’Œâ€œç­¾åâ€ã€‚
///
/// 1.  **æ³¨å†Œç»“æž„ä½“ï¼š**
///     *   å®žçŽ°ä¸€ä¸ª `collect_struct_names` è¾…åŠ©å‡½æ•°ã€‚
///     *   éåŽ†ç¨‹åºä¸­æ‰€æœ‰çš„ `struct` å®šä¹‰ï¼Œå°†å®ƒä»¬çš„åå­—ï¼ˆ`name`ï¼‰è®°å½•åˆ° `Context` çš„ `struct_defs` è¡¨ä¸­ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬åªå…³å¿ƒåå­—ï¼Œä¸å…³å¿ƒå…¶å†…éƒ¨å­—æ®µã€‚
///
/// 2.  **æ³¨å†Œå‡½æ•°å’Œå…¨å±€å˜é‡ï¼š**
///     *   å®žçŽ°ä¸€ä¸ª `collect_function_types` è¾…åŠ©å‡½æ•°ã€‚
///     *   éåŽ†æ‰€æœ‰é¡¶å±‚çš„ `fn` å®šä¹‰ã€‚å¯¹äºŽæ¯ä¸€ä¸ªå‡½æ•°ï¼Œè½¬æ¢å…¶å‚æ•°å’Œè¿”å›žå€¼çš„ç±»åž‹ï¼Œæž„é€ å‡º `Function` ç±»åž‹ï¼Œç„¶åŽå°†å…¶åå­—å’Œç±»åž‹ç­¾åå­˜å…¥ `Context` çš„ `func_types` å’Œå…¨å±€ `type_env` ä¸­ã€‚
///     *   åŒæ ·ï¼ŒéåŽ†æ‰€æœ‰é¡¶å±‚çš„ `let` ç»‘å®šï¼Œæ£€æŸ¥å…¶ç±»åž‹å¹¶å­˜å…¥å…¨å±€ `type_env`ã€‚
///
/// > å®Œæˆç¬¬ä¸€é˜¶æ®µåŽï¼Œ`Context` å°±æœ‰äº†ä¸€å¼ â€œå…¨å±€ç¬¦å·è¡¨â€ï¼ŒçŸ¥é“äº†ç¨‹åºä¸­æ‰€æœ‰é¡¶å±‚â€œæœ‰ä»€ä¹ˆâ€ï¼Œå³ä½¿æˆ‘ä»¬è¿˜æ²¡æ£€æŸ¥å®ƒä»¬â€œåšä»€ä¹ˆâ€ã€‚
///
/// **ç¬¬äºŒé˜¶æ®µï¼šæ£€æŸ¥ï¼ˆChecking Passï¼‰**
///
/// çŽ°åœ¨ï¼Œæ‰€æœ‰å®šä¹‰éƒ½å·²â€œå¤‡æ¡ˆâ€ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹çœŸæ­£çš„æ£€æŸ¥äº†ã€‚
///
/// 1.  åœ¨ `check_program` å‡½æ•°ä¸­ï¼ŒæŒ‰é¡ºåºè°ƒç”¨ä½ ä¹‹å‰å®žçŽ°çš„æ£€æŸ¥å‡½æ•°ï¼š
/// 2.  éåŽ†å¹¶è°ƒç”¨ `check_struct_def` æ£€æŸ¥æ¯ä¸ªç»“æž„ä½“çš„å­—æ®µç±»åž‹ã€‚
/// 3.  éåŽ†å¹¶è°ƒç”¨ `check_top_let` æ£€æŸ¥æ¯ä¸ªå…¨å±€ `let` ç»‘å®šçš„è¡¨è¾¾å¼ã€‚
/// 4.  éåŽ†å¹¶è°ƒç”¨ `check_top_function` æ£€æŸ¥æ¯ä¸ªé¡¶å±‚å‡½æ•°çš„å‡½æ•°ä½“ã€‚ç”±äºŽæ‰€æœ‰å‡½æ•°ç­¾åéƒ½å·²åœ¨ç¬¬ä¸€é˜¶æ®µæ³¨å†Œï¼Œå‡½æ•°é—´çš„äº’ç›¸è°ƒç”¨å’Œé€’å½’è°ƒç”¨æ­¤æ—¶éƒ½å¯ä»¥è¢«æ­£ç¡®åœ°æ£€æŸ¥ã€‚
///
/// ---
///
/// ### ðŸš€ è§è¯ä½ çš„æˆæžœï¼
///
/// å®Œæˆ `check_program` åŽï¼Œä½ å°±æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½å®Œå¤‡çš„ MiniMoonBit ç±»åž‹æ£€æŸ¥å™¨ï¼
///
/// **å†æ¬¡ç¥è´ºä½ å®Œæˆäº†è¿™ä¸€é‡è¦çš„é‡Œç¨‹ç¢‘ï¼æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¿›å…¥ç±»åž‹æ£€æŸ¥çš„æœ€ç»ˆé˜¶æ®µï¼**
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_program_test.mbt
/// ```
/// ================================================================================

///|
test "Program TypeCheck Test" {
  let code =
    #|let a = 3;
    #|let b = 4;
    #|fn fold(arr: Array[Int], f: (Int, Int) -> Int, init: Int) -> Int { 
    #|  let mut result = init;
    #|  let mut i = 0; 
    #|  while i < arr.length() {
    #|    result = f(result, arr[i]);
    #|  }
    #|  result
    #|}
    #|
    #|fn main {
    #|  fn max(a, b) { if a > b { a } else { b } }
    #|  fn min(a, b) { if a < b { a } else { b } }
    #|  let numbers = [a, 1, b, 1, 5, 9, 2, 6, 5];
    #|  let maximum = fold(numbers, max, -1000);
    #|  let minimum = fold(numbers, min, 1000);
    #|  let max_min_diff = maximum - minimum;
    #|  print_int(max_min_diff);
    #|}
  let ctx = Context::new()
  ctx.type_env.set("print_int", Type::{
    kind: Function([Int], Unit),
    mutable: false,
  })
  ctx.func_types.set("print_int", Function([Int], Unit))
  // Type check the program
  let tokens = @lexer.tokenize(code)
  let program = @parser.parse(tokens)
  let _ = ctx.check_program(program)

}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¡¨è¾¾å¼ï¼šApplyExpr
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿæ£€æŸ¥æœ€åŸºæœ¬çš„åŽŸå­è¡¨è¾¾å¼äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬å‘ä¸Šèµ°ä¸€æ­¥ï¼Œå¼€å§‹å¤„ç† `ApplyExpr`ã€‚
///
/// åœ¨è¯­æ³•åˆ†æžé˜¶æ®µï¼Œ`ApplyExpr` æ˜¯ä¸€ä¸ªå¤åˆæ¦‚å¿µï¼Œå®ƒä»¥ä¸€ä¸ª `AtomExpr` ä¸ºåŸºç¡€ï¼ŒåŽé¢å¯ä»¥è·Ÿéšä¸€ç³»åˆ—çš„å‡½æ•°è°ƒç”¨ `()`ã€æ•°ç»„ç´¢å¼• `[]` æˆ–å­—æ®µè®¿é—® `.`ã€‚
///
/// åœ¨ç±»åž‹æ£€æŸ¥é˜¶æ®µï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦ä¸€ä¸ª `check_apply_expr` å‡½æ•°æ¥å¤„ç†å®ƒã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_apply_expr` çš„åŸºç¡€æƒ…å†µ
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/apply_expr.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_apply_expr` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// æœ¬æ¬¡æŒ‘æˆ˜çš„æµ‹è¯•ç”¨ä¾‹éžå¸¸ç®€å•ï¼Œåªæ¶‰åŠ `ApplyExpr` æœ€åŸºç¡€çš„å½¢å¼ï¼šå³å®ƒä»…ä»…æ˜¯ `AtomExpr` çš„ä¸€ä¸ªåŒ…è£…ã€‚
///
/// å› æ­¤ï¼Œä½ çš„ `check_apply_expr` å‡½æ•°çŽ°åœ¨åªéœ€è¦å¤„ç† `parser::ApplyExprKind::AtomExpr` è¿™ä¸€ç§æƒ…å†µã€‚
///
/// 1.  åœ¨ `check_apply_expr` ä¸­ï¼Œ`match` ä¼ å…¥çš„ `apply_expr.kind`ã€‚
/// 2.  å½“å®ƒæ˜¯ `AtomExpr(atom_expr)` æ—¶ï¼Œç›´æŽ¥è°ƒç”¨æˆ‘ä»¬ä¸Šä¸€å…³å®žçŽ°çš„ `self.check_atom_expr(atom_expr)`ã€‚
/// 3.  `check_atom_expr` ä¼šè¿”å›žä¸€ä¸ªå¸¦ç±»åž‹çš„åŽŸå­è¡¨è¾¾å¼ã€‚ä½ éœ€è¦ç”¨å®ƒæ¥æž„å»ºä¸€ä¸ªæ–°çš„ã€å¸¦ç±»åž‹çš„ `typecheck::ApplyExpr`ï¼Œå¹¶å°†å…¶ç±»åž‹ï¼ˆ`ty`ï¼‰è®¾ç½®ä¸ºåˆšåˆšè¿”å›žçš„åŽŸå­è¡¨è¾¾å¼çš„ç±»åž‹ã€‚
///
/// æˆ‘ä»¬å°†åœ¨åŽç»­æŒ‘æˆ˜ä¸­é€æ­¥ä¸º `check_apply_expr` æ·»åŠ å¤„ç†å‡½æ•°è°ƒç”¨ã€æ•°ç»„è®¿é—®ç­‰æ›´å¤æ‚çš„èƒ½åŠ›ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®ŒæˆåŽï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®žçŽ°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typecheck_simple_apply_expr_test.mbt
/// ```
///
/// åŠ æ²¹ï¼æˆ‘ä»¬æ­£åœ¨ç¨³æ­¥æž„å»ºç±»åž‹æ£€æŸ¥å™¨çš„å±‚æ¬¡ç»“æž„ã€‚
/// ================================================================================

///|
test "Simple Apply Expression Type Check" {
  let code =
    #|42 3.14 true "Hello" x y z
  let ctx = Context::new()
  ctx.type_env.set("x", { kind: TypeKind::Double, mutable: false })
  ctx.type_env.set("y", { kind: TypeKind::Bool, mutable: false })
  ctx.type_env.set("z", { kind: TypeKind::String, mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of 42
  let (a, tok_view) = @parser.parse_apply_expr(tokens[:])
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Int)
  // Type of 3.14
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Double)
  // Type of true
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Bool)
  // Type of "Hello"
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is String)
  // Type of x
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Double)
  // Type of y
  let (a, tok_view) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is Bool)
  // Type of z
  let (a, _) = @parser.parse_apply_expr(tok_view)
  let a = ctx.check_apply_expr(a)
  assert_true(a.ty is String)
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¡¨è¾¾å¼ï¼šä»ŽåŽŸå­è¡¨è¾¾å¼å¼€å§‹
///
/// æ­å–œä½ ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†å¯¹é¡¶å±‚å£°æ˜Žçš„ç±»åž‹æ£€æŸ¥ï¼
/// çŽ°åœ¨ï¼Œæˆ‘ä»¬å°†æ·±å…¥ç¼–è¯‘å™¨çš„æ ¸å¿ƒè…¹åœ°ï¼š**è¡¨è¾¾å¼çš„ç±»åž‹æ£€æŸ¥**ã€‚
///
/// æˆ‘ä»¬çš„æœ€ç»ˆç›®æ ‡æ˜¯å®žçŽ°ä¸€ä¸ª `check_expr` å‡½æ•°ï¼Œå®ƒèƒ½å¤Ÿç¡®å®šä»»ä½•å¤æ‚è¡¨è¾¾å¼çš„ç±»åž‹ã€‚
/// ä½†æ­£å¦‚æˆ‘ä»¬åœ¨è¯­æ³•åˆ†æžé˜¶æ®µæ‰€åšçš„é‚£æ ·ï¼Œæˆ‘ä»¬å°†é‡‡ç”¨â€œè‡ªåº•å‘ä¸Šâ€çš„ç­–ç•¥ï¼Œä»Žæœ€ç®€å•çš„éƒ¨åˆ†å¼€å§‹ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_atom_expr`
///
/// **åŽŸå­è¡¨è¾¾å¼ï¼ˆAtomExprï¼‰**æ˜¯æ‰€æœ‰å¤æ‚è¡¨è¾¾å¼çš„åŸºçŸ³ã€‚
/// ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡æ˜¯åœ¨ `typecheck/atom_expr.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_atom_expr` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°æŽ¥æ”¶ä¸€ä¸ªæ¥è‡ª parser çš„ `AtomExpr`ï¼Œå¹¶è¿”å›žä¸€ä¸ª**å¸¦æœ‰ç±»åž‹ä¿¡æ¯**çš„æ–° `AtomExpr`ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// ä½ éœ€è¦åœ¨ `check_atom_expr` ä¸­ä½¿ç”¨ `match` è¯­å¥æ¥å¤„ç†ä¸åŒç§ç±»çš„åŽŸå­è¡¨è¾¾å¼ï¼š
///
/// 1.  **å­—é¢é‡ï¼ˆLiteralsï¼‰ï¼š**
///     *   å¯¹äºŽ `Int(v)`ï¼Œå…¶ç±»åž‹æ˜¾ç„¶æ˜¯ `TypeKind::Int`ã€‚
///     *   å¯¹äºŽ `Double(v)`ï¼Œå…¶ç±»åž‹æ˜¯ `TypeKind::Double`ã€‚
///     *   å¯¹äºŽ `Bool(v)`ï¼Œå…¶ç±»åž‹æ˜¯ `TypeKind::Bool`ã€‚
///     *   å¯¹äºŽ `String(s)`ï¼Œå…¶ç±»åž‹æ˜¯ `TypeKind::String`ã€‚
///
/// 2.  **æ ‡è¯†ç¬¦ï¼ˆIdentifiersï¼‰ï¼š**
///     *   å¯¹äºŽ `Ident(name)`ï¼Œæƒ…å†µå˜å¾—æœ‰è¶£èµ·æ¥ã€‚è¿™ä»£è¡¨ä¸€ä¸ªå˜é‡ã€‚
///     *   å®ƒçš„ç±»åž‹æ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¿…é¡»åœ¨**ç±»åž‹çŽ¯å¢ƒï¼ˆType Environmentï¼‰**ä¸­æŸ¥æ‰¾å®ƒï¼
///     *   `Context` ç»“æž„ä½“ä¸­åŒ…å«ä¸€ä¸ª `type_env` å­—æ®µï¼Œå®ƒæ˜¯ä¸€ä¸ª `Map`ï¼Œå­˜å‚¨äº†å½“å‰ä½œç”¨åŸŸå†…æ‰€æœ‰å·²çŸ¥å˜é‡çš„ç±»åž‹ã€‚
///     *   ä½ éœ€è¦ä»Ž `self.type_env` ä¸­æŸ¥æ‰¾ `name` å¯¹åº”çš„ç±»åž‹ã€‚å¦‚æžœæ‰¾ä¸åˆ°ï¼Œå°±åº”è¯¥æŠ›å‡ºä¸€ä¸ª `TypeCheckError` é”™è¯¯ã€‚
///
/// **è¯·æ³¨æ„ï¼š**
/// æœ¬æ¬¡æŒ‘æˆ˜çš„æµ‹è¯•ç”¨ä¾‹åªåŒ…å«ä¸Šè¿°å‡ ç§æƒ…å†µã€‚ä½ æš‚æ—¶**ä¸éœ€è¦**å¤„ç† `Paren`ã€`Tuple`ã€`Array` ç­‰æ›´å¤æ‚çš„åŽŸå­è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å°†åœ¨åŽç»­çš„æŒ‘æˆ˜ä¸­é€æ­¥å®Œå–„å®ƒä»¬ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®ŒæˆåŽï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®žçŽ°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typecheck_simple_atom_expr_test.mbt
/// ```
///
/// åŠ æ²¹ï¼è¿™æ˜¯æˆ‘ä»¬æž„å»ºç±»åž‹æŽ¨æ–­å¼•æ“Žçš„ç¬¬ä¸€æ­¥ï¼
/// ================================================================================

///|
test "Simple Atom Expression Type Check" {
  let code =
    #|42 3.14 true "Hello" x y z
  let ctx = Context::new()
  ctx.type_env.set("x", { kind: TypeKind::Double, mutable: false })
  ctx.type_env.set("y", { kind: TypeKind::Bool, mutable: false })
  ctx.type_env.set("z", { kind: TypeKind::String, mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of 42
  let (a, tok_view) = @parser.parse_atom_expr(tokens[:])
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Int)
  // Type of 3.14
  let (a, tok_view) = @parser.parse_atom_expr(tok_view)
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Double)
  // Type of true
  let (a, tok_view) = @parser.parse_atom_expr(tok_view)
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Bool)
  // Type of "Hello"
  let (a, tok_view) = @parser.parse_atom_expr(tok_view)
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is String)
  // Type of x
  let (a, tok_view) = @parser.parse_atom_expr(tok_view)
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Double)
  // Type of y
  let (a, tok_view) = @parser.parse_atom_expr(tok_view)
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is Bool)
  // Type of z
  let (a, _) = @parser.parse_atom_expr(tok_view)
  let a = ctx.check_atom_expr(a)
  assert_true(a.ty is String)
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥çš„æ ¸å¿ƒï¼šExpr
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥å¤„ç† `AtomExpr` å’Œ `ApplyExpr` äº†ã€‚çŽ°åœ¨ï¼Œæˆ‘ä»¬æ¥åˆ°äº†ç±»åž‹æ£€æŸ¥çš„æ ¸å¿ƒæž¢çº½ï¼š`check_expr` å‡½æ•°ã€‚
///
/// `Expr` æ˜¯ä¸€ä¸ªé€’å½’çš„æžšä¸¾ç±»åž‹ï¼Œå®ƒå¯ä»¥ä»£è¡¨å„ç§å¤æ‚çš„è¡¨è¾¾å¼ï¼Œå¦‚ä¸€å…ƒè¿ç®—ã€äºŒå…ƒè¿ç®—ç­‰ã€‚
/// `check_expr` çš„èŒè´£å°±æ˜¯æ·±å…¥åˆ°è¿™äº›è¡¨è¾¾å¼çš„å†…éƒ¨ï¼ŒéªŒè¯å®ƒä»¬çš„ç±»åž‹è§„åˆ™ï¼Œå¹¶æœ€ç»ˆç¡®å®šæ•´ä¸ªè¡¨è¾¾å¼çš„ç±»åž‹ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/expr.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_expr` å‡½æ•°ã€‚
/// æœ¬æ¬¡æŒ‘æˆ˜çš„æµ‹è¯•è¦†ç›–äº†å¤šç§è¡¨è¾¾å¼ï¼Œä½ éœ€è¦ä¸€æ¬¡æ€§å¤„ç†å®ƒä»¬ï¼
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// ä½ éœ€è¦åœ¨ `check_expr` ä¸­ `match` ä¼ å…¥çš„ `expr.kind`ï¼Œå¹¶ä¸ºä¸åŒçš„æƒ…å†µç¼–å†™ç±»åž‹æ£€æŸ¥é€»è¾‘ï¼š
///
/// 1.  **`ApplyExpr(apply_expr)`:**
///     *   è¿™æ˜¯æœ€ç®€å•çš„æƒ…å†µã€‚ç›´æŽ¥è°ƒç”¨æˆ‘ä»¬åˆšå®Œæˆçš„ `self.check_apply_expr(apply_expr)`ã€‚
///     *   è¿”å›žçš„ `ApplyExpr` å·²ç»å¸¦æœ‰äº†ç±»åž‹ï¼Œç”¨å®ƒæ¥æž„é€ ä¸€ä¸ª `typecheck::Expr` å¹¶è¿”å›žã€‚
///
/// 2.  **`NotExpr(inner_expr)` (é€»è¾‘éž `!`)**
///     *   é¦–å…ˆï¼Œé€’å½’è°ƒç”¨ `self.check_expr(inner_expr)` æ¥æ£€æŸ¥å†…éƒ¨è¡¨è¾¾å¼ã€‚
///     *   **ç±»åž‹è§„åˆ™ï¼š** `!` æ“ä½œç¬¦åªèƒ½ç”¨äºŽ `Bool` ç±»åž‹ã€‚ä½ éœ€è¦æ£€æŸ¥ `inner_expr` çš„ç±»åž‹æ˜¯å¦ä¸º `Bool`ã€‚å¦‚æžœä¸æ˜¯ï¼Œå°±æŠ›å‡ºç±»åž‹é”™è¯¯ã€‚
///     *   **è¿”å›žç±»åž‹ï¼š** `NotExpr` æœ¬èº«çš„ç±»åž‹æ°¸è¿œæ˜¯ `Bool`ã€‚
///
/// 3.  **`NegExpr(inner_expr)` (å–å `-`)**
///     *   åŒæ ·ï¼Œé€’å½’è°ƒç”¨ `self.check_expr(inner_expr)`ã€‚
///     *   **ç±»åž‹è§„åˆ™ï¼š** `-` æ“ä½œç¬¦åœ¨æˆ‘ä»¬çš„è¯­è¨€ä¸­åªèƒ½ç”¨äºŽ `Int` æˆ– `Double`ã€‚ä½ éœ€è¦æ£€æŸ¥ `inner_expr` çš„ç±»åž‹ã€‚
///     *   **è¿”å›žç±»åž‹ï¼š** `NegExpr` çš„ç±»åž‹ä¸Žå®ƒå†…éƒ¨è¡¨è¾¾å¼çš„ç±»åž‹ç›¸åŒã€‚
///
/// 4.  **`BinaryExpr(op, left, right)` (äºŒå…ƒè¿ç®—)**
///     *   è¿™æ˜¯æœ€å¤æ‚çš„éƒ¨åˆ†ã€‚é¦–å…ˆï¼Œé€’å½’è°ƒç”¨ `check_expr` æ£€æŸ¥å·¦å³ä¸¤ä¸ªå­è¡¨è¾¾å¼ `left` å’Œ `right`ã€‚
///     *   **é€šç”¨è§„åˆ™ï¼š** å¯¹äºŽæ‰€æœ‰äºŒå…ƒè¿ç®—ï¼Œå·¦å³ä¸¤ä¸ªæ“ä½œæ•°çš„ç±»åž‹å¿…é¡»å…¼å®¹ï¼ˆåœ¨æˆ‘ä»¬çš„ç®€å•å®žçŽ°ä¸­ï¼Œæ„å‘³ç€ç±»åž‹å¿…é¡»å®Œå…¨ç›¸åŒï¼‰ã€‚ä½ å¯ä»¥ä½¿ç”¨ `self.is_type_compatible(...)` è¾…åŠ©å‡½æ•°æ¥åˆ¤æ–­ã€‚
///     *   **æ ¹æ®æ“ä½œç¬¦ `op` åˆ¤æ–­è¿”å›žç±»åž‹ï¼š**
///         *   **ç®—æœ¯è¿ç®— (`+`, `-`, `*`, `/`, `%`)ï¼š** æ“ä½œæ•°å¿…é¡»æ˜¯ `Int` æˆ– `Double`ã€‚è¿”å›žç±»åž‹ä¸Žæ“ä½œæ•°ç±»åž‹ç›¸åŒã€‚
///         *   **æ¯”è¾ƒè¿ç®— (`>`, `<`, `==`, `!=`, `>=`, `<=`)ï¼š** æ“ä½œæ•°å¯ä»¥æ˜¯ `Int` æˆ– `Double`ã€‚è¿”å›žç±»åž‹æ°¸è¿œæ˜¯ `Bool`ã€‚
///         *   **é€»è¾‘è¿ç®— (`&&`, `||`)ï¼š** æ“ä½œæ•°å¿…é¡»æ˜¯ `Bool`ã€‚è¿”å›žç±»åž‹ä¹Ÿæ˜¯ `Bool`ã€‚ï¼ˆæ³¨ï¼šæœ¬æ¬¡æµ‹è¯•æœªè¦†ç›–ï¼Œä½†å¯ä»¥æå‰æ€è€ƒï¼‰
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®ŒæˆåŽï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®žçŽ°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typecheck_simple_expr_test.mbt
/// ```
///
/// åŠ æ²¹ï¼è¿™æ˜¯ç±»åž‹æ£€æŸ¥å™¨ä¸­å·¥ä½œé‡æœ€å¤§ã€ä¹Ÿæœ€æ ¸å¿ƒçš„éƒ¨åˆ†ã€‚
/// ================================================================================

///|
test "Simple Expression Type Check" {
  let code =
    #|42 ; 3.14 ; true ; "Hello";
    #|!true ; !false ; !x ;
    #|-42 ; -3.14 ; -y ;
    #|1 + 3; 4 - 5 ; 6 * 7; 8.0 / 2.0; 9 % 4;
    #|1 > 2; 42.0 >= y; x == true ;
  let ctx = Context::new()
  ctx.type_env.set("x", { kind: TypeKind::Bool, mutable: false })
  ctx.type_env.set("y", { kind: TypeKind::Double, mutable: false })
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type of 42
  let (a, tok_view) = @parser.parse_expr(tokens[:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of 3.14
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Double)
  // Type of true
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  // Type of "Hello"
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is String)
  // Type of !true
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  // Type of !false
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  // Type of !x
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  // Type of -42
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of -3.14
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Double)
  // Type of -y
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Double)
  // Type of 1 + 3
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of 4 - 5
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of 6 * 7
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  // Type of 8.0 / 2.0
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Double)
  // Type of 9 % 4
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Int)
  //// Type of 1 > 2
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  //// Type of 42 == y
  let (a, tok_view) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
  //// Type of x == true
  let (a, _) = @parser.parse_expr(tok_view[1:])
  let a = ctx.check_expr(a)
  assert_true(a.ty is Bool)
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥ï¼šç»“æž„ä½“æž„é€ 
///
/// æˆ‘ä»¬å·²ç»å¯ä»¥å®šä¹‰ç»“æž„ä½“äº†ï¼ŒçŽ°åœ¨æˆ‘ä»¬éœ€è¦æ£€æŸ¥å®ƒçš„**æž„é€ ï¼ˆConstructionï¼‰**è¿‡ç¨‹ã€‚
/// ç±»åž‹æ£€æŸ¥å™¨å¿…é¡»ç¡®ä¿æˆ‘ä»¬ç”¨äºŽæž„é€ ç»“æž„ä½“çš„å­—æ®µåå’Œå€¼çš„ç±»åž‹éƒ½æ˜¯æ­£ç¡®çš„ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_struct_construct_expr`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/struct_construct_expr.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_struct_construct_expr` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°åœ¨ `check_atom_expr` å†…éƒ¨è¢«è°ƒç”¨ï¼Œå½“é‡åˆ° `StructName::{...}` è¯­æ³•æ—¶è§¦å‘ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// æ£€æŸ¥ `MyStruct::{ field1: value1, ... }` çš„é€»è¾‘å¦‚ä¸‹ï¼š
///
/// 1.  **æŸ¥æ‰¾ç»“æž„ä½“å®šä¹‰ï¼š**
///     *   ä»Ž `Context` çš„ `struct_defs` è¡¨ä¸­ï¼Œæ ¹æ®åå­— `MyStruct` æŸ¥æ‰¾åˆ°å®ƒçš„å®šä¹‰ã€‚å¦‚æžœæ‰¾ä¸åˆ°ï¼Œè¯´æ˜Žè¯¥ç»“æž„ä½“æœªå®šä¹‰ï¼Œåº”æŠ›å‡ºé”™è¯¯ã€‚
///
/// 2.  **éåŽ†å¹¶æ£€æŸ¥æ‰€æœ‰å­—æ®µï¼š**
///     *   éåŽ†æž„é€ è¡¨è¾¾å¼ä¸­æä¾›çš„æ¯ä¸€ä¸ª `field: value` å¯¹ã€‚
///     *   å¯¹äºŽæ¯ä¸ªå­—æ®µï¼Œé¦–å…ˆæ£€æŸ¥ç»“æž„ä½“å®šä¹‰ä¸­æ˜¯å¦å­˜åœ¨åŒåå­—æ®µã€‚å¦‚æžœä¸å­˜åœ¨ï¼ŒæŠ›å‡ºé”™è¯¯ã€‚
///     *   è°ƒç”¨ `check_expr` æ£€æŸ¥ `value` çš„ç±»åž‹ã€‚
///     *   ä½¿ç”¨ `is_type_compatible` éªŒè¯ `value` çš„ç±»åž‹æ˜¯å¦ä¸Žç»“æž„ä½“å®šä¹‰ä¸­è¯¥å­—æ®µçš„ç±»åž‹ç›¸åŒ¹é…ã€‚å¦‚æžœä¸åŒ¹é…ï¼ŒæŠ›å‡ºé”™è¯¯ã€‚
///
/// 3.  **æ£€æŸ¥å­—æ®µå®Œæ•´æ€§ï¼š**
///     *   ä¸€ä¸ªå®Œæ•´çš„å®žçŽ°è¿˜éœ€è¦æ£€æŸ¥ï¼Œæž„é€ è¡¨è¾¾å¼ä¸­æä¾›çš„å­—æ®µæ˜¯å¦åŒ…å«äº†ç»“æž„ä½“å®šä¹‰ä¸­æ‰€æœ‰æœªå£°æ˜Žä¸ºå¯é€‰çš„å­—æ®µã€‚
///     *   ä¸ºäº†ç®€åŒ–ï¼Œåœ¨æˆ‘ä»¬çš„ MiniMoonBit ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚æž„é€ æ—¶å¿…é¡»æä¾›æ‰€æœ‰å­—æ®µã€‚ä½ å¯ä»¥é€šè¿‡æ¯”è¾ƒæž„é€ è¡¨è¾¾å¼ä¸­çš„å­—æ®µæ•°é‡å’Œå®šä¹‰ä¸­çš„å­—æ®µæ•°é‡æ¥åšä¸€ä¸ªç®€å•çš„æ£€æŸ¥ã€‚
///
/// 4.  **ç¡®å®šè¡¨è¾¾å¼ç±»åž‹ï¼š**
///     *   å¦‚æžœæ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼Œé‚£ä¹ˆæ•´ä¸ªæž„é€ è¡¨è¾¾å¼çš„ç±»åž‹å°±æ˜¯è¯¥ç»“æž„ä½“æœ¬èº«çš„ç±»åž‹ï¼Œå³ `TypeKind::Struct("MyStruct")`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_struct_construct_test.mbt
/// ```
/// ================================================================================

///|
test "Struct Construct TypeCheck Test" {
  let code =
    #|struct Point { x: Int; y: Int; }
    #|let p1 = Point::{ x: 1, y: 2 };
  let tokens = @lexer.tokenize(code)
  let ctx = Context::new()

  // 1. Parse and check the struct definition to populate the context
  let (struct_def, tok_view1) = @parser.parse_struct_def(tokens)
  let _ = ctx.check_struct_def(struct_def) // Assumes check_struct_def works

  // 2. Parse and check the valid `let p1 = ...` statement
  let (let_stmt1, _) = @parser.parse_let_stmt(tok_view1)
  let _ = ctx.check_let_stmt(let_stmt1)
  let p1_type = ctx.lookup_type("p1")
  assert_true(p1_type is Some({ kind: Struct("Point"), .. }))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è‡ªå®šä¹‰ç±»åž‹ï¼šç»“æž„ä½“
///
/// æˆ‘ä»¬å·²ç»èƒ½å¤Ÿå°† parser è§£æžå‡ºçš„ç±»åž‹è½¬æ¢ä¸ºç±»åž‹æ£€æŸ¥å™¨ä¸­çš„å†…éƒ¨è¡¨ç¤ºäº†ã€‚
/// çŽ°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥å¤„ç†ä¸€ä¸ªæ›´é‡è¦çš„éƒ¨åˆ†ï¼š**æ£€æŸ¥ç”¨æˆ·è‡ªå®šä¹‰çš„ç»“æž„ä½“ï¼ˆStructï¼‰**ã€‚
///
/// å½“æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸ªç»“æž„ä½“å®šä¹‰æ—¶ï¼Œä¸»è¦ä»»åŠ¡æ˜¯éªŒè¯å…¶æ‰€æœ‰å­—æ®µçš„ç±»åž‹éƒ½æ˜¯å·²çŸ¥çš„ã€åˆæ³•çš„ç±»åž‹ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_struct_def`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/struct_def.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_struct_def` å‡½æ•°ã€‚
///
/// è¿™ä¸ªå‡½æ•°æŽ¥æ”¶ä¸€ä¸ªä»Ž parser ä¼ æ¥çš„ `StructDef`ï¼Œç„¶åŽéœ€è¦ï¼š
/// 1.  éåŽ†ç»“æž„ä½“çš„æ¯ä¸€ä¸ªå­—æ®µã€‚
/// 2.  è°ƒç”¨æˆ‘ä»¬ä¹‹å‰å®žçŽ°çš„ `check_parser_type`ï¼Œå°†æ¯ä¸ªå­—æ®µçš„ parser ç±»åž‹è½¬æ¢ä¸ºç±»åž‹æ£€æŸ¥å™¨çš„å†…éƒ¨ç±»åž‹ã€‚
/// 3.  æž„é€ å¹¶è¿”å›žä¸€ä¸ªæ–°çš„ã€å·²æ£€æŸ¥è¿‡çš„ `StructDef`ï¼ˆè¿™é‡Œçš„â€œæ–°â€æŒ‡çš„æ˜¯ç±»åž‹æ£€æŸ¥å™¨å†…éƒ¨çš„ AST èŠ‚ç‚¹ï¼Œå…¶å®šä¹‰å¯èƒ½ä¸Ž parser çš„ç•¥æœ‰ä¸åŒï¼‰ã€‚
///
/// ---
///
/// ### ðŸ¤” æ·±å…¥æ€è€ƒï¼šå¾ªçŽ¯å¼•ç”¨ä¸Žå‰å‘å¼•ç”¨
///
/// åœ¨å®žçŽ° `check_struct_def` æ—¶ï¼Œä¸€ä¸ªéžå¸¸ç»å…¸çš„ç¼–è¯‘å™¨é—®é¢˜ä¼šæ‘†åœ¨ä½ çš„é¢å‰ï¼š
///
/// è€ƒè™‘ä»¥ä¸‹ä»£ç ï¼š
///
/// ```moonbit
/// struct Node {
///   next: List; // `List` åœ¨è¿™é‡Œè¢«ä½¿ç”¨
/// }
///
/// struct List {
///   head: Node; // `Node` åœ¨è¿™é‡Œè¢«ä½¿ç”¨
/// }
/// ```
///
/// å½“ç±»åž‹æ£€æŸ¥å™¨å¤„ç† `struct Node` æ—¶ï¼Œå®ƒé‡åˆ°äº† `List` ç±»åž‹ã€‚ä½†æ­¤æ—¶ï¼Œ`List` ç»“æž„ä½“è¿˜å°šæœªè¢«å¤„ç†ï¼
/// è¿™ç§åœ¨å®šä¹‰ä¹‹å‰å°±è¢«å¼•ç”¨çš„æƒ…å†µï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º**å‰å‘å¼•ç”¨ï¼ˆForward Referenceï¼‰**ã€‚
///
/// **è¯·ä½ æƒ³ä¸€æƒ³ï¼š**
///
/// > æˆ‘ä»¬çš„ç±»åž‹æ£€æŸ¥å™¨åº”è¯¥å¦‚ä½•è®¾è®¡ï¼Œæ‰èƒ½æ­£ç¡®å¤„ç†è¿™ç§æƒ…å†µï¼Ÿ
/// > å¦‚æžœåªæ˜¯ç®€å•åœ°ä»Žä¸Šåˆ°ä¸‹ä¾æ¬¡å¤„ç†æ¯ä¸ªç»“æž„ä½“å®šä¹‰ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
///
/// **ðŸ’¡ æç¤ºï¼šä¸¤é˜¶æ®µå¤„ç†ï¼ˆTwo-Passï¼‰**
///
/// è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸€ä¸ªç»å…¸æ–¹æ³•æ˜¯é‡‡ç”¨â€œä¸¤é˜¶æ®µå¤„ç†â€ï¼š
///
/// 1.  **ç¬¬ä¸€é˜¶æ®µï¼ˆæ³¨å†Œé˜¶æ®µï¼‰ï¼š** éåŽ†æ‰€æœ‰çš„ç»“æž„ä½“å®šä¹‰ï¼Œä½†åªè®°å½•ä¸‹å®ƒä»¬çš„**åå­—**ã€‚å°†æ‰€æœ‰ç»“æž„ä½“çš„åå­—æ³¨å†Œåˆ°ä¸€ä¸ªé›†åˆæˆ– `Map` ä¸­ï¼Œè¿™æ ·ç¼–è¯‘å™¨å°±çŸ¥é“â€œå­˜åœ¨å“ªäº›ç»“æž„ä½“â€ã€‚
/// 2.  **ç¬¬äºŒé˜¶æ®µï¼ˆæ£€æŸ¥é˜¶æ®µï¼‰ï¼š** å†æ¬¡éåŽ†æ‰€æœ‰çš„ç»“æž„ä½“å®šä¹‰ã€‚è¿™ä¸€æ¬¡ï¼Œæˆ‘ä»¬çœŸæ­£åœ°åŽ»æ£€æŸ¥æ¯ä¸ªç»“æž„ä½“å†…éƒ¨çš„å­—æ®µã€‚å› ä¸ºåœ¨ç¬¬ä¸€é˜¶æ®µæˆ‘ä»¬å·²ç»æ³¨å†Œäº†æ‰€æœ‰ç»“æž„ä½“çš„åå­—ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬åœ¨ `Node` ä¸­é‡åˆ° `List` æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ³¨å†Œè¡¨ä¸­æŸ¥åˆ° `List` æ˜¯ä¸€ä¸ªå·²çŸ¥çš„ï¼ˆè™½ç„¶å¯èƒ½å°šæœªå®Œå…¨æ£€æŸ¥çš„ï¼‰ç±»åž‹ï¼Œä»Žè€Œå…è®¸è¿™ç§å¼•ç”¨ã€‚
///
/// åœ¨æˆ‘ä»¬çš„ MiniMoonBit ç¼–è¯‘å™¨ä¸­ï¼Œ`check_program` å‡½æ•°ï¼ˆä½äºŽ `typecheck/program.mbt`ï¼‰å·²ç»ä¸ºä½ æ­å»ºå¥½äº†è¿™ä¸ªä¸¤é˜¶æ®µå¤„ç†çš„æ¡†æž¶ã€‚
/// ä½ çŽ°åœ¨éœ€è¦å®žçŽ°çš„ `check_struct_def` æ­£æ˜¯è¿™ä¸ªæ¡†æž¶ä¸­çš„ç¬¬äºŒé˜¶æ®µçš„æ ¸å¿ƒéƒ¨åˆ†ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// å®ŒæˆåŽï¼Œè¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æ£€éªŒä½ çš„å®žçŽ°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typecheck_struct_def_test.mbt
/// ```
///
/// åŠ æ²¹ï¼ä½ æ­£åœ¨å¤„ç†ç¼–è¯‘å™¨è®¾è®¡ä¸­ä¸€ä¸ªéžå¸¸æ ¸å¿ƒä¸”æœ‰è¶£çš„é—®é¢˜ï¼
/// ================================================================================

///|
test "Struct Definition Typecheck" {
  let code =
    #|struct Point { x: Int; mut y: Int; }
    #|struct Queue { data: Array[Int]; mut front: Int; mut back: Int; }
  let tokens = @lexer.tokenize(code)
  let ctx = Context::new()
  // Parse
  let (struct_def, tok_view) = @parser.parse_struct_def(tokens[:])
  // Typecheck for `struct Point { x: Int; mut y: Int }`
  let struct_def = ctx.check_struct_def(struct_def)
  assert_true(struct_def.name is "Point")
  assert_true(struct_def.fields.length() is 2)
  assert_true(
    struct_def.fields is [f1, f2] &&
    f1 is { name: "x", ty: { kind: Int, mutable: false } } &&
    f2 is { name: "y", ty: { kind: Int, mutable: true } },
  )
  // Typecheck for `struct Queue { data: Array[Int]; mut front: Int; mut back: Int }`
  let (struct_def, _) = @parser.parse_struct_def(tok_view)
  let struct_def = ctx.check_struct_def(struct_def)
  assert_true(struct_def.name is "Queue")
  assert_true(struct_def.fields.length() is 3)
  assert_true(
    struct_def.fields is [f1, f2, f3] &&
    f1 is { name: "data", ty: { kind: Array(Int), mutable: false } } &&
    f2 is { name: "front", ty: { kind: Int, mutable: true } } &&
    f3 is { name: "back", ty: { kind: Int, mutable: true } },
  )
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥ï¼šé¡¶å±‚å‡½æ•°
///
/// æˆ‘ä»¬å·²ç»æ”»å…‹äº†æœ€å¤æ‚çš„å±€éƒ¨å‡½æ•°ï¼ŒçŽ°åœ¨å›žåˆ°é¡¶å±‚å‡½æ•°çš„ç±»åž‹æ£€æŸ¥ï¼Œå®ƒè¦ç®€å•å¾—å¤šã€‚
///
/// é¡¶å±‚å‡½æ•°æ˜¯æž„æˆç¨‹åºçš„ä¸»ä½“ã€‚å¯¹å®ƒä»¬çš„æ£€æŸ¥æ˜¯ç±»åž‹æ£€æŸ¥æµç¨‹ä¸­éžå¸¸é‡è¦çš„ä¸€çŽ¯ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_top_function`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/top_function.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_top_function` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// æ£€æŸ¥é¡¶å±‚å‡½æ•°çš„ä¸»ä½“ä¸Žæ£€æŸ¥å±€éƒ¨å‡½æ•°éžå¸¸ç›¸ä¼¼ï¼Œä½†ç”±äºŽé¡¶å±‚å‡½æ•°ï¼ˆ`main`é™¤å¤–ï¼‰çš„æ‰€æœ‰ç±»åž‹éƒ½å¿…é¡»æ˜¾å¼æ³¨è§£ï¼Œæˆ‘ä»¬æ— éœ€è¿›è¡Œå¤æ‚çš„ç±»åž‹æŽ¨æ–­ã€‚
///
/// æ•´ä¸ªæµç¨‹å¦‚ä¸‹ï¼š
///
/// 1.  **æŸ¥æ‰¾å‡½æ•°ç­¾åï¼š**
///     *   åœ¨æ£€æŸ¥å‡½æ•°ä½“ä¹‹å‰ï¼Œæˆ‘ä»¬å‡è®¾å·²ç»é€šè¿‡ä¸€ä¸ªâ€œé¢„å¤„ç†â€é˜¶æ®µï¼Œå°†æ‰€æœ‰é¡¶å±‚å‡½æ•°çš„ç­¾åï¼ˆå‡½æ•°åã€å‚æ•°ç±»åž‹ã€è¿”å›žç±»åž‹ï¼‰éƒ½æ³¨å†Œåˆ°äº† `Context` çš„ `func_types` è¡¨ä¸­ã€‚
///     *   å› æ­¤ï¼Œå‡½æ•°çš„ç¬¬ä¸€æ­¥æ˜¯ä»Ž `func_types` ä¸­æŸ¥æ‰¾åˆ°å½“å‰è¦æ£€æŸ¥çš„å‡½æ•° `func` çš„ç­¾åã€‚
///
/// 2.  **åˆ›å»ºå‡½æ•°ä½œç”¨åŸŸï¼š**
///     *   è°ƒç”¨ `enter_scope()` ä¸ºå‡½æ•°ä½“åˆ›å»ºä¸€ä¸ªæ–°çš„ã€ç‹¬ç«‹çš„ä½œç”¨åŸŸã€‚
///
/// 3.  **è®¾ç½®ä¸Šä¸‹æ–‡å¹¶å¡«å……ä½œç”¨åŸŸï¼š**
///     *   å°† `Context` çš„ `current_func_ret_ty` è®¾ç½®ä¸ºä»Žå‡½æ•°ç­¾åä¸­æŸ¥åˆ°çš„è¿”å›žç±»åž‹ã€‚
///     *   éåŽ†å‡½æ•°çš„æ‰€æœ‰å‚æ•°ï¼Œå°†å®ƒä»¬çš„åå­—å’Œç±»åž‹æ·»åŠ åˆ°æ–°çš„ä½œç”¨åŸŸä¸­ã€‚
///
/// 4.  **æ£€æŸ¥å‡½æ•°ä½“ï¼š**
///     *   è°ƒç”¨ `check_block_expr` å¯¹æ•´ä¸ªå‡½æ•°ä½“è¿›è¡Œç±»åž‹æ£€æŸ¥ã€‚
///
/// 5.  **éªŒè¯è¿”å›žç±»åž‹ï¼š**
///     *   æ£€æŸ¥ `check_block_expr` è¿”å›žçš„å‡½æ•°ä½“ç±»åž‹ï¼Œæ˜¯å¦ä¸Žå‡½æ•°ç­¾åçš„è¿”å›žç±»åž‹å…¼å®¹ã€‚
///
/// 6.  **æ¸…ç†ï¼š**
///     *   è°ƒç”¨ `exit_scope()` é€€å‡ºå‡½æ•°ä½œç”¨åŸŸã€‚
///     *   å°† `current_func_ret_ty` é‡ç½®ä¸º `None`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_top_func_test.mbt
/// ```
/// ================================================================================

///|
test "Top Function TypeCheck Test" {
  let code =
    #|fn fib(n : Int) -> Int {
    #|  if n <= 1 {
    #|    return n;
    #|  } else {
    #|    return fib(n - 1) + fib(n - 2);
    #|  }
    #|}
  let ctx = Context::new()
  ctx.func_types.set("fib", Function([Int], Int))
  ctx.type_env.set("fib", { kind: Function([Int], Int), mutable: false })
  // parse
  let tokens = @lexer.tokenize(code)
  let (top_func, _) = @parser.parse_top_function(tokens[:])
  let _ = ctx.check_top_function(top_func)

}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥è¯­å¥ï¼šé¡¶å±‚ let
///
/// é™¤äº†å‡½æ•°å†…éƒ¨çš„ `let mut`ï¼Œæˆ‘ä»¬çš„è¯­è¨€è¿˜æ”¯æŒåœ¨é¡¶å±‚ï¼ˆå…¨å±€ä½œç”¨åŸŸï¼‰ä½¿ç”¨ `let` æ¥å®šä¹‰å…¨å±€å¸¸é‡ã€‚
/// å¯¹å®ƒçš„ç±»åž‹æ£€æŸ¥ä¸Ž `let mut` éžå¸¸ç›¸ä¼¼ï¼Œä½†æœ‰ä¸€ä¸ªå…³é”®çš„åŒºåˆ«ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_top_let`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/top_let.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_top_let` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// `check_top_let` çš„é€»è¾‘å‡ ä¹Žä¸Ž `check_let_mut_stmt` å®Œå…¨ç›¸åŒï¼š
///
/// 1.  æ£€æŸ¥ `=` å³ä¾§è¡¨è¾¾å¼çš„ç±»åž‹ã€‚
/// 2.  å¦‚æžœå­˜åœ¨ç±»åž‹æ³¨è§£ï¼Œåˆ™éªŒè¯å…¶ä¸Žè¡¨è¾¾å¼ç±»åž‹æ˜¯å¦å…¼å®¹ã€‚
/// 3.  å°†æ–°å˜é‡çš„åç§°å’Œç±»åž‹æ·»åŠ åˆ°ç±»åž‹çŽ¯å¢ƒ `self.type_env` ä¸­ã€‚
///
/// **å”¯ä¸€çš„åŒºåˆ«åœ¨äºŽï¼š**
///
/// > é€šè¿‡é¡¶å±‚ `let` å®šä¹‰çš„å˜é‡æ˜¯**ä¸å¯å˜çš„ï¼ˆimmutableï¼‰**ã€‚
/// > å› æ­¤ï¼Œåœ¨å°†å®ƒæ·»åŠ åˆ°ç±»åž‹çŽ¯å¢ƒæ—¶ï¼Œä½ å¿…é¡»å°†å…¶æ ‡è®°ä¸º `mutable: false`ã€‚
///
/// è¿™ç¡®ä¿äº†ç¼–è¯‘å™¨åœ¨åŽç»­çš„æ£€æŸ¥ä¸­ï¼Œå¦‚æžœé‡åˆ°è¯•å›¾ä¿®æ”¹è¯¥å˜é‡çš„èµ‹å€¼è¯­å¥ï¼Œèƒ½å¤Ÿæ­£ç¡®åœ°æŠ›å‡ºé”™è¯¯ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_top_let_test.mbt
/// ```
/// ================================================================================

///|
test "Top Let Stmt Type Check" {
  let code =
    #|let x : Int = 42;
    #|let y = true;
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  // Type check for `let x : Int = 42;`
  let (top_let1, tok_view) = @parser.parse_top_let(tokens[:])
  let checked_top_let1 = ctx.check_top_let(top_let1)
  assert_true(checked_top_let1.ty.kind is Int)
  let ty1 = ctx.lookup_type("x")
  assert_true(ty1 is Some(t) && t.kind is Int && t.mutable == false)

  // Type check for `let y = true;`
  let (top_let2, _) = @parser.parse_top_let(tok_view)
  let checked_top_let2 = ctx.check_top_let(top_let2)
  assert_true(checked_top_let2.ty.kind is Bool)
  let ty2 = ctx.lookup_type("y")
  assert_true(ty2 is Some(t) && t.kind is Bool && t.mutable == false)
}
/// ================================================================================
/// # ç±»åž‹æŽ¨æ–­çš„é­”æ³•ï¼šç±»åž‹å˜é‡ä¸Žåˆä¸€ï¼ˆUnificationï¼‰
///
/// æ¬¢è¿Žæ¥åˆ°æˆ‘ä»¬ç¼–è¯‘å™¨ä¸­æœ€æ¿€åŠ¨äººå¿ƒçš„éƒ¨åˆ†ä¹‹ä¸€ï¼š**ç±»åž‹æŽ¨æ–­ï¼ˆType Inferenceï¼‰**ã€‚
/// ç±»åž‹æŽ¨æ–­å…è®¸ç¨‹åºå‘˜çœç•¥éƒ¨åˆ†æˆ–å…¨éƒ¨çš„ç±»åž‹æ³¨è§£ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æŽ¨å¯¼å‡ºè¿™äº›å˜é‡çš„ç±»åž‹ã€‚
/// å®ƒçš„æ ¸å¿ƒé­”æ³•ï¼Œå°±æ˜¯**ç±»åž‹å˜é‡ï¼ˆType Variablesï¼‰**å’Œ**åˆä¸€ï¼ˆUnificationï¼‰**ç®—æ³•ã€‚
///
/// ## ðŸ¤” ä¸ºä»€ä¹ˆéœ€è¦ç±»åž‹å˜é‡ï¼Ÿ
///
/// æƒ³è±¡ä¸€ä¸‹è¿™ä¸ªåœºæ™¯ï¼š
///
/// ```moonbit
/// let a = [];
/// ```
///
/// åœ¨è¿™ä¸€è¡Œï¼Œ`a` çš„ç±»åž‹æ˜¯ `Array[?]`ã€‚ä½†æˆ‘ä»¬å®Œå…¨ä¸çŸ¥é“ `?` åº”è¯¥æ˜¯ä»€ä¹ˆç±»åž‹ã€‚
/// ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¼•å…¥ä¸€ä¸ªâ€œå ä½ç¬¦â€ç±»åž‹ï¼Œç§°ä¹‹ä¸º**ç±»åž‹å˜é‡**ã€‚
/// æˆ‘ä»¬å¯ä»¥è¯´ `a` çš„ç±»åž‹æ˜¯ `Array[TypeVar(0)]`ï¼Œå…¶ä¸­ `0` æ˜¯è¿™ä¸ªç±»åž‹å˜é‡çš„å”¯ä¸€IDã€‚
/// æˆ‘ä»¬å°†è¿™ä¸ªä¿¡æ¯è®°å½•åœ¨ `Context` çš„ä¸€å¼ è¡¨é‡Œï¼ˆä¾‹å¦‚ `type_vars: Map[Int, TypeKind]`ï¼‰ã€‚
///
/// ## âš™ï¸ ç±»åž‹å˜é‡å¦‚ä½•å·¥ä½œï¼šåˆä¸€ï¼ˆUnificationï¼‰
///
/// ç±»åž‹å˜é‡çš„çœŸæ­£å¨åŠ›åœ¨äºŽå®ƒä»¬å¦‚ä½•é€šè¿‡ä»£ç çš„ä¸Šä¸‹æ–‡æ¥èŽ·å¾—å…·ä½“çš„ç±»åž‹ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºâ€œåˆä¸€â€ã€‚
///
/// **åœºæ™¯1ï¼šæŽ¨æ–­å‡ºå…·ä½“ç±»åž‹**
///
/// å¦‚æžœæˆ‘ä»¬æŽ¥ä¸‹æ¥çœ‹åˆ° `a.push(1)`ï¼Œç±»åž‹æ£€æŸ¥å™¨ä¼šåˆ†æž `push` å‡½æ•°ã€‚å®ƒçŸ¥é“ `push` çš„å‚æ•°ç±»åž‹åº”è¯¥ä¸Žæ•°ç»„çš„å…ƒç´ ç±»åž‹ç›¸åŒã€‚
/// å› æ­¤ï¼Œ`Int` ç±»åž‹å¿…é¡»ä¸Ž `TypeVar(0)` å…¼å®¹ã€‚
/// æ­¤æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥**åˆä¸€** `TypeVar(0)` å’Œ `Int`ï¼Œåœ¨æˆ‘ä»¬çš„è¡¨ä¸­è®°å½•ä¸‹ï¼š`TypeVar(0) = Int`ã€‚
/// `a` çš„ç±»åž‹ä¹‹è°œå°±æ­¤è§£å¼€ï¼Œå®ƒæ˜¯ä¸€ä¸ª `Array[Int]`ã€‚
///
/// **åœºæ™¯2ï¼šå…³è”ä¸¤ä¸ªæœªçŸ¥ç±»åž‹**
///
/// å‡è®¾æˆ‘ä»¬æœ‰ `let b = []`ï¼Œå®ƒçš„ç±»åž‹æ˜¯ `Array[TypeVar(1)]`ã€‚
/// å¦‚æžœä»£ç ä¸­å‡ºçŽ°äº† `a == b`ï¼Œè¿™æ„å‘³ç€ `a` å’Œ `b` çš„ç±»åž‹å¿…é¡»å…¼å®¹ã€‚
/// ä¹Ÿå°±æ˜¯è¯´ `Array[TypeVar(0)]` å¿…é¡»ä¸Ž `Array[TypeVar(1)]` å…¼å®¹ï¼Œè¿™è¿›ä¸€æ­¥è¦æ±‚ `TypeVar(0)` å¿…é¡»ä¸Ž `TypeVar(1)` å…¼å®¹ã€‚
///
/// æ­¤æ—¶ï¼Œæˆ‘ä»¬å°† `TypeVar(0)` å’Œ `TypeVar(1)` **åˆä¸€**ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¡¨ä¸­è®°å½• `TypeVar(1) = TypeVar(0)`ã€‚
/// è¿™å°±åƒå»ºç«‹äº†ä¸€ä¸ªâ€œç­‰ä»·å…³ç³»â€ã€‚çŽ°åœ¨ï¼Œä»»ä½•å…³äºŽ `TypeVar(0)` çš„ä¿¡æ¯ï¼Œéƒ½å°†è‡ªåŠ¨ä¼ é€’ç»™ `TypeVar(1)`ã€‚
///
/// **åœºæ™¯3ï¼šä¿¡æ¯ä¼ é€’**
///
/// å»¶ç»­åœºæ™¯2ï¼Œå¦‚æžœæˆ‘ä»¬ç¨åŽçœ‹åˆ°äº† `a.push(1)`ï¼Œæˆ‘ä»¬æŽ¨æ–­å‡º `TypeVar(0) = Int`ã€‚
/// å› ä¸ºæˆ‘ä»¬å·²ç»çŸ¥é“ `TypeVar(1) = TypeVar(0)`ï¼Œæ‰€ä»¥æˆ‘ä»¬ç«‹åˆ»ä¹ŸçŸ¥é“äº† `TypeVar(1) = Int`ã€‚
/// `b` çš„ç±»åž‹ä¹Ÿéšä¹‹ç¡®å®šä¸º `Array[Int]`ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `is_type_compatible` ä¸­çš„ `TypeVar` é€»è¾‘
///
/// ä½ çš„ä»»åŠ¡å°±æ˜¯å°†ä¸Šè¿°é€»è¾‘åœ¨ `typecheck/typedef.mbt` çš„ `is_type_compatible` å‡½æ•°ä¸­å®žçŽ°ã€‚
/// ä½ éœ€è¦ä¸º `match (a, b)` æ·»åŠ å¤„ç† `TypeVar` çš„åˆ†æ”¯ï¼š
///
/// *   **`TypeVar` vs. å…·ä½“ç±»åž‹ï¼ˆä¾‹å¦‚ `(TypeVar(id), Int)`ï¼‰ï¼š**
///     å°†ç±»åž‹å˜é‡ `id` ä¸Žè¯¥å…·ä½“ç±»åž‹è¿›è¡Œåˆä¸€ã€‚
/// *   **`TypeVar` vs. `TypeVar`ï¼ˆä¾‹å¦‚ `(TypeVar(id_a), TypeVar(id_b))`ï¼‰ï¼š**
///     å°†ä¸¤ä¸ªç±»åž‹å˜é‡è¿›è¡Œåˆä¸€ã€‚
///
/// ä½ å¯èƒ½éœ€è¦ä¸€ä¸ªè¾…åŠ©å‡½æ•°ï¼Œä¾‹å¦‚ `set_var_type_to_typekind`ï¼Œæ¥æ›´æ–°ä½ çš„ç±»åž‹å˜é‡è¡¨ï¼Œå¹¶å¤„ç†å¥½â€œç­‰ä»·å…³ç³»â€çš„ä¼ é€’ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// æœ¬æ¬¡çš„æµ‹è¯•ç”¨ä¾‹ä¼šç›´æŽ¥è°ƒç”¨ `is_type_compatible` æ¥éªŒè¯ä½ çš„åˆä¸€ç®—æ³•æ˜¯å¦æ­£ç¡®ã€‚
///
/// ```bash
/// moon test -p typecheck -f typecheck_type_var_test.mbt
/// ```
///
/// åŠ æ²¹ï¼è¿™æ˜¯é€šå¾€çŽ°ä»£ç±»åž‹ç³»ç»Ÿæœ€å…³é”®ã€ä¹Ÿæœ€æœ‰è¶£çš„ä¸€æ­¥ï¼
/// ================================================================================

///|
test "Type Var Test - 1" {
  let ctx = Context::new()
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_vars.set(2, TypeVar(2))
  ctx.type_vars.set(3, TypeVar(3))
  // TVar(0) = Double
  let t1 = ctx.is_type_compatible(TypeVar(0), Double)
  assert_true(t1 is true)
  assert_true(ctx.type_vars.get(0).unwrap() is Double)
  // TVar(1) = TVar(0)
  let t2 = ctx.is_type_compatible(TypeVar(1), TypeVar(0))
  assert_true(t2 is true)
  assert_true(ctx.type_vars.get(1).unwrap() is Double)
  // TVar(2) = TVar(3)
  let t3 = ctx.is_type_compatible(TypeVar(2), TypeVar(3))
  assert_true(t3 is true)
  // TVAr(3) = Int, therefore TVar(2) = Int
  let t4 = ctx.is_type_compatible(TypeVar(3), Int)
  assert_true(t4 is true)
  assert_true(ctx.type_vars.get(2).unwrap() is Int)
  assert_true(ctx.type_vars.get(3).unwrap() is Int)
  let t5 = ctx.is_type_compatible(TypeVar(2), Double)
  assert_true(t5 is false)
}

///|
///
/// 0 == 1 == 2 == 3
/// 2 == (Double, Int)
///
/// 0, 1, 2, 3 should all resolve to (Double, Int)
test "Type Var Test - 2" {
  let ctx = Context::new()
  ctx.type_vars.set(0, TypeVar(0))
  ctx.type_vars.set(1, TypeVar(1))
  ctx.type_vars.set(2, TypeVar(2))
  ctx.type_vars.set(3, TypeVar(3))
  //
  let _ = ctx.is_type_compatible(TypeVar(0), TypeVar(1))
  let _ = ctx.is_type_compatible(TypeVar(1), TypeVar(2))
  let _ = ctx.is_type_compatible(TypeVar(2), TypeVar(3))
  let _ = ctx.is_type_compatible(TypeVar(3), TypeVar(0))
  let _ = ctx.is_type_compatible(TypeVar(2), Tuple([Double, Int]))
  let t0 = ctx.type_vars.get(0).unwrap()
  let t1 = ctx.type_vars.get(1).unwrap()
  let t2 = ctx.type_vars.get(2).unwrap()
  let t3 = ctx.type_vars.get(3).unwrap()
  assert_true(t0 is Tuple([Double, Int]))
  assert_true(t1 is Tuple([Double, Int]))
  assert_true(t2 is Tuple([Double, Int]))
  assert_true(t3 is Tuple([Double, Int]))
}
/// ================================================================================
/// # ç±»åž‹æ£€æŸ¥æŽ§åˆ¶æµï¼šwhile å¾ªçŽ¯
///
/// `while` æ˜¯æˆ‘ä»¬è¯­è¨€ä¸­å”¯ä¸€çš„å¾ªçŽ¯ç»“æž„ã€‚ä¸Ž `if-else` ä¸åŒï¼Œ`while` å¾ªçŽ¯æœ¬èº«ä¸äº§ç”Ÿå€¼ï¼Œå› æ­¤å®ƒçš„ç±»åž‹æ£€æŸ¥è¦ç®€å•å¾—å¤šã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `check_while_stmt`
///
/// ä½ çš„ä»»åŠ¡æ˜¯åœ¨ `typecheck/while_stmt.mbt` æ–‡ä»¶ä¸­å®žçŽ° `Context::check_while_stmt` å‡½æ•°ã€‚
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// 1.  **æ£€æŸ¥æ¡ä»¶ï¼š**
///     *   `while` åŽé¢çš„æ¡ä»¶è¡¨è¾¾å¼å¿…é¡»æ˜¯ `Bool` ç±»åž‹ã€‚ä½ éœ€è¦è°ƒç”¨ `check_expr` æ£€æŸ¥è¯¥æ¡ä»¶ã€‚
///
/// 2.  **æ£€æŸ¥å¾ªçŽ¯ä½“ï¼š**
///     *   è°ƒç”¨ `check_block_expr` æ¥æ£€æŸ¥å¾ªçŽ¯ä½“çš„ä»£ç å—ã€‚
///     *   ç”±äºŽ `while` å¾ªçŽ¯ä¸äº§ç”Ÿå€¼ï¼Œå¾ªçŽ¯ä½“å—çš„ç±»åž‹å¯ä»¥è¢«å¿½ç•¥ã€‚
///
/// 3.  **`while` è¯­å¥çš„ç±»åž‹ï¼š**
///     *   `while` è¯­å¥æœ¬èº«çš„ç±»åž‹æ°¸è¿œæ˜¯ `Unit`ã€‚
///
/// ---
///
/// **é˜¶æ®µæ€§æµ‹è¯•ï¼š**
///
/// ```bash
/// moon test -p typecheck -f typecheck_while_stmt_test.mbt
/// ```
/// ================================================================================

///|
test "While Stmt TypeCheck Test" {
  let code =
    #|let mut i = 0;
    #|while i < 10 {
    #|  i += 1;
    #|}
  let ctx = Context::new()
  // Parse
  let tokens = @lexer.tokenize(code)
  let (let_stmt, tok_view) = @parser.parse_let_mut_stmt(tokens[:])
  let _ = ctx.check_let_mut_stmt(let_stmt)
  let (while_stmt, _) = @parser.parse_while_stmt(tok_view)
  let _ = ctx.check_while_stmt(while_stmt)

}
/// ================================================================================
/// # ðŸŽ‰ ç»ˆç« ï¼šå®Œæˆç±»åž‹æ£€æŸ¥å™¨
///
/// ðŸŽŠ **æ­å–œä½ ï¼ä½ å·²ç»æ¥åˆ°äº†ç±»åž‹æ£€æŸ¥é˜¶æ®µçš„æœ€åŽä¸€å…³ï¼** ðŸŽŠ
///
/// ç»è¿‡å‰é¢çš„æ‰€æœ‰æŒ‘æˆ˜ï¼Œä½ å·²ç»æž„å»ºäº†ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„ç±»åž‹æ£€æŸ¥ç³»ç»Ÿã€‚çŽ°åœ¨ï¼Œæ˜¯æ—¶å€™å®Œæˆæœ€åŽçš„æ­¥éª¤ï¼š
/// å®žçŽ° `typechecker.mbt` ä¸­çš„ `typecheck` å‡½æ•°ï¼Œå®ƒå°†éåŽ†æ•´ä¸ªè¯­æ³•æ ‘ï¼Œå°†æ‰€æœ‰ `TypeVar` æ›¿æ¢ä¸ºå…·ä½“çš„å®žä½“ç±»åž‹ã€‚
///
/// ## ðŸŽ¯ ä½ çš„ä»»åŠ¡ï¼šå®žçŽ° `typecheck` å‡½æ•°
///
/// `typecheck` å‡½æ•°æ˜¯æ•´ä¸ªç±»åž‹æ£€æŸ¥é˜¶æ®µçš„æœ€ç»ˆå…¥å£ã€‚å®ƒçš„æ ¸å¿ƒä»»åŠ¡æ˜¯ï¼š
///
/// 1. **éåŽ†æ•´ä¸ªè¯­æ³•æ ‘**ï¼šä»Žç¨‹åºçš„æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé€’å½’åœ°è®¿é—®æ¯ä¸€ä¸ªè¯­æ³•èŠ‚ç‚¹
/// 2. **æ›¿æ¢ç±»åž‹å˜é‡**ï¼šå°† AST ä¸­æ‰€æœ‰çš„ `TypeVar` æ›¿æ¢ä¸ºé€šè¿‡ç±»åž‹æ£€æŸ¥å¾—åˆ°çš„å®žé™…ç±»åž‹
/// 3. **è¿”å›žç±»åž‹åŒ–çš„ AST**ï¼šè¿”å›žä¸€ä¸ªæ‰€æœ‰ç±»åž‹éƒ½å·²ç¡®å®šçš„è¯­æ³•æ ‘
///
/// ### ðŸ’¡ å®žçŽ°æ€è·¯
///
/// ä½ å·²ç»å®žçŽ°äº† `check_program` å‡½æ•°ï¼Œå®ƒä¼šï¼š
/// - è¿›è¡Œå®Œæ•´çš„ç±»åž‹æ£€æŸ¥
/// - åœ¨ `Context` ä¸­è®°å½•æ‰€æœ‰ç±»åž‹ä¿¡æ¯
/// - ç¡®ä¿ç¨‹åºåœ¨ç±»åž‹å±‚é¢æ˜¯æ­£ç¡®çš„
///
/// çŽ°åœ¨ï¼Œä½ éœ€è¦å®žçŽ° `typecheck` å‡½æ•°ï¼Œå®ƒä¼šï¼š
/// - è°ƒç”¨ `check_program` è¿›è¡Œç±»åž‹æ£€æŸ¥
/// - éåŽ† ASTï¼Œå°† `TypeVar` æ›¿æ¢ä¸ºå®žé™…ç±»åž‹
/// - è¿”å›žç±»åž‹åŒ–åŽçš„ AST
///
/// **å…³é”®æ­¥éª¤ï¼š**
///
/// 1. **è°ƒç”¨ç±»åž‹æ£€æŸ¥**ï¼šä½¿ç”¨ `check_program` å¯¹ç¨‹åºè¿›è¡Œç±»åž‹æ£€æŸ¥
/// 2. **éåŽ†æ›¿æ¢**ï¼šå®žçŽ°ä¸€ä¸ªéåŽ†å‡½æ•°ï¼Œé€’å½’åœ°è®¿é—®æ¯ä¸ªèŠ‚ç‚¹
/// 3. **ç±»åž‹æ›¿æ¢**ï¼šå¯¹äºŽåŒ…å« `TypeVar` çš„èŠ‚ç‚¹ï¼Œä»Ž `Context` ä¸­æŸ¥æ‰¾å¯¹åº”çš„å®žé™…ç±»åž‹å¹¶æ›¿æ¢
/// 4. **ä¿æŒç»“æž„**ï¼šç¡®ä¿æ›¿æ¢åŽçš„ AST ç»“æž„ä¸ŽåŽŸå§‹ç»“æž„å®Œå…¨ä¸€è‡´
///
/// ## ðŸš€ è§è¯ä½ çš„æˆæžœï¼
///
/// å®Œæˆè¿™ä¸ªä»»åŠ¡åŽï¼Œä½ å°±æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½å®Œå¤‡çš„ MiniMoonBit ç±»åž‹æ£€æŸ¥å™¨ï¼
/// ä½ å¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤æ¥æµ‹è¯•ä½ çš„å®žçŽ°ï¼š
///
/// ```bash
/// moon test -p typecheck -f typechecker_test.mbt
/// ```
///
/// è¿™ä¸ªæµ‹è¯•ä¼šéªŒè¯ä½ çš„ `typecheck` å‡½æ•°æ˜¯å¦æ­£ç¡®åœ°å°†æ‰€æœ‰ `TypeVar` æ›¿æ¢ä¸ºäº†å…·ä½“çš„ç±»åž‹ã€‚
///
/// ## ðŸŽŠ æ­å–œä½ å®Œæˆäº†ç±»åž‹æ£€æŸ¥çš„æ‰€æœ‰å†…å®¹ï¼
///
/// ä½ å·²ç»æˆåŠŸæž„å»ºäº†ä¸€ä¸ªå®Œæ•´çš„ç±»åž‹æ£€æŸ¥ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š
/// - âœ… åŸºç¡€ç±»åž‹æ£€æŸ¥
/// - âœ… è¡¨è¾¾å¼ç±»åž‹æŽ¨æ–­
/// - âœ… è¯­å¥ç±»åž‹æ£€æŸ¥
/// - âœ… å‡½æ•°ç±»åž‹æ£€æŸ¥
/// - âœ… ç»“æž„ä½“ç±»åž‹æ£€æŸ¥
/// - âœ… ç¨‹åºçº§ç±»åž‹æ£€æŸ¥
/// - âœ… ç±»åž‹å˜é‡æ›¿æ¢
///
/// **è¿™æ˜¯ä¸€ä¸ªäº†ä¸èµ·çš„æˆå°±ï¼** ä½ å·²ç»æŽŒæ¡äº†çŽ°ä»£ç¼–è¯‘å™¨ä¸­æœ€æ ¸å¿ƒçš„é™æ€åˆ†æžæŠ€æœ¯ä¹‹ä¸€ã€‚
///
/// **æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¿›å…¥ç¼–è¯‘å™¨çš„ä¸‹ä¸€ä¸ªæ¿€åŠ¨äººå¿ƒçš„é˜¶æ®µï¼šKNF è½¬æ¢ï¼**
/// ================================================================================

///|
test "Program TypeCheck Test - 2" {
  let code =
    #|let a = 3;
    #|let b = 4;
    #|fn fold(arr: Array[Int], f: (Int, Int) -> Int, init: Int) -> Int { 
    #|  let mut result = init;
    #|  let mut i = 0; 
    #|  while i < arr.length() {
    #|    result = f(result, arr[i]);
    #|  }
    #|  result
    #|}
    #|
    #|fn main {
    #|  fn max(a, b) { if a > b { a } else { b } }
    #|  fn min(a, b) { if a < b { a } else { b } }
    #|  let numbers = [a, 1, b, 1, 5, 9, 2, 6, 5];
    #|  let maximum = fold(numbers, max, -1000);
    #|  let minimum = fold(numbers, min, 1000);
    #|  let max_min_diff = maximum - minimum;
    #|  println(max_min_diff);
    #|}
  let tokens = @lexer.tokenize(code)
  let program = @parser.parse(tokens)
  let program = typecheck(program)
  let program_str = program.to_string()
  assert_false(program_str.contains("TypeVar"))
}
