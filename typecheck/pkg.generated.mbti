// Generated using `moon info`, DON'T EDIT IT
package "Kaida-Amethyst/MiniMoonBit/typecheck"

import(
  "Kaida-Amethyst/MiniMoonBit/lexer"
  "Kaida-Amethyst/MiniMoonBit/parser"
  "Kaida-Amethyst/either"
)

// Values
fn typecheck(@parser.Program) -> Program raise TypeCheckError

// Errors
pub(all) suberror TypeCheckError String
impl Show for TypeCheckError

// Types and methods
pub(all) struct ApplyExpr {
  kind : ApplyExprKind
  ty : TypeKind
  toks : ArrayView[@lexer.Token]
}
fn ApplyExpr::to_string(Self, color? : Bool) -> String
impl Show for ApplyExpr

pub(all) enum ApplyExprKind {
  AtomExpr(AtomExpr)
  ArrayAccess(ApplyExpr, Expr)
  FieldAccess(ApplyExpr, String)
  Call(ApplyExpr, Array[Expr])
}
impl Show for ApplyExprKind

pub(all) enum AssignOp {
  Assign
  PlusAssign
  MinusAssign
  MultAssign
  DivAssign
  ModAssign
}
impl Eq for AssignOp
impl Show for AssignOp

pub(all) struct AssignStmt {
  left_value : LeftValue
  op : AssignOp
  expr : Expr
}
fn AssignStmt::to_string(Self, color? : Bool) -> String
impl Show for AssignStmt

pub(all) struct AtomExpr {
  kind : AtomExprKind
  ty : TypeKind
  toks : ArrayView[@lexer.Token]
}
fn AtomExpr::to_string(Self, color? : Bool) -> String
impl Show for AtomExpr

pub(all) enum AtomExprKind {
  Int(Int)
  Int64(Int64)
  UInt(UInt)
  UInt64(UInt64)
  Double(Double)
  Float(Double)
  Char(Char)
  Bool(Bool)
  String(String)
  Ident(String)
  Unit
  Paren(Expr)
  Tuple(Array[Expr])
  Array(Array[Expr])
  ArrayMake(Expr, Expr)
  StructConstruct(StructConstructExpr)
  EnumConstruct(String, String, Array[Expr])
  Cast(TypeKind, Expr)
  BitCast(TypeKind, Expr)
}
impl Show for AtomExprKind

pub(all) enum BinaryOp {
  Add
  Sub
  Mul
  Div
  Mod
  ShiftLeft
  ShiftRight
  Eq
  NE
  LT
  GT
  LE
  GE
  And
  Or
  BitAnd
  BitOr
}
impl Eq for BinaryOp
impl Show for BinaryOp

pub(all) struct BlockExpr {
  stmts : Array[Stmt]
  ty : TypeKind
}
fn BlockExpr::to_string(Self, color? : Bool) -> String
impl Show for BlockExpr

pub(all) struct Context {
  mut type_env : Env
  type_vars : Map[Int, TypeKind]
  struct_defs : Map[String, StructDef]
  enum_defs : Map[String, EnumDef]
  func_types : Map[String, TypeKind]
  mut current_func_ret_ty : TypeKind?
  // private fields
}
fn Context::add_type_var(Self) -> TypeKind
fn Context::check_apply_expr(Self, @parser.ApplyExpr) -> ApplyExpr
fn Context::check_array_expr(Self, Array[@parser.Expr]) -> (AtomExprKind, TypeKind)
fn Context::check_array_make_expr(Self, @parser.Expr, @parser.Expr) -> (AtomExprKind, TypeKind)
fn Context::check_assign_stmt(Self, @parser.AssignStmt) -> AssignStmt raise TypeCheckError
fn Context::check_atom_expr(Self, @parser.AtomExpr) -> AtomExpr
fn Context::check_block_expr(Self, @parser.BlockExpr) -> BlockExpr
fn Context::check_enum_constuct_expr(Self, String?, String, Array[@parser.Expr], @parser.AtomExpr) -> (AtomExprKind, TypeKind)
fn Context::check_enum_def(Self, @parser.EnumDef) -> EnumDef raise TypeCheckError
fn Context::check_expr(Self, @parser.Expr) -> Expr
fn Context::check_extern_function(Self, @parser.ExternFunction) -> ExternFunction raise TypeCheckError
fn Context::check_for_stmt(Self, @parser.ForStmt) -> ForStmt raise TypeCheckError
fn Context::check_if_expr(Self, @parser.IfExpr) -> IfExpr
fn Context::check_left_value(Self, @parser.LeftValue) -> LeftValue raise TypeCheckError
fn Context::check_let_mut_stmt(Self, @parser.LetMutStmt) -> LetMutStmt raise TypeCheckError
fn Context::check_let_stmt(Self, @parser.LetStmt) -> LetStmt raise TypeCheckError
fn Context::check_local_function(Self, @parser.LocalFunction) -> LocalFunction raise TypeCheckError
fn Context::check_match_expr(Self, @parser.MatchExpr) -> MatchExpr
fn Context::check_match_expr_type(Self, @parser.MatchExpr) -> MatchExpr
fn Context::check_parser_type(Self, @parser.Type, mutable? : Bool) -> Type raise TypeCheckError
fn Context::check_parser_typekind(Self, @parser.TypeKind) -> TypeKind raise TypeCheckError
fn Context::check_program(Self, @parser.Program) -> Program raise TypeCheckError
fn Context::check_stmt(Self, @parser.Stmt) -> Stmt raise TypeCheckError
fn Context::check_struct_construct_expr(Self, @parser.StructConstructExpr) -> (AtomExprKind, TypeKind)
fn Context::check_struct_def(Self, @parser.StructDef) -> StructDef raise TypeCheckError
fn Context::check_top_function(Self, @parser.TopFunction) -> TopFunction raise TypeCheckError
fn Context::check_top_let(Self, @parser.TopLet) -> TopLet raise TypeCheckError
fn Context::check_tuple_expr(Self, Array[@parser.Expr]) -> (AtomExprKind, TypeKind)
fn Context::check_while_stmt(Self, @parser.WhileStmt) -> WhileStmt raise TypeCheckError
fn Context::collect_function_types(Self, @parser.Program) -> Unit raise TypeCheckError
fn Context::collect_struct_or_enum_names(Self, @parser.Program) -> Unit raise TypeCheckError
fn Context::enter_scope(Self) -> Unit
fn Context::exit_scope(Self) -> Unit
fn Context::find_enum_def_by_variant_name(Self, String) -> Array[EnumDef]
fn Context::has_error_happened(Self) -> Bool
fn Context::is_type_compatible(Self, TypeKind, TypeKind) -> Bool
fn Context::lookup_type(Self, String) -> Type?
fn Context::new() -> Self
fn Context::set_current_func_ret_ty(Self, TypeKind) -> Unit
fn Context::set_error_happened(Self) -> Unit
fn Context::substitute_apply_expr_type_var(Self, ApplyExpr) -> ApplyExpr raise TypeCheckError
fn Context::substitute_assign_stmt_type_var(Self, AssignStmt) -> AssignStmt raise TypeCheckError
fn Context::substitute_atom_expr_type_var(Self, AtomExpr) -> AtomExpr raise TypeCheckError
fn Context::substitute_block_expr_type_var(Self, BlockExpr) -> BlockExpr raise TypeCheckError
fn Context::substitute_expr_type_var(Self, Expr) -> Expr raise TypeCheckError
fn Context::substitute_for_stmt_type_var(Self, ForStmt) -> ForStmt raise TypeCheckError
fn Context::substitute_if_expr_type_var(Self, IfExpr) -> IfExpr raise TypeCheckError
fn Context::substitute_left_value_type_var(Self, LeftValue) -> LeftValue raise TypeCheckError
fn Context::substitute_let_mut_stmt_type_var(Self, LetMutStmt) -> LetMutStmt raise TypeCheckError
fn Context::substitute_let_stmt_type_var(Self, LetStmt) -> LetStmt raise TypeCheckError
fn Context::substitute_local_function_type_var(Self, LocalFunction) -> LocalFunction raise TypeCheckError
fn Context::substitute_match_expr_type_var(Self, MatchExpr) -> MatchExpr raise TypeCheckError
fn Context::substitute_stmt_type_var(Self, Stmt) -> Stmt raise TypeCheckError
fn Context::substitute_struct_construct_expr_type_var(Self, StructConstructExpr) -> StructConstructExpr raise TypeCheckError
fn Context::substitute_top_function_type_var(Self, TopFunction) -> TopFunction raise TypeCheckError
fn Context::substitute_top_let_type_var(Self, TopLet) -> TopLet raise TypeCheckError
fn Context::substitute_type_var(Self, Program) -> Program raise TypeCheckError
fn Context::substitute_while_stmt_type_var(Self, WhileStmt) -> WhileStmt raise TypeCheckError
fn Context::throw_(Self, @lexer.Token, String, @lexer.ThrowLevel) -> Unit

pub struct EnumDef {
  name : String
  enum_fields : Array[EnumField]
}
fn EnumDef::get_field(Self, String) -> EnumField?
fn EnumDef::to_string(Self, color? : Bool) -> String
impl Show for EnumDef

pub struct EnumField {
  name : String
  types : Array[TypeKind]
}
fn EnumField::to_string(Self, color? : Bool) -> String
impl Show for EnumField

pub(all) struct Env {
  local_ : Map[String, Type]
  parent : Env?
}
fn Env::get(Self, String) -> Type?
fn Env::new(parent? : Self?) -> Self
fn Env::set(Self, String, Type) -> Unit

pub(all) struct Expr {
  kind : ExprKind
  ty : TypeKind
  toks : ArrayView[@lexer.Token]
}
fn Expr::to_string(Self, color? : Bool) -> String
impl Show for Expr

pub(all) enum ExprKind {
  ApplyExpr(ApplyExpr)
  BlockExpr(BlockExpr)
  NotExpr(Expr)
  NegExpr(Expr)
  BinaryExpr(BinaryOp, Expr, Expr)
  IfExpr(IfExpr)
  MatchExpr(MatchExpr)
}
impl Show for ExprKind

pub(all) struct ExternFunction {
  fname : String
  param_list : Array[Param]
  ret_ty : TypeKind
  ffi_name : String
}
fn ExternFunction::to_string(Self, color? : Bool) -> String
impl Show for ExternFunction

pub(all) struct ForStmt {
  inits : Array[(String, Expr)]
  cond : Expr
  steps : Array[(String, AssignOp, Expr)]
  body : BlockExpr
}
fn ForStmt::to_string(Self, color? : Bool) -> String
impl Show for ForStmt

pub(all) struct IfExpr {
  cond : Expr
  then_block : BlockExpr
  else_block : @either.Either[IfExpr, BlockExpr]?
  ty : TypeKind
}
fn IfExpr::to_string(Self, color? : Bool) -> String
impl Show for IfExpr

pub(all) struct LeftValue {
  kind : LeftValueKind
  ty : Type
}
fn LeftValue::to_string(Self, color? : Bool) -> String
impl Show for LeftValue

pub(all) enum LeftValueKind {
  Ident(String)
  ArrayAccess(LeftValue, Expr)
  FieldAccess(LeftValue, String)
}
impl Show for LeftValueKind

pub(all) struct LetMutStmt {
  name : String
  ty : TypeKind
  expr : Expr
}
fn LetMutStmt::to_string(Self, color? : Bool) -> String
impl Show for LetMutStmt

pub(all) struct LetStmt {
  pattern : Pattern
  ty : TypeKind
  expr : Expr
}
fn LetStmt::to_string(Self, color? : Bool) -> String
impl Show for LetStmt

pub(all) struct LocalFunction {
  fname : String
  param_list : Array[(String, Type)]
  ret_ty : Type
  body : BlockExpr
}
fn LocalFunction::to_string(Self, color? : Bool) -> String
impl Show for LocalFunction

pub struct MatchArm {
  pattern : Pattern
  match_guard : Expr?
  body : Expr
  toks : ArrayView[@lexer.Token]
}
fn MatchArm::to_string(Self, color? : Bool) -> String
impl Show for MatchArm

pub struct MatchExpr {
  cond : Expr
  arms : Array[MatchArm]
  ty : TypeKind
}
fn MatchExpr::to_string(Self, color? : Bool) -> String
impl Show for MatchExpr

pub(all) struct Param {
  name : String
  ty : TypeKind
}
fn Param::to_string(Self, color? : Bool) -> String
impl Show for Param

pub(all) struct Pattern {
  kind : PatternKind
}
fn Pattern::to_string(Self, color? : Bool) -> String
impl Eq for Pattern
impl Show for Pattern

pub(all) enum PatternKind {
  Wildcard
  Boolean(Bool)
  Integer(Int)
  Ident(String)
  Tuple(Array[Pattern])
  EnumVariant(String, String, Array[Pattern])
}
impl Eq for PatternKind
impl Show for PatternKind

pub(all) enum PatternSet {
  Empty
  Single(PatternKind)
  Universal(TypeKind)
  NumberComplement(Array[Int])
  Union(Array[PatternSet])
  EnumConstructor(String, String, Array[PatternSet])
  TupleConstructor(Array[PatternSet])
}
impl Eq for PatternSet
impl Show for PatternSet

pub(all) struct Program {
  source_file : String
  top_lets : Map[String, TopLet]
  top_functions : Map[String, TopFunction]
  extern_funcions : Map[String, ExternFunction]
  struct_defs : Map[String, StructDef]
  enum_defs : Map[String, EnumDef]
}
fn Program::to_string(Self, color? : Bool) -> String
impl Show for Program

pub(all) struct Stmt {
  kind : StmtKind
}
fn Stmt::to_string(Self, color? : Bool) -> String
impl Show for Stmt

pub(all) enum StmtKind {
  LetStmt(LetStmt)
  LetMutStmt(LetMutStmt)
  AssignStmt(AssignStmt)
  WhileStmt(WhileStmt)
  ForStmt(ForStmt)
  ExprStmt(Expr)
  ReturnStmt(Expr?)
  LocalFunction(LocalFunction)
}
impl Show for StmtKind

pub(all) struct StructConstructExpr {
  name : String
  fields : Array[(String, Expr)]
  toks : ArrayView[@lexer.Token]
}
fn StructConstructExpr::to_string(Self, color? : Bool) -> String
impl Show for StructConstructExpr

pub(all) struct StructDef {
  name : String
  fields : Array[StructField]
  methods : Map[String, TypeKind]
}
fn StructDef::get_field_type(Self, String) -> Type?
fn StructDef::to_string(Self, color? : Bool) -> String
impl Show for StructDef

pub(all) struct StructField {
  name : String
  ty : Type
}
fn StructField::to_string(Self, color? : Bool) -> String
impl Show for StructField

pub(all) struct TopFunction {
  fname : String
  param_list : Array[Param]
  ret_ty : TypeKind
  body : BlockExpr
}
fn TopFunction::to_string(Self, color? : Bool) -> String
impl Show for TopFunction

pub struct TopLet {
  name : String
  ty : Type
  expr : Expr
}
fn TopLet::to_string(Self, color? : Bool) -> String
impl Show for TopLet

pub(all) struct Type {
  kind : TypeKind
  mutable : Bool
}
impl Show for Type

pub(all) enum TypeKind {
  Unit
  Bool
  Int
  Int64
  UInt
  UInt64
  Double
  Float
  Char
  String
  Tuple(Array[TypeKind])
  Array(TypeKind)
  Function(Array[TypeKind], TypeKind)
  Struct(String)
  Enum(String)
  Any
  TypeVar(Int)
}
impl Eq for TypeKind
impl Hash for TypeKind
impl Show for TypeKind

pub(all) struct WhileStmt {
  cond : Expr
  body : BlockExpr
}
fn WhileStmt::to_string(Self, color? : Bool) -> String
impl Show for WhileStmt

// Type aliases

// Traits

